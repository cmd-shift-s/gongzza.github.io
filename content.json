{"meta":{"title":"GongZza's blog","subtitle":null,"description":null,"author":"GongZza","url":"https://gongzza.github.io","root":"/"},"pages":[],"posts":[{"title":"VSCode Debugging for Node.js","slug":"vscode/debugging","date":"2019-06-19T17:32:10.000Z","updated":"2021-02-21T13:45:10.904Z","comments":true,"path":"vscode/debugging/","link":"","permalink":"https://gongzza.github.io/vscode/debugging/","excerpt":"","text":"VSCode - Debugging을 참고하여 작성하였습니다. VSCode Debugging for Node.jsExpress로 echo 서버를 개발하면서 mocha로 테스트 할 때 디버깅 환경을 구축해 볼 것입니다. Debugger extensionsVSCode는 기본적으로 Node.js 디버깅 기능을 제공합니다. 그래서 JavaScript, TypeScript 등 JavaScript로 변환해주는 언어들에 대해서 디버깅이 가능합니다. 다른 언어들은 VSCode Marketplat에서 Debugger를 찾아서 설치해서 사용할 수 있습니다. Launch configurationsF5를 누르면 디버그를 시작하게 됩니다. 만약 설정 파일이 없을 경우 추가 하라는 팝업이 뜨게 됩니다. 그러면 Open launch.json 버튼을 눌러서 launch.json 파일로 이동합니다. 현재 열려있는 파일을 기반으로 VSCode가 디버거를 찾아서 있을 경우 자동으로 추가해줍니다. 만약 찾지 못하였으면 Node.js를 선택해서 추가해줍니다. 여기서 저희는 Mocha로 디버그를 실행 할 것입니다. 그래서 설정을 다음과 같이 작성해 줍니다. .vscode/launch.json12345678910111213141516171819202122&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Run mocha&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/node_modules/mocha/bin/_mocha&quot;, &quot;args&quot;: [ &quot;--opts&quot;, &quot;test/mocha.opts&quot;, &quot;--timeout&quot;, &quot;0&quot;, // 디버깅 시간이 테스트 결과에 영향을 주지 않기 위해서, &quot;--colors&quot;, // terminal color와 같은 색으로 출력 ], // 디버그 실행 시 DEBUG CONSOLE 오픈 &quot;internalConsoleOptions&quot;: &quot;openOnSessionStart&quot; // 디버그 실행 시 TERMINAL에서 실행 // &quot;console&quot;: &quot;integratedTerminal&quot;, // &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot; &#125; ]&#125; Debug actions Continue / Pause F5: Step을 진행하지 않고 다음 Breakpoint까지 진행 Step Over F10: 현재 라인 실행 후 다음 라인으로 커서를 이동 Step Into F11: 다음 실행이 함수일 경우 함수 내부로 커서를 이동 Step Out ⇧F11: 현재 커서가 함수일 경우 함수 실행을 완료하고 호출한 곳으로 커서를 이동 Restart ⇧⌘F5 Stop ⇧F5 Echo serverPOST와 GET 모두 동작하는 echo 서버를 작성해 볼 것입니다. 123456789101112131415161718$ mkdir echo-server$ cd echo-server# package.json 초기화$ npm init -yWrote to /echo-server/package.json:...$ npm i -S typescript express ts-node+ express@4.17.1+ typescript@3.5.2$ npm i -D @types/express+ @types/express@4.17.0# tsconfig.json 초기화$ npx tsc --initmessage TS6071: Successfully created a tsconfig.json file. 이제 서버를 작성해 봅니다. src/app.ts1234567import express from &#x27;express&#x27;export const app = express()app.use(&#x27;/echo&#x27;, (req, res) =&gt; &#123; return res.send(req.query.msg || req.body.msg)&#125;) src/server.ts12345import &#123; app &#125; from &#x27;./app&#x27;const port = process.env.PORT || 3000app.listen(port, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`)) app.ts와 server.ts 파일로 분리한 이유는 supertest에서 서버를 실행 시켜서 API를 호출하기 때문에 중복으로 서버를 실행하지 않기 위해서 분리를 합니다. 그리고 서버가 켜져 있으면 테스트가 종료되지 않습니다. Test12345678$ npm i -D mocha @types/mocha supertest @types/supertest chai @types/chai ts-node+ supertest@4.0.2+ chai@4.2.0+ mocha@6.1.4+ ts-node@8.3.0+ @types/chai@4.1.7+ @types/mocha@5.2.7+ @types/supertest@2.0.7 mocha: Test Framework supertest: HTTP 호출 및 검사 chaijs: Assertion Library ts-node: ts 파일을 바로 실행할 때 사용 mocha는 ts를 해석할 수 없기 때문에 ts-node를 이용해서 ts로 작성된 테스트 파일을 실행합니다. GET과 POST로 /echo API를 요청하는 테스트를 작성합니다. test/app.ts12345678910111213141516171819202122232425262728293031323334import request from &#x27;supertest&#x27;import &#123; app &#125; from &#x27;../src/app&#x27;import &#123; expect &#125; from &#x27;chai&#x27;describe(&#x27;app&#x27;, () =&gt; &#123; const req = request(app) it(&#x27;GET /echo - returns msg&#x27;, async () =&gt; &#123; // given const msg = &#x27;message&#x27; // when const res = await req.get(&#x27;/echo&#x27;) .query(&#123; msg &#125;) .expect(200) // then expect(res.text).to.equal(msg) &#125;) it(&#x27;POST /echo - returns msg&#x27;, async () =&gt; &#123; // given const msg = &#x27;message&#x27; // when const res = await req.post(&#x27;/echo&#x27;) .send(&#123; msg &#125;) .expect(200) // then expect(res.text).to.equal(msg) &#125;)&#125;) mocha에서 사용할 옵션을 추가합니다. test/mocha.opts123--require ts-node&#x2F;register--extension tstest&#x2F;**&#x2F;*.test.ts test script를 수정합니다. package.json12345&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha&quot; &#125;&#125; 테스트를 수행합니다. 123456789101112131415161718$ npm t&gt; echo-server@1.0.0 test /echo-server&gt; mocha app echo ✓ GET /echo - returns msg 1) POST /echo - returns msgTypeError: Cannot read property &#x27;echo&#x27; of undefined 1 passing (27ms) 1 failing 1) app echo POST /echo - returns msg: Error: expected 200 &quot;OK&quot;, got 500 &quot;Internal Server Error&quot; 테스트가 실패하는 것을 확인할 수 있습니다. Debug이제 VSCode의 Debug를 사용해서 에러를 확인해 볼 것입니다. mocha.opts에 --grep app\\secho\\sPOST를 추가해서 실패했던 테스트만 수행하도록 합니다. 그리고 /echo api에서 res.send에 breakpoint를 찍고 F5를 눌러서 디버깅을 수행합니다. 오른쪽에 WATCH에서 req.body가 undefined인 것을 확인 할 수 있습니다. 즉, undefined에서 msg를 가져오려고 해서 에러가 발생한 것임을 알 수 있습니다. req.body가 undefined인 이유는 Content-Type: application/json을 해석하지 못해서 입니다. 다음과 같이 json 형식을 파싱할 수 있도록 추가해줍니다. src/app.ts1234567import express from &#x27;express&#x27;const app = express()app.use(express.json())... express.json()은 body-parser를 기반으로 작성된 built-in middleware입니다. test/mocha.opts에서 --grep app\\secho\\sPOST를 지우고 다시 테스트를 수행하면 모든 테스트가 성공하는 것을 확인 할 수 있습니다. 12345678910$ npm t &gt; echo-server@1.0.0 test /echo-server&gt; mocha app ✓ GET /echo - returns msg ✓ POST /echo - returns msg 2 passing (34ms) 결론디버깅 없이 테스트 실패를 확인하기 위해서는 데이터를 추측해서 하나씩 출력해보거나 조건문 마다 현재 단계를 출력해서 어느 단계에서 로그가 멈췄는지 확인해 봐야 하고 다시 로그를 지우는 수고가 필요합니다. 하지만, 디버그 모드로 실행하면 비즈니스 로직 또는 테스트 코드를 한단계씩 확인할 수 있기 때문에 문제점을 바로 확인하고 고칠 수 있어서 훨씬 빠르고 정확하고 편하게 문제를 해결 할 수 있습니다. 참고 https://code.visualstudio.com/docs/editor/debugging https://code.visualstudio.com/docs/nodejs/nodejs-debugging","categories":[{"name":"VSCode","slug":"VSCode","permalink":"https://gongzza.github.io/categories/VSCode/"}],"tags":[{"name":"mocha","slug":"mocha","permalink":"https://gongzza.github.io/tags/mocha/"},{"name":"vscode","slug":"vscode","permalink":"https://gongzza.github.io/tags/vscode/"},{"name":"debugging","slug":"debugging","permalink":"https://gongzza.github.io/tags/debugging/"}]},{"title":"업무 효율을 올리기 위해 키보드에서 손 떼지 않기 on Mac","slug":"mac/shortcuts","date":"2019-06-09T12:14:25.000Z","updated":"2021-02-21T13:45:10.903Z","comments":true,"path":"mac/shortcuts/","link":"","permalink":"https://gongzza.github.io/mac/shortcuts/","excerpt":"","text":"업무 효율을 올리기 위해 키보드에서 손 떼지 않기 on Mac단축키를 사용하면 빠르고 정확하게 원하는 작업을 수행할 수 있습니다. 목차 Keyboard 설정 Browser Vim BetterTouchTool Keyboard 설정입력 지연 시간 단축키보드를 사용하기 전에 빠른 입력을 위해서 설정을 조금 건드려 줍니다. 키보드 환경설정에 들어가셔서 다음과 같이 “키 반복”과 “반복 지연 시간”을 빠르고 짧게 올려줍니다. 모든 컨트롤 선택Tab을 이용해서 모든 컨트롤(취소, 저장 버튼 등)에 포커스를 줄 수 있도록 합니다. 예를 들어서 “Don’t Save”, “Cancel”, “Save” 선택지가 있을 경우 “Don’t Save” 버튼에 포커스가 되어 있는 것을 볼 수 있습니다. 이렇게 포커스가 되어 있을 때 키보드에서 스페이스를 누르면 “Don’t Save” 버튼이 눌립니다. 여기서 주의해야 할 사항은 엔터를 누르면 현재 포커스와 상관없이 파란색으로 표시된 버튼이 눌리게 됩니다. 즉, 위 화면에서 엔터를 누르면 “Save” 버튼이 눌리게 됩니다. 기본 단축키커서를 이동하고 텍스트를 선택/삭제하는 기본 단축키 입니다. 왠만한 프로그램에서는 사용 가능한 단축키들입니다. 단축키 설명 up / down 커서를 위 / 아래 줄 이동 left / right 커서를 문자 단위로 왼쪽 / 오른쪽 이동 option + up / down cmd + left / right 커서를 현재 줄의 처음 / 끝 위치로 이동 option + left / right 커서를 단어 단위로 왼쪽 / 오른쪽 이동 cmd + up / down 커서를 페이지 시작 / 끝 위치로 이동 shift + up / down 현재 커서에서 위 / 아래 줄 단위로 선택(반복 가능) shift + left / right 현재 커서에서 왼쪽 / 오른쪽 문자 선택(반복 가능) option + shift + left / right 현재 커서에서 왼쪽 / 오른쪽 단어 선택(반복 가능) cmd + shift + up / down 현재 커서에서 페이지 처음 / 끝 위치까지 선택 delete 문자 또는 선택된 문자열 삭제 option + delete 단어 단위로 삭제 cmd + delete 현재 커서에서 줄의 시작 위치까지 삭제 Browser단축키제가 브라우저에서 주로 사용하는 단축키들입니다. (Chrome과 Safari에서 테스트 하였습니다.) Chrome 단축키 Safari 단축키 단축키 설명 cmd + t 새 탭을 열고, 그 탭으로 이동 cmd + shift + t 마지막으로 닫은 탭을 다시 열고, 그 탭으로 이동 cmd + l 주소 입력란으로 포커스 이동 및 텍스트 전체 선택 cmd + [ or ] cmd + left or right 웹 페이지 Backward / Forward 이동 cmd + shift + [ or ] cmd + shift + left or right Left or Right 탭으로 이동 cmd + link click 새 탭에서 링크 열기 검색검색을 하는 2가지 방법이 있습니다. 브라우저 주소란에 검색어를 입력해서 브라우저에서 설정한 검색엔진으로 검색을 하는 방법과 검색 사이트에 접속해서 검색어 입력란에 검색어를 입력 후 검색을 하는 방법입니다. 브라우저 주소란을 이용할 경우 단축키(cmd + l)로 포커스를 주고 바로 검색어를 입력해서 검색을 할 수 있는 장점이 있습니다. 포커스를 줄 때 텍스트가 전체 선택이기 때문에 바로 다른 검색어를 입력 후 검색을 할 수 있습니다. 그리고 검색어를 입력할 때 브라우저가 검색엔진 제안, 책갈피 및 방문 기록 등을 보여주기 때문에 검색을 하면서 접속할 사이트를 찾아서 바로 접속할 수 있습니다. 하지만, 정밀하게 검색을 하기 위해서는 검색 사이트에 접속해서 검색을 해야 합니다. 예를 들어 사이트 등록 기간 설정 등이 있습니다. VimText 편집 작업이 많을 경우 Vim을 사용하는 것이 좋습니다. 이유는 처음에도 설명했듯이 빠르고 정확하게 원하는 작업을 수행하기 위해서입니다. 단축키Vim 단축키를 참고하였습니다. 단축키 설명 Exiting :w 저장 :wq :x 저장 후 종료 :q 종료 :q! 변경 내역 저장 없이 종료 Navigating h(left), j(up), k(down), l(right) 커서 이동 &lt;C-B&gt; / &lt;C-F&gt; Page Up/Down b / w 이전/다음 단어로 이동 ge / e 이전/다음 단어끝으로 이동 0(zero) 현재 줄의 시작 위치로 이동 ^ 현재 줄의 처음 문자 위치로 이동 $ 현재 줄의 마지막 위치로 이동 fc/Fc 현재 커스에서 앞/뒤로 문자 c를 찾아서 문자 c로 이동 tc/Tc 현재 커스에서 앞/뒤로 문자 c를 찾아서 문자 c 이전으로 이동 ; / , f or t 다음 / 이전 검색 반복 gg / [[ 첫번째 줄로 이동 G / ]] 마지막 줄로 이동 :n nG n 줄로 이동 [( / [{ / [&lt; 이전 (, {, &lt; 로 이동 ]) 다음 ) 로 이동 { / } 이전 / 다음 공백으로 이동 zz 커서가 화면 중앙엥 위치할 수 있도록 화면 이동 H(top), M(middle), L(bottom) 현재 화면에서 커서 위치 이동 Search n / N 다음/이전 일치하는 패턴 검색 * / # 다음/이전 커서 아래에 있는 단어 검색 Editing ESC / &lt;C-[&gt; Insert/Visual Mode 종료 a 현재 커서 뒤에 입력 i 현재 커서 앞에 입력 o / O 다음/이전 줄에 입력 s / S 문자/줄을 제거 후 입력 C 현재 커서에서 줄의 마지막 까지 제거 후 입력 r 현재 커서 문자 변경 u / &lt;C-R&gt; Undo / Redo Clipboard x 문자 삭제 dd 현재 줄 제거 (Cut) yy 현재 줄 복사 (Copy) p / P 앞/뒤에 붙여넣기 ]p / [p 현재 indent level에 맞게 앞/뒤에 붙여넣기 Visual Mode v Visual Mode 진입 V Visual Line Mode 진입 &lt;C-v&gt; Visual Block Mode 진입 In visual mode d / x 선택 영역 삭제 s 선택 영역 변경 y 선택 영역 복사 ~ / u / U Swap case / Lowercase / Uppercase 연산자Normal 모드에서 사용하며, 텍스트에 다양한 동작을 수행할 수 있습니다. Operators list d 삭제 y 복사 c 변경(삭제 후 Insert 모드) v Visual mode Text objects p 절 w 단어 s 문장 [, (, {, &lt; [], (), {} 블록 ‘ / “ / ` 문자열 인용구 b / B ( / { 블록 사용법: d(Operator) [[i]nside or [a]ppend] w(Text object) 예제 dd 현재 라인 삭제 dw 현재 단어의 다음 단어 시작 위치까지 삭제 db 현재 단어의 시작 위치까지 삭제 2dd 2 줄 삭제 dib ( 블록 안의 내용 삭제 daB { 블록을 포함해서 삭제 vi’ ‘ 사이 내용을 visual mode로 선택 Vim-SurroundVSCode에서 vim을 사용할 경우 여러가지 plugin들을 사용할 수 있습니다. 저는 그 중에 vim-surround를 가장 많이 사용하고 있습니다. 사용법은 연산자와 비슷합니다. Surround Command 설명 d s &lt;문자&gt; Surround 문자 삭제 c s &lt;문자&gt; &lt;원하는 문자&gt; Surround 문자를 원하는 문자로 변경 S &lt;문자&gt; Surround 문자 추가 (in visual mode) 예제 cs”‘ “test” -&gt; ‘test’ ds” “test” -&gt; test cs”t123&gt; “test” -&gt; &lt;123&gt;test&lt;/123&gt; ysaw) test -&gt; (test) BetterTouchToolBetterTouchTool은 Mac에서 다양한 입력 장치를 사용자 정의 할 수있는 기능이 가득한 훌륭한 응용 프로그램입니다.(windows는 AutoHotKey가 있습니다.) 단순히 단축키 Trigger 기능 뿐만 아니라, Window 이동 및 크기 조정, OS 기능 등으로 조작이 가능합니다. 단축키저는 주로 Global Keyboard에서 Open Application 기능을 사용합니다. 이 기능은 Dock에서 프로그램을 클릭하는 것처럼 프로그램이 꺼져 있을 경우 실행을 시키고, 실행 중일 경우 해당 프로그램으로 포커스를 이동합니다. 그리고 저는 추가 동작으로 마우스를 프로그램 중앙에 오도록해서 마우스 커서를 찾는 일이 많이 줄어 들게 되었습니다. cmd는 단축키로 많이 사용 되기 때문에 중복을 피하기 위해 프로그램 실행 시에는 option 버튼을 주로 사용합니다. 사용법제일 많이 사용하게 되는 경우는 VSCode로 개발 중 웹 검색이 필요할 때 단축키로 브라우저에 포커스를 주고 cmd + l로 주소창에 포커스를 주고 검색을 하는 것입니다. 그리고 검색 결과를 보고 다시 VSCode로 올 때에도 단축키를 이용해서 실행을 시키기 때문에 cmd + tab 등으로 프로그램을 찾는 시간을 줄여줍니다. 단축키를 얼마나 사용했는 지도 볼 수 있습니다. 마치며모든 단축키를 한번에 외우기를 어려울 것입니다. 하지만, 하나의 단축키에 집중해서 사용하다 보면은 머리보다 손이 먼저 움직이는 날이 올 것입니다. 위에서 소개한 Vim 단축키도 모든 단축키를 소개한 것이 아닙니다. 주로 제가 사용 하거나 사용하고 싶은 기능들로 작성해 보았습니다. 또 다른 VIM 기능 또는 업무 효율성 관련 좋은 프로그램이 있으면 소개해 주시면 감사하겠습니다.","categories":[{"name":"Mac","slug":"Mac","permalink":"https://gongzza.github.io/categories/Mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://gongzza.github.io/tags/mac/"},{"name":"shortcut","slug":"shortcut","permalink":"https://gongzza.github.io/tags/shortcut/"},{"name":"bettertouchtool","slug":"bettertouchtool","permalink":"https://gongzza.github.io/tags/bettertouchtool/"},{"name":"vi","slug":"vi","permalink":"https://gongzza.github.io/tags/vi/"}]},{"title":"MySQL 5.7 FullText Search 이용하기 with ngram","slug":"database/mysql-fulltext-search","date":"2019-05-26T11:17:54.000Z","updated":"2021-02-21T09:19:03.605Z","comments":true,"path":"database/mysql-fulltext-search/","link":"","permalink":"https://gongzza.github.io/database/mysql-fulltext-search/","excerpt":"","text":"IntroductionMySQL 5.7에서 제공하는 FullText Search를 사용해 보면서 삽질했던 내용을 작성해보았습니다. ngram parser와 stopwords 이용해서 full-text index를 만들고 boolean mode로 full-text search까지 해볼 것입니다. Docker로 테스트 DB 만들기간단하게 Docker를 이용해서 테스트를 위한 mysql5.7 DB를 생성합니다. 1234567891011121314151617181920# Run mysql:5.7 container$ docker run --name test-db -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.7135f4de514bf42336a62755db7cd72de5c187dcd0cff7c777fa902661e76b295# connect mysql$ docker exec -it test-db mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.25 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.mysql&gt; Create Table &amp; FullText index full-text index는 InnoDB 또는 MyISAM 테이블에서만 생성이 가능합니다. 그리고 컬럼 타입이 CHAR, VARCHAR 또는 TEXT 이어야 합니다. 1234567891011121314151617181920CREATE DATABASE test;USE test;Database changedCREATE TABLE articles ( id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY, title VARCHAR(200), body TEXT, FULLTEXT idx_ft_title_and_body (title,body) ) ENGINE=InnoDB;INSERT INTO articles (title,body) VALUES (&#x27;MySQL Tutorial&#x27;,&#x27;DBMS stands for DataBase ...&#x27;), (&#x27;How To Use MySQL Well&#x27;,&#x27;After you went through a ...&#x27;), (&#x27;Optimizing MySQL&#x27;,&#x27;In this tutorial we will show ...&#x27;), (&#x27;1001 MySQL Tricks&#x27;,&#x27;1. Never run mysqld as root. 2. ...&#x27;), (&#x27;MySQL vs. YourSQL&#x27;,&#x27;In the following database comparison ...&#x27;), (&#x27;MySQL Security&#x27;,&#x27;When configured properly, MySQL ...&#x27;);Query OK, 6 rows affected (0.01 sec) 이미 생성된 Table에 Index를 추가 하고 싶은 경우 CREATE INDEX 또는 ALTER TABLE를 이용해서 추가할 수 있습니다. 12345678-- DROP INDEX-- DROP INDEX idx_ft_title_and_body on articles;-- CREATE INDEXCREATE FULLTEXT INDEX idx_ft_title_and_body on articles(title, body);-- ALTER TABLEALTER TABLE articles ADD FULLTEXT INDEX idx_ft_title_and_body(title, body); FullText 검색FullText 검색은 다음과 같은 구문을 이용합니다. 123456789MATCH (col1,col2,...) AGAINST (expr [search_modifier])search_modifier: &#123; IN NATURAL LANGUAGE MODE | IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION | IN BOOLEAN MODE | WITH QUERY EXPANSION &#125; 12345678SELECT * FROM articles WHERE MATCH (title,body) AGAINST (&#x27;database&#x27; IN NATURAL LANGUAGE MODE);+----+-------------------+------------------------------------------+| id | title | body |+----+-------------------+------------------------------------------+| 1 | MySQL Tutorial | DBMS stands for DataBase ... || 5 | MySQL vs. YourSQL | In the following database comparison ... |+----+-------------------+------------------------------------------+2 rows in set (0.00 sec) 참고로 FullText 검색은 대/소문자를 구분하지 않습니다. 검색이 잘 되는 것을 확인할 수 있습니다. 12SELECT * FROM articles WHERE MATCH (title, body) AGAINST (&#x27;data&#x27; IN NATURAL LANGUAGE MODE);Empty set (0.01 sec) 하지만 ‘data’로 검색했을 경우에는 검색 결과가 없는데요. 이유는 full-text index 생성 시 공백을 구분자로 단어 단위로 저장을 하기 때문에 검색하는 단어가 정확히 일치해야지만 결과를 받을 수 있습니다. 저장된 단어 확인하기OPTIMIZE TABLE로 저장된 단어들을 INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE에서 확인해 볼 수 있습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051SET GLOBAL innodb_ft_aux_table = &#x27;test/articles&#x27;;SET GLOBAL innodb_optimize_fulltext_only=ON;OPTIMIZE TABLE articles;+---------------+----------+----------+----------+| Table | Op | Msg_type | Msg_text |+---------------+----------+----------+----------+| test.articles | optimize | status | OK |+---------------+----------+----------+----------+1 row in set (0.00 sec)SELECT WORD, DOC_COUNT, DOC_ID, POSITION FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE;+------------+-----------+--------+----------+| WORD | DOC_COUNT | DOC_ID | POSITION |+------------+-----------+--------+----------+| 1001 | 1 | 5 | 0 || after | 1 | 3 | 22 || comparison | 1 | 6 | 44 || configured | 1 | 7 | 20 || database | 2 | 2 | 31 || database | 2 | 6 | 35 || dbms | 1 | 2 | 15 || following | 1 | 6 | 25 || mysql | 6 | 2 | 0 || mysql | 6 | 3 | 11 || mysql | 6 | 4 | 11 || mysql | 6 | 5 | 5 || mysql | 6 | 6 | 0 || mysql | 6 | 7 | 0 || mysql | 6 | 7 | 41 || mysqld | 1 | 5 | 31 || never | 1 | 5 | 21 || optimizing | 1 | 4 | 0 || properly | 1 | 7 | 31 || root | 1 | 5 | 41 || run | 1 | 5 | 27 || security | 1 | 7 | 6 || show | 1 | 4 | 42 || stands | 1 | 2 | 20 || through | 1 | 3 | 37 || tricks | 1 | 5 | 11 || tutorial | 2 | 2 | 6 || tutorial | 2 | 4 | 25 || use | 1 | 3 | 7 || well | 1 | 3 | 17 || went | 1 | 3 | 32 || you | 1 | 3 | 28 || yoursql | 1 | 6 | 10 |+------------+-----------+--------+----------+33 rows in set (0.00 sec) 보시는 것처럼 단어 단위로 저장되어 있어서 ‘data’로 검색 시 결과가 없는 것입니다. ngram Parserngram Parser를 이용하면은 위 문제를 해결할 수 있습니다. ngram Parser는 built-in 되어있는 MySQL full-text parser로 CJK(Chinese, Japanese, Korean)을 지원하며, 공백으로 단어 사이를 구분하고 ngram_token_size(기본값: 2)단위로 단어를 연속적으로 쪼개서 저장합니다. ‘abcd’를 예로 들면 다음과 같이 저장을 합니다. 1234n&#x3D;1: &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;n&#x3D;2: &#39;ab&#39;, &#39;bc&#39;, &#39;cd&#39;n&#x3D;3: &#39;abc&#39;, &#39;bcd&#39;n&#x3D;4: &#39;abcd&#39; Rebuild Indexngram Parser를 이용하여 index를 다시 생성합니다. 12345-- DROP INDEXDROP INDEX idx_ft_title_and_body ON articles;-- CREATE INDEXALTER TABLE articles ADD FULLTEXT INDEX idx_ft_title_and_body(title, body) WITH PARSER NGRAM; 다시 data로 검색을 하면은… 12SELECT * FROM articles WHERE MATCH (title, body) AGAINST (&#x27;data&#x27; IN NATURAL LANGUAGE MODE);Empty set (0.01 sec) 검색 결과가 없습니다. 저장된 단어들을 확인해 봅니다. 1234567891011121314151617SELECT WORD, DOC_COUNT, DOC_ID, POSITION FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE;+------+-----------+--------+----------+| WORD | DOC_COUNT | DOC_ID | POSITION |+------+-----------+--------+----------+| 00 | 1 | 5 | 1 || 01 | 1 | 5 | 2 || 10 | 1 | 5 | 0 || bm | 1 | 2 | 16 || ck | 1 | 5 | 14 || co | 2 | 6 | 44 || co | 2 | 7 | 20 || cu | 1 | 7 | 8 || db | 1 | 2 | 15 || ds | 1 | 2 | 24 || ec | 1 | 7 | 7 |...129 rows in set (0.00 sec) 보시면은 1001은 위 설명대로 2개씩 잘 들어가 있는 것이 확인되지만, database의 맨 앞글자인 da가 저장되어 있지 않습니다. Stopwords맨 처음 저장된 단어들을 봤을 때 눈치 채신분이 계실지 모르겠지만, ‘a’, for’ 또는 ‘to’ 같은 단어들은 저장이 되어 있지 않았습니다. 이유는 기본적으로 제공하는 Stopwords 때문입니다. INFORMATION_SCHEMA.INNODB_FT_DEFAULT_STOPWORD를 확인해봅니다. 123456789101112131415161718192021222324252627282930313233343536373839404142SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DEFAULT_STOPWORD;+-------+| value |+-------+| a || about || an || are || as || at || be || by || com || de || en || for || from || how || i || in || is || it || la || of || on || or || that || the || this || to || was || what || when || where || who || will || with || und || the || www |+-------+36 rows in set (0.00 sec) InnoDB와 MyISAM이 기본적으로 제공하는 Stopwords가 다릅니다. 여기에 해당하는 단어들은 검색 범위에 포함되지 않는 것입니다. ‘da’는 여기에 없는데 왜 저장되지 않았는지에 대해서 제 생각에는 단어를 쪼개면서 ‘a’가 Stopwords에 필터링 되서 저장이 되지 않았나 생각됩니다. 보시면은 ‘a’ 또는 ‘i’로 시작하거나 끝나는 쪼개진 단어들은 모두 저장되지 않았습니다. 12SELECT WORD, DOC_COUNT, DOC_ID, POSITION FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE WHERE WORD LIKE &#x27;%a%&#x27; OR WORD LIKE &#x27;%i%&#x27;;Empty set (0.00 sec) 위 문제를 해결하기 위해서 Stopwords 비활성화 하거나 stopwords 테이블을 만들어서 사용하는 방법이 있습니다. Stopwords를 비활성화 하는 방법innodb_ft_enable_stopword를 확인해 보시기 바랍니다. CREATE TABLE stopwordsstopwords 테이블 스키마는 매우 간단합니다. value varchar만 있으면 됩니다. 123456789-- Create a new stopword tableCREATE TABLE stopwords(value VARCHAR(30)) ENGINE = INNODB;-- Set the innodb_ft_server_stopword_table option to the new stopword tableSET GLOBAL innodb_ft_server_stopword_table = &#x27;test/stopwords&#x27;;-- Create the full-text index (which rebuilds the table if no FTS_DOC_ID column is defined)DROP INDEX idx_ft_title_and_body ON articles;ALTER TABLE articles ADD FULLTEXT INDEX idx_ft_title_and_body(title, body) WITH PARSER NGRAM; 꼭 full-text index 재생성이 필요합니다. 그리고 만약 DBMS를 재시작 할 경우 innodb_ft_server_stopword_table정보가 리셋되기 때문에 꼭 mysql.cnf에 설정해 두시기 바랍니다. 12[mysqld]innodb_ft_server_stopword_table=&#x27;test/stopwords&#x27; db_name에 ‘-‘가 있을 경우 @002d로 변경 하시면 됩니다. 이제 ‘data’로 검색하면은 ‘database’ 검색 결과와 같은 결과를 보실 수 있습니다. 12345678SELECT * FROM articles WHERE MATCH (title, body) AGAINST (&#x27;data&#x27; IN NATURAL LANGUAGE MODE);+----+-------------------+------------------------------------------+| id | title | body |+----+-------------------+------------------------------------------+| 1 | MySQL Tutorial | DBMS stands for DataBase ... || 5 | MySQL vs. YourSQL | In the following database comparison ... |+----+-------------------+------------------------------------------+2 rows in set (0.01 sec) Boolean full-text search그러나 다시 ‘database’로 검색하면은 아까보다 더 많은 검색 결과가 나오는데요. 12345678910SELECT * FROM articles WHERE MATCH (title,body) AGAINST (&#x27;database&#x27; IN NATURAL LANGUAGE MODE);+----+-----------------------+------------------------------------------+| id | title | body |+----+-----------------------+------------------------------------------+| 1 | MySQL Tutorial | DBMS stands for DataBase ... || 5 | MySQL vs. YourSQL | In the following database comparison ... || 4 | 1001 MySQL Tricks | 1. Never run mysqld as root. 2. ... || 2 | How To Use MySQL Well | After you went through a ... || 6 | MySQL Security | When configured properly, MySQL ... |+----+-----------------------+------------------------------------------+ 보시면은 아까의 검색 결과에 포함되어 있지 않은 ID 4, 2 그리고 6이 검색 되었습니다. 검색 결과가 많은 이유는 검색어도 쪼개서 검색을 하기 때문입니다. 즉, ‘data’를 검색하게 되면은 ‘da’, ‘at’, ‘ta’ 단어로 검색을 합니다. 그래서 ID 1과 5가 ‘da’로 검색이 된 것이고 4는 ‘as’로, 2와 6은 ‘se’에서 검색이 된 것입니다. 이부분은 검색 모드를 IN BOOLEAN MODE로 변경해서 처리가 어느정도 가능합니다. 12345678SELECT * FROM articles WHERE MATCH (title, body) AGAINST (&#x27;database&#x27; IN BOOLEAN MODE);+----+-------------------+------------------------------------------+| id | title | body |+----+-------------------+------------------------------------------+| 1 | MySQL Tutorial | DBMS stands for DataBase ... || 5 | MySQL vs. YourSQL | In the following database comparison ... |+----+-------------------+------------------------------------------+2 rows in set (0.00 sec) 원하는 검색 결과만 나온 것을 확인할 수 있습니다. Boolean 검색은 다음과 같은 로직을 가지고 검색을 합니다. ‘+’ stands for AND ‘-‘ stands for NOT [no operator] implies OR 즉 위 검색은 ‘database’ 단어를 포함하는지 보기 때문에 기대하던 검색 결과를 가질 수 있었습니다. References https://dev.mysql.com/doc/refman/5.7/en/fulltext-search.html https://dev.mysql.com/doc/refman/5.7/en/fulltext-stopwords.html https://dev.mysql.com/doc/refman/5.7/en/fulltext-search-ngram.html https://dev.mysql.com/doc/refman/5.7/en/fulltext-boolean.html https://dev.mysql.com/doc/refman/5.7/en/fulltext-fine-tuning.html","categories":[{"name":"Database","slug":"Database","permalink":"https://gongzza.github.io/categories/Database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://gongzza.github.io/tags/mysql/"},{"name":"FullText","slug":"FullText","permalink":"https://gongzza.github.io/tags/FullText/"}]},{"title":"TypeScript definition for process.env","slug":"typescript/typescript-definition-for-process-env","date":"2019-03-03T09:21:38.000Z","updated":"2021-02-21T13:41:51.328Z","comments":true,"path":"typescript/typescript-definition-for-process-env/","link":"","permalink":"https://gongzza.github.io/typescript/typescript-definition-for-process-env/","excerpt":"","text":"IntroductionNode.js 환경변수로 process.env를 사용하실 것입니다. TypeScript에서는 process.env도 타입을 선언해서 자동완성 기능을 사용할 수 있습니다. @types/nodeprocess를 그냥 쓰게 되면 찾을 수 없는 이름이라고 에러메시지가 나옵니다. process도 타입 선언이 필요한데요. 위 설명에도 나와 있듯이 @types/node를 설치해서 Node.js의 타입들을 사용할 수 있습니다. 123$ npm i -D typescript @types/node+ @types/node@11.10.4+ typescript@3.3.3333 process.env는 다음과 같이 선언되어 있습니다. @types/node/globals.d.ts12345678declare namespace NodeJS &#123; interface Process &#123; env: ProcessEnv &#125; interface ProcessEnv &#123; [key: string]: string | undefined; &#125;&#125; 보시는 것처럼 process.env에 대해서 어떤 key라도 사용이 가능하기 때문에 자동완성 기능이 없는 것입니다. Extends NodeJS.Process interface다음과 같이 definition file에 타입을 선언하면, process.env의 자동완성 기능을 사용할 수 있습니다. node.d.ts12345678910declare namespace NodeJS &#123; interface Process &#123; /** running on server */ isServer: boolean &#125; interface ProcessEnv &#123; /** node environment */ NODE_ENV: string &#125;&#125; AutoComplete dotenvdotenv를 이용하면 .env 파일을 읽어서 자동으로 process.env에 설정할 수 있습니다. 먼저 dotenv를 설치합니다. 12$ npm i dotenv+ dotenv@6.2.0 그리고 .env 파일에 환경변수를 작성합니다. .env1NODE_ENV=development index.ts에서 간단하게 환경변수 NODE_ENV를 출력하는 프로그램을 작성합니다. index.ts12require(&#x27;dotenv&#x27;).config()console.log(process.env.NODE_ENV) tsc로 컴파일 후 실행해 보면 NODE_ENV가 잘 출력되는 것을 확인할 수 있습니다. 12345# typescript compile &amp; run$ npx tsc index.ts &amp;&amp; node index.js# outputdevelopment Conclusion매번 타입 선언하는 것이 번거로울 수는 있지만, 타입을 선언해서 오타를 줄이고 리팩토링을 빠르게 하기 위해서 TypeScript를 사용하는 만큼 타입을 철저히 선언해서 사용하는 것이 좋을 것 같습니다.","categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://gongzza.github.io/categories/Typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"dotenv","slug":"dotenv","permalink":"https://gongzza.github.io/tags/dotenv/"}]},{"title":"TypeScript로 Nuxt.js 실행하기 - 2","slug":"nuxtjs/nuxt-ts-2","date":"2019-02-18T08:58:33.000Z","updated":"2021-02-21T13:41:51.327Z","comments":true,"path":"nuxtjs/nuxt-ts-2/","link":"","permalink":"https://gongzza.github.io/nuxtjs/nuxt-ts-2/","excerpt":"","text":"이전 포스트 Introduction이번에는 Decorator를 이용해서 컴포넌트를 클래스 스타일로 만들고 테스트 환경을 구축해 볼 것입니다. ESLint먼저 그전에 먼저 eslint가 typescript를 이해할 수 있도록 파서를 변경할 것입니다. 12$ npm i -D @typescript-eslint/parser+ @typescript-eslint/parser@1.5.0 그리고 .eslintrc.js 파일의 parser를 변경해 줍니다. .eslint.js123456module.exports = &#123; parserOptions: &#123;- parser: &#x27;babel-eslint&#x27;+ parser: &#x27;@typescript-eslint/parser&#x27; &#125;&#125; Component Class컴포넌트를 클래스로 만들면 다음과 같은 장점들이 있습니다. computed, methods 그리고 data를 따로 나눠서 선언하지 않아도 됩니다. 함수 선언 시 매번 ,로 구분 지어주지 않아도 됩니다. 자동완성 기능을 손쉽게 사용할 수 있습니다. Install먼저 nuxt-property-decorator를 설치합니다. 12$ npm i -D nuxt-property-decorator+ nuxt-property-decorator@2.1.3 nuxt-property-decorator는 Vue class component, Vue Property Decorator 그리고 Vuex Class를 기반으로 Nuxt의 hooks를 추가한 모듈입니다. Decoratorpages/index.vue 파일에 Decorator를 적용해 봅니다. pages/index.vue1234567891011121314151617181920&lt;template&gt; ... &lt;h1 class=&quot;title&quot;&gt; &#123;&#123; name &#125;&#125; &lt;/h1&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; Component, Vue &#125; from &#x27;nuxt-property-decorator&#x27;import Logo from &#x27;~/components/Logo.vue&#x27;@Component(&#123; components: &#123; Logo &#125;&#125;)export default class IndexPage extends Vue &#123; name: string = &#x27;hello-nuxt-ts-decorator&#x27;&#125;&lt;/script&gt; npm run dev로 서버를 실행해 보면 hello-nuxt-ts-decorator 문구를 확인할 수 있습니다. Testcreate-nuxt-app에서 생성한 Jest 기반 테스트 환경도 TypeScript를 적용해 볼 것입니다. Install먼저 ts-jest와 @types/jest를 설치합니다. 123$ npm i -D ts-jest @types/jest+ @types/jest@24.0.6+ ts-jest@23.10.5 TsConfigtypes에 @types/jest를 추가합니다. tsconfig.json123456789&#123; &quot;compileOptions&quot;: &#123; ... &quot;types&quot;: [ &quot;@types/jest&quot;, ... ] &#125;&#125; JestConfigJest에서 .ts 파일 확장자를 테스트 하도록 jest.config.js을 수정합니다. jest.config.js12345678module.exports = &#123; moduleFileExtensions: [&#x27;ts&#x27;, ...], testRegex: &#x27;(test|spec)\\\\.(jsx?|tsx?)$&#x27;, transform: &#123; &#x27;^.+\\\\tsx?$&#x27;: &#x27;ts-jest&#x27;, ... &#125;&#125; Move.js로 되어있는 파일 확장자를 .ts로 변경합니다. 1$ mv test/Logo.spec.js test/Logo.spec.ts Typestest/Logo.spec.ts 파일을 열어보면 describe, test와 expect는 @types/jest가 적용되서 정상적으로 타입이 선언되어 있는 것을 확인할 수 있습니다. 하지만, import Logo from &#39;@/components/Logo.vue&#39;에서 다음과 같이 에러가 보입니다. 이유는 .vue 파일 확장자에 대해서 TypeScript가 해석을 못하기 때문입니다. 그래서 .vue 파일 확장자에 대해서 타입을 선언해주어야 합니다. types/vue-shims.d.ts1234declare module &#x27;*.vue&#x27; &#123; import Vue from &#x27;vue&#x27; export default Vue&#125; 타입을 선언하고 나서 에러가 사라지는 것을 확인하실 수 있을 것입니다. Run Test이제 테스트를 실행해 봅니다. 1234567891011121314$ npm t&gt; hello-nuxt-ts@1.0.0 test hello-nuxt-ts&gt; jestPASS test/Logo.spec.ts Logo ✓ is a Vue instance (20ms)Test Suites: 1 passed, 1 totalTests: 1 passed, 1 totalSnapshots: 0 totalTime: 3.673sRan all test suites. test/Logo.spec.ts 파일의 테스트가 성공하는 것을 확인할 수 있습니다.","categories":[{"name":"Nuxt.js","slug":"Nuxt-js","permalink":"https://gongzza.github.io/categories/Nuxt-js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://gongzza.github.io/tags/nuxt-js/"},{"name":"nuxt-typescript","slug":"nuxt-typescript","permalink":"https://gongzza.github.io/tags/nuxt-typescript/"}]},{"title":"TypeScript로 Nuxt.js 시작하기 - 1","slug":"nuxtjs/nuxt-ts-1","date":"2019-02-16T15:23:29.000Z","updated":"2021-02-21T13:41:51.326Z","comments":true,"path":"nuxtjs/nuxt-ts-1/","link":"","permalink":"https://gongzza.github.io/nuxtjs/nuxt-ts-1/","excerpt":"","text":"IntroductionUpdate: 2019-03-21 Nuxt.js가 v2.5.0로 릴리즈 되면서 nuxt-ts를 설치하지 않고 @nuxt/typescript로 TypeScript를 공식적으로 지원하기 시작하였습니다. 릴리즈 소식은 여기를 확인해 주세요. nuxt-typescript 예제는 여기를 확인해 주세요. Create Projectnpx create-nuxt-app 명령어로 프로젝트를 생성합니다. 12345678910111213141516171819202122232425262728293031$ npx create-nuxt-app hello-nuxt-ts&gt; Generating Nuxt.js project in hello-nuxt-ts? Project name: hello-nuxt-ts? Project description: My marvelous Nuxt.js project? Use a custom server framework: none? Choose features to install: Linter / Formatter? Use a custom UI framework: none? Use a custom test framework: jest? Choose rendering mode: Single Page App? Author name: Gz? Choose a package manager: npm&gt; hello-nuxt-ts@1.0.0 lint hello-nuxt-ts&gt; eslint --ext .js,.vue --ignore-path .gitignore . &quot;--fix&quot; To get started: cd hello-nuxt-ts npm run dev To build &amp; start for production: cd hello-nuxt-ts npm run build npm start To test: cd hello-nuxt-ts npm run test cd hello-nuxt-ts &amp;&amp; npm run dev 명령어로 서버를 실행하고 http://localhost:3000 주소로 접속하면 다음 화면을 볼 수 있습니다. Migrating to TypeScript@nuxt/typescript를 설치하고 tsconfig.json 파일을 생성합니다. 123456# Install dependency$ npm i -D @nuxt/typescript+ @nuxt/typescript@2.5.1# Generate tsconfig.json$ echo &#123;&#125; &gt; tsconfig.json tsconfig.json 파일 내용은 nuxt 실행 시 자동으로 채워집니다. 그 다음 nuxt.config.js 파일을 .ts 파일로 변경합니다. 1$ mv nuxt.config.js nuxt.config.ts 그리고 nuxt.config.ts 에 타입을 선언합니다. nuxt.config.ts1234567891011121314151617181920212223242526272829303132// ts에서 .json 파일을 불러오기 위해서는 compilerOptions.resolveJsonModule를 활성화 시키면 됩니다.- import pkg from &#x27;package&#x27;+ const pkg = &#123; name: &#x27;hello-nuxt-ts&#x27;, description: &#x27;My marvelous Nuxt.js project&#x27; &#125;+ import NuxtConfiguration from &#x27;@nuxt/config&#x27;export default &#123; mode: &#x27;spa&#x27;, ... /* ** Build configuration */ build: &#123; /* ** You can extend webpack config here */ extend(config, ctx) &#123; // Run ESLint on save if (ctx.isDev &amp;&amp; ctx.isClient) &#123; // config.module이 null일 수 있어서 타입 체크가 필요합니다.+ if (!config.module) config.module = &#123; rules: [] &#125; config.module.rules.push(&#123; enforce: &#x27;pre&#x27;, test: /\\.(js|vue)$/, loader: &#x27;eslint-loader&#x27;, exclude: /(node_modules)/ &#125;) &#125; &#125; &#125;&#125; as NuxtConfiguration npx nuxt 명령어를 실행해서 정상 작동을 확인해 봅니다. 12345678910111213141516171819202122232425262728$ npx nuxtℹ tsconfig.json found, enabling TypeScript runtime support ╭─────────────────────────────────────────╮ │ │ │ Nuxt.js v2.5.1 │ │ Running in development mode (spa) │ │ Memory usage: 97.1 MB (RSS: 157 MB) │ │ │ │ Listening on: http://localhost:3000 │ │ │ ╰─────────────────────────────────────────╯ℹ Preparing project for developmentℹ Initial build may take a while✔ Builder initialized✔ Nuxt files generatedℹ Starting type checking service...ℹ Using 1 worker with 2048MB memory limit✔ Client Compiled successfully in 4.00sℹ Type checking in progress...ℹ Waiting for file changesℹ No type errors foundℹ Version: typescript 3.3.4000ℹ Time: 4943ms 서버를 실행하고 tsconfig.json 파일을 확인해 보면 설정 옵션이 추가된 것을 확인할 수 있습니다. 그리고 서버가 실행중인 상태에서 pages/index.vue의 script를 &lt;script lang=&quot;ts&quot;&gt;로 바꿔봅니다. 123456789↻ Updated pages/index.vue✔ Client Compiled successfully in 688.54msℹ Type checking in progress...ℹ No type errors foundℹ Version: typescript 3.3.4000ℹ Time: 1598ms 정상적으로 동작하는 것을 확인할 수 있습니다. Next다음은 nuxt-property-decorator를 사용해서 Component를 Class Base로 작성하는 방법을 살펴볼 것입니다. 그리고 jest로 테스트를 추가해볼 것입니다. 다음 포스트 References https://github.com/nuxt/nuxt.js/releases https://codesandbox.io/s/github/nuxt/nuxt.js/tree/dev/examples/typescript","categories":[{"name":"Nuxt.js","slug":"Nuxt-js","permalink":"https://gongzza.github.io/categories/Nuxt-js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://gongzza.github.io/tags/nuxt-js/"},{"name":"nuxt-typescript","slug":"nuxt-typescript","permalink":"https://gongzza.github.io/tags/nuxt-typescript/"}]},{"title":"Open Current Folder in Finder from iTerm2 of Mac OS X","slug":"mac/open-current-folder-in-finder-from-iterm2","date":"2018-12-21T22:57:14.000Z","updated":"2021-02-21T13:45:10.901Z","comments":true,"path":"mac/open-current-folder-in-finder-from-iterm2/","link":"","permalink":"https://gongzza.github.io/mac/open-current-folder-in-finder-from-iterm2/","excerpt":"","text":"IntroductioniTerm2을 사용하다 보면 현재 폴더를 Finder에서 봐야할 때가 있는데요. 이럴때 현재 프롬프트에 커서가 있다면 open . 명령으로 간단하게 현재 폴더를 Finder로 열 수 있습니다. 하지만, iTerm2에서는 단축키를 지원해 주지 않고, 현재 프로세스가 실행중인 상태라면은 세션을 새로 열고 오픈 명령어를 실행해야 합니다. 이런 번거로운 작업을 Profile을 이용해서 단축키로 한번에 여는 방법을 소개합니다. ProfileiTerm2에서는 세션을 새로 열 때 프로필 개념을 사용하는데, 단축키를 지정해서 원하는 프로필로 세션을 생성할 수 있습니다. 먼저, cmd + , 단축키로 Preferences를 엽니다. 그리고 Profile 탭으로 이동합니다. 보시면은 현재 Default 프로필만 존재하는데요. Finder를 오픈 할 프로필을 하나 추가합니다. 그리고 다음과 같이 입력합니다. Basics -&gt; Shortcut key 지정 (저는 여기서 ctrl+cmd+f를 지정하였습니다.) Command 에서 Command 란에 open .를 입력 Working Directory -&gt; Reuse previous session’s directory 선택 Open Finder이제 단축키를 누르면 Finder가 오픈이 되는데요. iTerm2의 경고도 같이 나오게 됩니다. Session을 시작했는데, 바로 종료 된다는 알림입니다. 체크박스에 체크를 하고 확인을 누르면, 다시 나와서 귀찮게 하지 않을 것입니다. Conclusion이제 프로세스가 실행중 이여도 단축키를 누르면 현재 폴더를 Finder에서 열 수 있게 되었습니다. 새로 세션을 열고 open . 명령어를 직접 칠 수도 있지만, 새로 세션을 열 때 딜레이가 많아서 단축키를 사용하는 것이 훨신 빠르게 작업을 할 수 있는 방법입니다.","categories":[{"name":"Mac","slug":"Mac","permalink":"https://gongzza.github.io/categories/Mac/"}],"tags":[{"name":"iterm2","slug":"iterm2","permalink":"https://gongzza.github.io/tags/iterm2/"},{"name":"finder","slug":"finder","permalink":"https://gongzza.github.io/tags/finder/"}]},{"title":"GraphQL Server - TypeGraphQL","slug":"graphql/graphql-server-type","date":"2018-10-25T15:47:07.000Z","updated":"2021-02-21T09:19:03.612Z","comments":true,"path":"graphql/graphql-server-type/","link":"","permalink":"https://gongzza.github.io/graphql/graphql-server-type/","excerpt":"","text":"이전 포스트 GraphQL Server - TypeGraphQL이번에는 TypeGraphQL을 적용해서 리팩토링을 해보겠습니다. TypeGraphQL은 Decorator를 이용해서 Schema를 구성할 수 있게 해줍니다. Install12$ npm i -d type-graphql+ type-graphql@0.15.0 type-graphql&#64;0.15.0부터 @types/graphql 버전이 맞춰져서 apollo-server와 같이 사용할 수 있게 되었습니다. TSConfigTypeScript 소스코드에서 Decorator를 사용할 수 있도록 설정을 활성화 합니다. tsconfig.json1234567&#123; &quot;compilerOptions&quot;: &#123; ... &quot;experimentalDecorators&quot;: true, &quot;emitDecoratorMetadata&quot;: true &#125;&#125; ObjectTypeObjectType을 사용해서 Book type을 선언합니다. src/book.type.ts123456789101112import &#123; ObjectType, Field &#125; from &#x27;type-graphql&#x27;@ObjectType()export class Book &#123; @Field() title: string @Field() author: string&#125; 위 코드는 아래와 같이 해석됩니다. 1234type Book &#123; title: String! author: String!&#125; ResolverResolver를 이용해서 Query와 Mutation을 작성합니다. src/book.resolver.ts123456789101112131415161718192021222324252627282930313233343536import &#123; Resolver, Query, Mutation, Arg &#125; from &#x27;type-graphql&#x27;import &#123; Book &#125; from &#x27;./book.type&#x27;@Resolver()export class BookResolver &#123; private items: Book[] constructor() &#123; this.items = [ &#123; title: &#x27;Harry Potter and the Chamber of Secrets&#x27;, author: &#x27;J.K. Rowling&#x27; &#125;, &#123; title: &#x27;Jurassic Park&#x27;, author: &#x27;Michael Crichton&#x27; &#125; ] &#125; @Query(() =&gt; [Book]) public books() &#123; return this.items &#125; @Mutation(() =&gt; Book) public createBook(@Arg(&#x27;title&#x27;) title: string, @Arg(&#x27;author&#x27;) author: string) &#123; const book: Book = &#123; title, author &#125; this.items.push(book) return book &#125;&#125; 여기서 함수명은 별도로 지정하지 않을 경우 그대로 사용이 됩니다. 즉 위 코드는 아래와 같이 해석됩니다. 1234567891011121314151617181920212223const typeDefs = gql` type Query &#123; books: [Book] &#125; type Mutation &#123; createBook(title: String!, author: String!): Book &#125;`const resolvers = &#123; Query: &#123; books: () =&gt; books &#125;, Mutation: &#123; createBook: (root, &#123;title, author&#125;) =&gt; &#123; const book = &#123; title, author &#125; books.push(book) return book &#125; &#125;&#125; 자세한 사항은 Resolver를 보시기 바랍니다. Build Schema이제 app.ts에서 TypeGraphQL을 사용하도록 수정합니다. src/app.ts123456789101112131415161718import &#x27;reflect-metadata&#x27;import express from &#x27;express&#x27;import &#123; ApolloServer &#125; from &#x27;apollo-server-express&#x27;import &#123; buildSchemaSync &#125; from &#x27;type-graphql&#x27;import &#123; BookResolver &#125; from &#x27;./book.resolver&#x27;const schema = buildSchemaSync(&#123; resolvers: [ BookResolver ], validate: false&#125;)export const app = express()export const server = new ApolloServer(&#123; schema &#125;)server.applyMiddleware(&#123; app &#125;) 보시면 코드가 매우 간결해진 것을 확인할 수 있습니다. schema.validate는 class-validator를 이용해서 ObjectType을 검사할 것인지의 여부를 설정합니다. 지금은 아직 DB를 붙이지 않아서 설정하지 않았습니다. Test테스트도 조금 수정이 필요합니다. 이전에는 nullable 이었던 변수들을 required로 선언하는 것 뿐입니다. test/book.spec.ts12345678910111213141516171819202122232425262728293031323334353637it(&#x27;mutation - createBook&#x27;, async () =&gt; &#123; ... const createdBook = await req.post(server.graphqlPath) .send(&#123; query: `- mutation CreateBook($title: String $author: String) &#123;+ mutation CreateBook($title: String! $author: String!) &#123; createBook(title: $title author: $author) &#123; title author &#125; &#125; `, variables: book &#125;) ...&#125;)it(&#x27;mutation - createBook - unknown argument&#x27;, async () =&gt; &#123;- expect(errors).to.have.lengthOf(1)+ expect(errors).to.have.lengthOf(3) // title: String!, author: String!&#125;)it(&#x27;mutation - createBook - cannot query field&#x27;, async () =&gt; &#123; const errors = await req.post(server.graphqlPath) .send(&#123; query: `- mutation CreateBook($title: String $author: String) &#123;+ mutation CreateBook($title: String! $author: String!) &#123; createBook(title: $title author: $author) &#123; title author content &#125; &#125; ` &#125;) .expect(400) .then(res =&gt; res.body.errors) ...&#125;) 테스트를 해보면 모두 통과하는 것을 확인할 수 있습니다. 123456789101112131415$ npm t&gt; graphql-server-example@1.0.0 test&gt; mocha -r ts-node/register -r tsconfig-paths/register test/**/*.spec.tsBook ✓ query - books (71ms) ✓ query - books - cannot query field ✓ mutation - createBook ✓ mutation - createBook - unknown argument ✓ mutation - createBook - cannot query field5 passing (126ms) ConclusionTypeGraphQL를 이용해서 Decorator 방식으로 개발을 해보았는데요. 소스코드가 깔끔해지고 명확해진 것을 느끼게 되었습니다. Examples에서 더 많은 예제를 확인하실 수 있습니다.","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://gongzza.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://gongzza.github.io/tags/graphql/"},{"name":"apollo","slug":"apollo","permalink":"https://gongzza.github.io/tags/apollo/"},{"name":"type-graphql","slug":"type-graphql","permalink":"https://gongzza.github.io/tags/type-graphql/"}]},{"title":"GraphQL Server - Test","slug":"graphql/graphql-server-test","date":"2018-09-19T16:18:38.000Z","updated":"2021-02-21T09:19:03.611Z","comments":true,"path":"graphql/graphql-server-test/","link":"","permalink":"https://gongzza.github.io/graphql/graphql-server-test/","excerpt":"","text":"GraphQL Server - Test이전 포스트에서 작성한 소스코드를 mocha와 supertest로 테스트 코드를 작성 해 볼 것입니다. Install123456789$ npm i -D mocha @types/mocha chai @types/chai supertest @types/supertest ts-node tsconfig-paths+ @types/supertest@2.0.6+ @types/chai@4.1.4+ chai@4.1.2+ ts-node@7.0.1+ tsconfig-paths@3.6.0+ @types/mocha@5.2.5+ mocha@5.2.0+ supertest@3.3.0 ts-node는 mocha가 typescript를 해석할 수 있도록 하고, tsconfig-paths는 tsconfig.json의 paths를 사용할 수 있게 합니다. TypeScript Configtsconfig.json을 상속 받는 tsconfig.compiler.json을 만듭니다. tsconfig.compiler.json1234567&#123; &quot;extends&quot;: &quot;./tsconfig.json&quot;, &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;test&quot; ]&#125; tsconfig.json 파일에 “exclude” 로 test 디렉토리를 넣으면 test 디렉토리 안에 있는 typescript 파일들이 tsconfig.json 파일의 설정대로 동작하지 않습니다. 그리고 tsconfig.compiler.json 파일로 설정을 나눔으로 써 컴파일 시 test 디렉토리를 배제할 수 있습니다. Scriptsmocha를 실행하는 test 스크립트와 build 시 typescript 컴파일러가 tsconfig.compiler.json을 바라보도록 수정합니다. 1234567&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha -r ts-node/register -r tsconfig-paths/register test/**/*.spec.ts&quot;, &quot;build&quot;: &quot;tsc -p tsconfig.compiler.json&quot;, ... &#125;&#125; TestBook type에 대한 Query와 Mutation 테스트를 작성합니다. test/book.spec.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import request from &#x27;supertest&#x27;import &#123; expect &#125; from &#x27;chai&#x27;import &#123; app, server &#125; from &#x27;~/app&#x27;describe(&#x27;Book&#x27;, () =&gt; &#123; const req = request(app) it(&#x27;query - books&#x27;, async () =&gt; &#123; const res = await req.post(server.graphqlPath) .send(&#123; query: &#x27;&#123; books &#123; title author &#125; &#125;&#x27; &#125;) .expect(200) const books = [ &#123; title: &#x27;Harry Potter and the Chamber of Secrets&#x27;, author: &#x27;J.K. Rowling&#x27; &#125;, &#123; title: &#x27;Jurassic Park&#x27;, author: &#x27;Michael Crichton&#x27; &#125; ] expect(res.body.data.books).to.eql(books) &#125;) it(&#x27;query - books - cannot query field&#x27;, async () =&gt; &#123; const errors = await req.post(server.graphqlPath) .send(&#123; query: &#x27;&#123; books &#123; title author content &#125; &#125;&#x27; &#125;) .expect(400) .then(res =&gt; res.body.errors) expect(errors).to.have.lengthOf(1) expect(errors[0].extensions.code).to.equal(&#x27;GRAPHQL_VALIDATION_FAILED&#x27;) expect(errors[0].message).to.equal(&#x27;Cannot query field &quot;content&quot; on type &quot;Book&quot;.&#x27;) &#125;) it(&#x27;mutation - createBook&#x27;, async () =&gt; &#123; const book = &#123; title: &#x27;Title&#x27;, author: &#x27;Author&#x27; &#125; const createdBook = await req.post(server.graphqlPath) .send(&#123; query: ` mutation CreateBook($title: String $author: String) &#123; createBook(title: $title author: $author) &#123; title author &#125; &#125; `, variables: book &#125;) .expect(200) .then(res =&gt; res.body.data.createBook) expect(createdBook).to.eql(book) const books = await req.post(server.graphqlPath) .send(&#123; query: &#x27;&#123; books &#123; title author &#125; &#125;&#x27; &#125;) .expect(200) .then(res =&gt; res.body.data.books) expect(books).to.deep.include(book) &#125;) it(&#x27;mutation - createBook - unknown argument&#x27;, async () =&gt; &#123; const errors = await req.post(server.graphqlPath) .send(&#123; query: ` mutation CreateBook($_id: String) &#123; createBook(_id: $_id) &#123; title author &#125; &#125; `, &#125;) .expect(400) .then(res =&gt; res.body.errors) expect(errors).to.have.lengthOf(1) expect(errors[0].extensions.code).to.equal(&#x27;GRAPHQL_VALIDATION_FAILED&#x27;) expect(errors[0].message).to.equal(&#x27;Unknown argument &quot;_id&quot; on field &quot;createBook&quot; of type &quot;Mutation&quot;.&#x27;) &#125;) it(&#x27;mutation - createBook - cannot query field&#x27;, async () =&gt; &#123; const errors = await req.post(server.graphqlPath) .send(&#123; query: ` mutation CreateBook($title: String $author: String) &#123; createBook(title: $title author: $author) &#123; title author content &#125; &#125; `, &#125;) .expect(400) .then(res =&gt; res.body.errors) expect(errors).to.have.lengthOf(1) expect(errors[0].extensions.code).to.equal(&#x27;GRAPHQL_VALIDATION_FAILED&#x27;) expect(errors[0].message).to.equal(&#x27;Cannot query field &quot;content&quot; on type &quot;Book&quot;.&#x27;) &#125;)&#125;) 테스트를 수행하면 정상적으로 동작하는 것을 확인할 수 있습니다. 12345678910111213141516$ npm t&gt; graphql-server-example@1.0.0 test&gt; mocha -r ts-node/register -r tsconfig-paths/register test/**/*.spec.tsBook ✓ query - books (91ms) ✓ query - books - cannot query field ✓ mutation - createBook ✓ mutation - createBook - unknown argument ✓ mutation - createBook - cannot query field5 passing (150ms) References How to Test GraphQL Server Using Mocha and Chai","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://gongzza.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://gongzza.github.io/tags/graphql/"},{"name":"express","slug":"express","permalink":"https://gongzza.github.io/tags/express/"},{"name":"apollo","slug":"apollo","permalink":"https://gongzza.github.io/tags/apollo/"},{"name":"test","slug":"test","permalink":"https://gongzza.github.io/tags/test/"},{"name":"mocha","slug":"mocha","permalink":"https://gongzza.github.io/tags/mocha/"},{"name":"chai","slug":"chai","permalink":"https://gongzza.github.io/tags/chai/"},{"name":"supertest","slug":"supertest","permalink":"https://gongzza.github.io/tags/supertest/"}]},{"title":"GraphQL Server - Example","slug":"graphql/graphql-server-example","date":"2018-09-18T13:39:05.000Z","updated":"2021-02-21T09:19:03.610Z","comments":true,"path":"graphql/graphql-server-example/","link":"","permalink":"https://gongzza.github.io/graphql/graphql-server-example/","excerpt":"","text":"GraphQL Server - ExampleApolloServer Getting started를 참고하여 TypeScript로 예제를 작성하였습니다. Initialize12$ mkdir graphql-server-example &amp;&amp; cd $_$ npm init -y Install1234567891011# dependencies$ npm i -S express graphql apollo-server-express+ express@4.16.3+ apollo-server-express@2.0.7+ graphql@14.0.2# devDependencies$ npm i -D typescript @types/express @types/graphql+ @types/express@4.16.0+ @types/graphql@14.0.0+ typescript@3.0.3 graphql은 직접 사용하진 않지만, Apollo Server에서 peer dependency로 필요합니다. TypeScript Configtsconfig.json을 작성합니다. tsconfig.json1234567891011121314&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;esnext&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;esModuleInterop&quot;: true, &quot;outDir&quot;: &quot;dist&quot;, &quot;sourceMap&quot;: true, &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: &#123; &quot;~/*&quot;: [&quot;./src/*&quot;] &#125; &#125;&#125; Scriptspackage.json에 컴파일 및 서버 실행 스크립트를 추가합니다. package.json12345678&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;npm run build &amp;&amp; npm start&quot;, &quot;start&quot;: &quot;node dist/server&quot;, &quot;prebuild&quot;: &quot;rm -rf dist&quot;, &quot;build&quot;: &quot;tsc&quot; &#125;&#125; 개발 서버는 npm run dev 명령어로 실행시킬 수 있습니다. GraphQL Server for Expressapollo-server-express를 사용해서 GraphQL을 주고받을 수 있는 express 서버를 작성합니다. src/app.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import express from &#x27;express&#x27;import &#123; ApolloServer, gql &#125; from &#x27;apollo-server-express&#x27;// This is a (sample) collection of books we&#x27;ll be able to query// the GraphQL server for. A more complete example might fetch// from an existing data source like a REST API or database.const books = [ &#123; title: &#x27;Harry Potter and the Chamber of Secrets&#x27;, author: &#x27;J.K. Rowling&#x27; &#125;, &#123; title: &#x27;Jurassic Park&#x27;, author: &#x27;Michael Crichton&#x27; &#125;]// Type definitions define the &quot;shape&quot; of your data and specify// which ways the data can be fetched from the GraphQL server.const typeDefs = gql` # Comments in GraphQL are defined with the hash (#) symbol. # This &quot;Book&quot; type can be used in other type declarations. type Book &#123; title: String author: String &#125; # The &quot;Query&quot; type is the root of all GraphQL queries. # (A &quot;Mutation&quot; type will be covered later on.) type Query &#123; books: [Book] &#125;`// Resolvers define the technique for fetching the types in the// schema. We&#x27;ll retrieve books from the &quot;books&quot; array above.const resolvers = &#123; Query: &#123; books: () =&gt; books &#125;&#125;export const app = express()// In the most basic sense, the ApolloServer can be started// by passing type definitions (typeDefs) and the resolvers// responsible for fetching the data for those types.export const server = new ApolloServer(&#123; typeDefs, resolvers &#125;)server.applyMiddleware(&#123; app &#125;) 서버를 실행시키는 server.ts를 추가합니다. src/server.ts1234567import &#123; app, server &#125; from &#x27;./app&#x27;const PORT = 3000app.listen(PORT, () =&gt; &#123; console.log(`🚀 Server ready at http://localhost:$&#123;PORT&#125;$&#123;server.graphqlPath&#125;`)&#125;) 서버 실행 부분을 따로 작성한 이유는 supertest로 express 테스트를 작성하기 위해서 입니다. Playground서버를 실행합니다. 123456789101112131415$ npm run dev&gt; graphql-server-example@1.0.0 dev&gt; npm run build &amp;&amp; npm start&gt; graphql-server-example@1.0.0 prebuild&gt; rm -rf dist&gt; graphql-server-example@1.0.0 build&gt; tsc&gt; graphql-server-example@1.0.0 start&gt; node dist/server🚀 Server ready at http://localhost:3000/graphql http://localhost:3000/graphql 이 주소에 접근 하면 playground 화면을 볼 수 있습니다. Query왼쪽은 요청 화면이고 오른쪽은 응답 화면입니다. 요청 화면에 쿼리를 입력하고 요청을 보내면 응답을 받을 수 있습니다. MutationQuery는 데이터를 가져오기에 초점을 맞춰있다면, Mutation은 데이터를 수정하거나 쓰는 역할을 담당합니다. Query와 마찬가지로 Mutation이 객체 타입을 반환하면 필드를 요청할 수 있습니다. Book을 등록하는 Mutation을 작성해봅니다. src/app.ts12345678910111213141516const typeDefs = gql` ... type Mutation &#123; createBook(title: String, author: String): Book &#125;`const resolvers = &#123; ... Mutation: &#123; createBook: (root, args) =&gt; &#123; books.push(args) return args &#125; &#125;&#125; 서버를 재시작 후 Mutation을 요청해보면 응답으로 저장된 Book을 받을 수 있습니다. Next다음 포스트에서는 지금까지 작성한 소스 코드를 mocha와 supertest로 테스트 코드를 작성 해 볼 것입니다. References ApolloServer Getting started GraphQL(KR) - 배우기","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://gongzza.github.io/categories/GraphQL/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://gongzza.github.io/tags/graphql/"},{"name":"express","slug":"express","permalink":"https://gongzza.github.io/tags/express/"},{"name":"apollo","slug":"apollo","permalink":"https://gongzza.github.io/tags/apollo/"}]},{"title":"PostgreSQL의 Trigger를 이용한 자동 chunk 생성","slug":"database/postgres-trigger","date":"2018-06-28T11:11:54.000Z","updated":"2021-02-21T09:19:03.606Z","comments":true,"path":"database/postgres-trigger/","link":"","permalink":"https://gongzza.github.io/database/postgres-trigger/","excerpt":"","text":"IntroductionPostgreSQL의 Trigger를 이용해서 chunk id를 자동으로 생성하거나 기존의 chunk의 날짜를 갱신하는 로직을 작성해 볼 것입니다. 간단히 테스트 해보기 위해서 Docker를 사용하시면 편합니다. Docker로 개발용 DB 만들기를 참고해 주시기 바랍니다. Table테이블을 생성합니다. schema.sql12345678910111213141516171819-- Tabledrop table if exists item;drop table if exists item_chunk;create table item_chunk ( id serial, updated_at timestamp not null, primary key(id));create table item ( id serial, chunk_id int not null, name varchar(100), created_at timestamp default current_timestamp(2) not null, updated_at timestamp, foreign key(chunk_id) references item_chunk(id)); Indexitem 테이블에서 chunk_id와 id를 primary key로 잡은 이유는 chunk_id로 가져올 때 index를 타게 하기 위해서 입니다. 123456postgres=# explain select * from item where chunk_id = 1 ;&quot;Bitmap Heap Scan on item (cost=4.16..9.50 rows=2 width=242)&quot;&quot; Recheck Cond: (chunk_id = 1)&quot;&quot; -&gt; Bitmap Index Scan on item_pkey (cost=0.00..4.16 rows=2 width=0)&quot;&quot; Index Cond: (chunk_id = 1)&quot; 처음에 데이터를 넣고 explain을 돌려 보면은 sequential scan으로 동작을 합니다. 이유는 select가 전체 row수의 5-10% 이상을 가져올 경우 sequential scan이 더 빠르다고 합니다. 참고 그래도 분포된 chunk_id를 가지게 되면 optimizer에 의해서 다시 index scan을 하게 됩니다. Function &amp;&amp; TriggerTrigger 시 동작 할 함수를 작성합니다. 함수는 item의 id를 이용해서 chunk id를 5개 단위로 증가시킵니다.그리고 item이 update 되면 item이 포함되어 있는 chunk의 update를 갱신합니다. schema.sql1234567891011121314151617181920212223242526272829303132333435363738-- Table...-- Triggerdrop trigger if exists item_chunk_upsert;drop function if exists item_chunk_upsert();create function item_chunk_upsert()returns trigger as $$declare chunk_id integer;begin if (tg_op = &#x27;INSERT&#x27;) then -- id는 1부터 시작하므로 -1을 해서 0부터 시작하도록 한다. -- chunk_id가 1부터 시작하도록 +1을 한다. new.chunk_id = div(new.id - 1, 5) + 1; -- 중복 등록일 경우 날짜를 갱신한다. insert into item_chunk(id) values(new.chunk_id) on conflict (id) do update set updated_at = new.created_at; else new.updated_at = current_timestamp(2); update item_chunk set updated_at = new.updated_at where id = new.chunk_id; end if; return new;end;$$ language plpgsql;-- 입력과 수정 전에 트리거를 발생시킨다.create trigger &quot;item_chunk_upsert&quot; before insert or update on &quot;item&quot; for each row execute procedure item_chunk_upsert(); Test테스트에 필요한 모듈을 설치합니다. 1$ npm i -S pg &amp;&amp; npm i -D mocha chai 테스트 시나리오는 item을 등록 또는 수정 시 자동으로 item_chunk에 영향이 있는지를 확인합니다. test.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const &#123; Client, types &#125; = require(&#x27;pg&#x27;)const &#123; readFileSync &#125; = require(&#x27;fs&#x27;)const &#123; expect &#125; = require(&#x27;chai&#x27;)const connectionString = process.env.DB_URL || &#x27;postgresql://postgres@localhost/postgres&#x27;const schema = readFileSync(&#x27;./schema.sql&#x27;).toString()// timestamp object를 string으로 변환한다.const TIMESTAMPTZ_OID = 1184const TIMESTAMP_OID = 1114const parseFn = (val) =&gt; &#123; return val === null ? null : val.toString()&#125;types.setTypeParser(TIMESTAMPTZ_OID, parseFn)types.setTypeParser(TIMESTAMP_OID, parseFn)// 비동기 딜레이 처리function sleep(ms) &#123; return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(true), ms))&#125;describe(&#x27;postgres trigger test&#x27;, () =&gt; &#123; let client beforeEach(async () =&gt; &#123; client = new Client(&#123;connectionString&#125;) await client.connect() await client.query(schema) // DB 초기화 &#125;) afterEach(async () =&gt; &#123; await client.end() &#125;) it(&#x27;item chunk upsert #1&#x27;, async () =&gt; &#123; // insert item let result = await client.query(`insert into item (name) values (&#x27;name1&#x27;) returning *`) expect(result.rowCount).to.equal(1) const item = result.rows[0] // select item chunk result = await client.query(&#x27;select * from item_chunk&#x27;) expect(result.rowCount).to.equal(1) const chunk = result.rows[0] // check expect(item.chunk_id).to.equal(chunk.id) expect(item.created_at).to.equal(chunk.updated_at) await sleep(10) // update item result = await client.query(`update item set name = $2 where id = $1 returning *`, [item.id, &#x27;Updated name&#x27;]) expect(result.rowCount).to.equal(1) const updatedItem = result.rows[0] expect(updatedItem.name).to.equal(&#x27;Updated name&#x27;) // select item chunk result = await client.query(&#x27;select * from item_chunk&#x27;) expect(result.rowCount).to.equal(1) // check const updatedChunk = result.rows[0] expect(updatedItem.chunk_id).to.equal(updatedChunk.id) expect(updatedItem.created_at).not.to.equal(updatedChunk.updated_at) expect(updatedItem.updated_at).to.equal(updatedChunk.updated_at) &#125;) it(&#x27;item chunk upsert #2&#x27;, async () =&gt; &#123; // insert item let result = await client.query(`insert into item (name) values (&#x27;name1&#x27;), (&#x27;name2&#x27;), (&#x27;name3&#x27;), (&#x27;name4&#x27;), (&#x27;name5&#x27;), (&#x27;name6&#x27;) returning *`) expect(result.rowCount).to.equal(6) const item1 = result.rows[0] const item6 = result.rows[5] // select item chunk result = await client.query(&#x27;select * from item_chunk&#x27;) expect(result.rowCount).to.equal(2) const chunk1 = result.rows[0] const chunk2 = result.rows[1] // check expect(item1.chunk_id).to.equal(chunk1.id) expect(item1.created_at).to.equal(chunk1.updated_at) expect(item6.chunk_id).to.equal(chunk2.id) expect(item6.created_at).to.equal(chunk2.updated_at) await sleep(10) // update item result = await client.query(`update item set name = $2 where id = $1 returning *`, [item1.id, &#x27;Updated name&#x27;]) expect(result.rowCount).to.equal(1) const updatedItem = result.rows[0] expect(updatedItem.name).to.equal(&#x27;Updated name&#x27;) // select item chunk result = await client.query(&#x27;select * from item_chunk where id = $1&#x27;, [updatedItem.chunk_id]) expect(result.rowCount).to.equal(1) // check const updatedChunk = result.rows[0] expect(updatedItem.chunk_id).to.equal(updatedChunk.id) expect(updatedItem.created_at).not.to.equal(updatedChunk.updated_at) expect(updatedItem.updated_at).to.equal(updatedChunk.updated_at) &#125;)&#125;) types를 이용해서 timestamp object를 string으로 리턴하도록 하였습니다. 그리고 등록 후 바로 수정을 하게 되면 시간 차이가 나지 않아서 테스트가 실패하는 경우가 발생합니다. 그래서 10ms 대기 후 수정하도록 하였습니다. 잘 동작 하는지 확인해 봅니다. 1234567$ npx mochapostgres trigger test ✓ item chunk upsert #1 ✓ item chunk upsert #22 passing (91ms) 정상적으로 잘 동작하는 것을 확인 할 수 있습니다. 결론Trigger를 이용해서 item의 name에만 신경쓰고 작업을 할 수 있게 되었습니다. 참고 PostgreSQL - SERIAL - Generate IDs PostgreSQL - Trigger PRocedures PostgreSQL - CREATE INSERT PostgreSQL - CREATE FUNCTION node-pg-types","categories":[{"name":"Database","slug":"Database","permalink":"https://gongzza.github.io/categories/Database/"}],"tags":[{"name":"postgresql","slug":"postgresql","permalink":"https://gongzza.github.io/tags/postgresql/"},{"name":"trigger","slug":"trigger","permalink":"https://gongzza.github.io/tags/trigger/"}]},{"title":"Docker로 개발용 DB 만들기","slug":"docker/db-sample","date":"2018-05-17T15:05:47.000Z","updated":"2021-02-21T09:19:03.608Z","comments":true,"path":"docker/db-sample/","link":"","permalink":"https://gongzza.github.io/docker/db-sample/","excerpt":"","text":"IntroductionDocker로 개발용 DB 생성 및 간단한 node 기반 접속 샘플을 작성해 보았습니다. Oracle MySQL &amp; MariaDB PostgreSQL MongoDB MSSQL OracleImage: https://hub.docker.com/r/wnameless/oracle-xe-11g/ 1$ docker run --name oracle-db -p 1521:1521 -d wnameless/oracle-xe-11g Environment Variables ORACLE_ALLOW_REMOTE(Y/N): 원격 접속 여부 ORACLE_DISABLE_ASYNCH_IO: For performance concern, you may want to disable the disk asynch IO Check Versionoracle.js12345678910111213141516171819202122232425262728// https://github.com/oracle/node-oracledb/blob/master/examples/version.jsvar oracledb = require(&#x27;oracledb&#x27;);console.log(&quot;Run at: &quot; + new Date());console.log(&quot;Node.js version: &quot; + process.version + &quot; (&quot; + process.platform, process.arch + &quot;)&quot;);// console.log(&quot;Node-oracledb version:&quot;, oracledb.version); // numeric version format is useful for comparisons// console.log(&quot;Node-oracledb version suffix:&quot;, oracledb.versionSuffix); // e.g. &quot;-beta.1&quot;, or empty for production releasesconsole.log(&quot;Node-oracledb version:&quot;, oracledb.versionString); // version (including the suffix)//console.log(&quot;Oracle Client library version:&quot;, oracledb.oracleClientVersion); // numeric version formatconsole.log(&quot;Oracle Client library version:&quot;, oracledb.oracleClientVersionString);oracledb.getConnection( &#123; user : &quot;system&quot;, password : &quot;oracle&quot;, connectString : &quot;localhost/XE&quot; &#125;, function(err, connection) &#123; if (err) &#123; console.error(err.message); return; &#125; // console.log(&quot;Oracle Database version:&quot;, connection.oracleServerVersion); // numeric version format console.log(&quot;Oracle Database version:&quot;, connection.oracleServerVersionString); &#125;); 1234567$ npm install oracledb$ node oracle.jsRun at: Wed May 16 2018 21:37:30 GMT+0900 (KST)Node.js version: v8.5.0 (darwin x64)Node-oracledb version: 2.2.0Oracle Client library version: 12.2.0.1.0Oracle Database version: 11.2.0.2.0 MySQL &amp; MariaDBImage: https://hub.docker.com/_/mysql/ Image: https://hub.docker.com/_/mariadb/ 12345# mysql$ docker run --name mysql-db -p 3306:3306 -e MYSQL_ROOT_PASSWORD=secure -d mysql# mariadb$ docker run --name maria-db -p 3306:3306 -e MYSQL_ROOT_PASSWORD=secure -d mariadb Environment Variables MYSQL_ROOT_PASSWORD(required): 루트 패스워드 MYSQL_DATABASE: database 생성 시 사용된다. MYSQL_USER, MYSQL_PASSWORD: 사용자 생성 및 MYSQL_DATABASE 로 생성 된 database의 권한을 받는다. MYSQL_ONETIME_PASSWORD: MySQL 5.6+ only. 1회성 비밀번호를 생성한다. SHA-256 Pluggable Authenticationhttps://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html#upgrade-caching-sha2-password MySQL 8.0+부터 사용자 암호화 방식이 caching_sha2_password가 되면서 이전 방식으로 로그인이 불가능하다. 다음과 같이 사용자의 비밀번호 암호화 방식을 이전 방식으로 수정하거나 Authentication switch request방식을 이용해서 접속할 수 있다. 12345678910111213141516$ docker exec -it mysql-db mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 8Server version: 8.0.11 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.mysql&gt; alter user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;secure&#x27;;Query OK, 0 rows affected (0.04 sec) Check Versionmysql.js12345678910111213141516const mysql = require(&#x27;mysql2&#x27;)const connection = mysql.createConnection(&#123; host: &#x27;localhost&#x27;, user: &#x27;root&#x27;, password: &#x27;secure&#x27;&#125;)connection.query( &#x27;SELECT VERSION() as version&#x27;, (err, results) =&gt; &#123; if (err) throw err console.log(results) connection.end() &#125;) 12345678$ npm install mysql2$ node mysql.js# mysql 8+[ TextRow &#123; version: &#x27;8.0.11&#x27; &#125; ]# mariadb[ TextRow &#123; version: &#x27;10.2.14-MariaDB-10.2.14+maria~jessie&#x27; &#125; ] PostgreSQLImage: https://hub.docker.com/_/postgres/ 1$ docker run --name postgres-db -p 5432:5432 -d postgres Environment Variables POSTGRES_PASSWORD: localhost로 접근 할 경우 비밀번호가 필요하지 않음. POSTGRES_USER(default: postgres): superuser와 같은 이름의 database를 생성한다. PGDATA(default: /var/lib/postgresql/data): database file POSTGRES_DB: 기본 database 생성, POSTGRES_USER 가 사용한다. POSTGRES_INITDB_ARGS: postgres initdb 아규먼트로 사용된다. Check Versionpostgres.js123456789101112const &#123; Client &#125; = require(&#x27;pg&#x27;)const client = new Client(&#123; user: &#x27;postgres&#x27;, database: &#x27;postgres&#x27;, port: 5432,&#125;)client.connect()client.query(&#x27;SELECT version()&#x27;, (err, &#123;rows&#125;) =&gt; &#123; console.log(err, rows[0].version) client.end()&#125;) 1234$ npm install pg$ node postgres.jsnull &#x27;PostgreSQL 10.3 (Debian 10.3-1.pgdg90+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516, 64-bit&#x27; MongoDBImage: https://hub.docker.com/_/mongo/ 1$ docker run --name mongo-db -p 27017:27017 -d mongo Environment Variables MONGO_INITDB_ROOT_USERNAME, MONGO_INITDB_ROOT_PASSWORD: admin 인증 database와 root 권한을 갖는 유저를 생성한다. mongodb는 mongod --auth 명령어로 시작된다. MONGO_INITDB_DATABASE(default: test): /docker-entrypoint-initdb.d 디렉토리안에 있는 .sh 또는 .js가 실행 될 때 바라보게 될 database를 설정한다. Initializing a fresh instance컨테이너가 처음 실행 될 때 /docker-entrypoint-initdb.d 디렉토리에서 .sh 또는 .js 파일을 찾아서 실행한다. 이때 MONGO_INITDB_DATABASE가 가리키는 database를 사용하게 된다. /mongo/seed/todos.js12db.todos.save(&#123;text: &#x27;study mongodb&#x27;, done: false&#125;)db.todos.save(&#123;text: &#x27;study docker&#x27;, done: true&#125;) 1234567$ docker --name mongo-init-db -v /mongo/seed:/docker-entrypoint-initdb.d -e MONGO_INITDB_DATABASE=todo -d mongo$ docker exec -it mongo-init-db mongo todo&gt; db.todos.find(&#123;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;5afd973adae4958f3c43f2d6&quot;), &quot;text&quot; : &quot;study mongodb&quot;, &quot;done&quot; : false &#125;&#123; &quot;_id&quot; : ObjectId(&quot;5afd973adae4958f3c43f2d7&quot;), &quot;text&quot; : &quot;study docker&quot;, &quot;done&quot; :true &#125; Configurationcustom configuration file을 사용 할 경우 mongod.conf 파일을 복사 하고 --config 옵션을 주면 된다. 1$ docker run --name some-mongo -v /my/custom:/etc/mongo -d mongo --config /etc/mongo/mongod.conf Check Versionmongo.js123456789101112131415161718// http://mongodb.github.io/node-mongodb-native/3.0/api/Admin.html#serverInfo// https://github.com/mongodb/node-mongodb-native/blob/master/lib/admin.jsconst MongoClient = require(&#x27;mongodb&#x27;).MongoClient;const test = require(&#x27;assert&#x27;);// Connection urlconst url = &#x27;mongodb://localhost:27017&#x27;;// Database Nameconst dbName = &#x27;test&#x27;;// Connect using MongoClientMongoClient.connect(url, &#123;useNewUrlParser: true&#125;, function(err, client) &#123; client.db(dbName).admin().serverInfo().then(info =&gt; &#123; console.log(info.version) client.close() &#125;)&#125;); 123$ npm install mongodb$ node mongo.js3.6.4 MSSQLImage: https://hub.docker.com/r/microsoft/mssql-server-linux/ 1$ docker run --name mssql-db -e &#x27;ACCEPT_EULA=Y&#x27; -e &#x27;SA_PASSWORD=mssql@secure.pw&#x27; -p 1433:1433 -d microsoft/mssql-server-linux Environment Variables ACCEPT_EULA(required): Y로 설정해 주어야 한다. SA_PASSWORD: 대/소문자, 숫자, 특수문자 중 3가지가 포함된 8글자 이상의 비밀번호를 지정해야 한다. MSSQL_PID: (default: Developer): Edition name Check Versionmssql.js1234567891011121314151617181920// https://github.com/tediousjs/node-mssql#promisesconst sql = require(&#x27;mssql&#x27;)sql.connect(&#123; user: &#x27;sa&#x27;, password: &#x27;mssql@secure.pw&#x27;, server: &#x27;localhost&#x27;&#125;).then(() =&gt; &#123; return sql.query`SELECT @@VERSION as version`&#125;).then(result =&gt; &#123; console.log(result.recordset[0].version) sql.close()&#125;).catch(err =&gt; &#123; console.error(err) sql.close()&#125;) 123456$ npm install mssql$ node mssql.jsMicrosoft SQL Server 2017 (RTM-CU6) (KB4101464) - 14.0.3025.34 (X64) Apr 9 2018 18:00:41 Copyright (C) 2017 Microsoft Corporation Developer Edition (64-bit) on Linux (Ubuntu 16.04.4 LTS)","categories":[{"name":"Docker","slug":"Docker","permalink":"https://gongzza.github.io/categories/Docker/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://gongzza.github.io/tags/mysql/"},{"name":"docker","slug":"docker","permalink":"https://gongzza.github.io/tags/docker/"},{"name":"oracle","slug":"oracle","permalink":"https://gongzza.github.io/tags/oracle/"},{"name":"mariadb","slug":"mariadb","permalink":"https://gongzza.github.io/tags/mariadb/"},{"name":"postgres","slug":"postgres","permalink":"https://gongzza.github.io/tags/postgres/"},{"name":"mongodb","slug":"mongodb","permalink":"https://gongzza.github.io/tags/mongodb/"},{"name":"mssql","slug":"mssql","permalink":"https://gongzza.github.io/tags/mssql/"}]},{"title":"명령어로 NGINX 컨트롤하기","slug":"linux/how-to-control-nginx","date":"2018-03-26T15:37:48.000Z","updated":"2021-02-21T09:19:03.652Z","comments":true,"path":"linux/how-to-control-nginx/","link":"","permalink":"https://gongzza.github.io/linux/how-to-control-nginx/","excerpt":"","text":"NGINX CLI를 이용해서 어떻게 컨트롤을 하는지 알아봅니다. Version현재 설치되어 있는 NGINX 버전입니다. 12$ nginx -vnginx version: nginx/1.12.2 Starting시작 명령어는 간단합니다. 1234$ nginx$ ps -ef | grep nginxroot 23157 1 0 11:14 ? 00:00:00 nginx: master process nginxnginx 23158 23157 0 11:14 ? 00:00:00 nginx: worker process 아무런 문구 없이 다음 프롬프트로 떨어진다면, 성공적으로 서버를 실행한 것입니다. 권한이 없거나, 이미 포트가 오픈되어 있다면은 다음과 같은 에러를 볼 수 있습니다. 123456789# permission denied$ nginxnginx: [alert] could not open error log file: open() &quot;/var/log/nginx/error.log&quot; failed (13: Permission denied)# address aready in use$ nginxnginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)nginx: [emerg] bind() to [::]:80 failed (98: Address already in use)nginx: [emerg] still could not bind() Test Configuration설정 파일은 기본적으로 /etc/nginx/nginx.conf 파일을 바라보고 있습니다. -c 옵션으로 설정 파일을 직접 지정할 수 있습니다. -t 옵션으로 설정 파일이 문법적으로 올바른지 확인할 수 있습니다. Example: mynginx.conf1234567http &#123; server &#123; location / &#123; root /data/www; &#125; &#125;&#125; 1234$ nginx -t -c /etc/nginx/mynginx.confnginx: the configuration file /etc/nginx/mynginx.conf syntax is oknginx: [emerg] no &quot;events&quot; section in configurationnginx: configuration file /etc/nginx/mynginx.conf test failed -T 옵션은 -t 옵션과 같지만, 설정 파일 내용을 출력합니다. Stopping-s 옵션으로 종료 signal을 보내서 프로세스를 종료합니다. 12345# 프로세스를 바로 종료한다.$ nginx -s stop# 현재 연결 중인 컨넥션이 모두 완료될 때까지 기다린 후 종료한다.$ nginx -s quit $ systemctl stop nginx 명령어도 KillSignal이 SIGQUIT으로 되어 있습니다. /lib/systemd/system/nginx.service1234[Service]...KillSignal=SIGQUIT... Reloading설정 파일을 수정 후 서버에 반영할 때 다음 명령어를 수행합니다. 1$ nginx -s reload 시작 명령어와 마찬가지로 아무런 문구 없이 다음 프롬프트로 떨어진다면, 정상적으로 반영이 된 것입니다. References https://www.nginx.com/resources/wiki/start/topics/tutorials/commandline/ https://nginx.org/en/docs/beginners_guide.html http://nginx.org/en/docs/switches.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://gongzza.github.io/categories/Linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://gongzza.github.io/tags/nginx/"},{"name":"linux","slug":"linux","permalink":"https://gongzza.github.io/tags/linux/"}]},{"title":"Jest로 TypeScript 학습테스트 환경 만들기","slug":"typescript/learning-typescript-with-jest","date":"2018-03-19T11:03:48.000Z","updated":"2021-02-21T13:41:51.327Z","comments":true,"path":"typescript/learning-typescript-with-jest/","link":"","permalink":"https://gongzza.github.io/typescript/learning-typescript-with-jest/","excerpt":"","text":"소개Jest로 TypeScript를 테스트 하면서 학습해 나가는 환경을 만들어 볼 것입니다. 프로젝트 생성12345678910111213141516171819# make dir and change dir$ mkdir learning-typescript-with-jest &amp;&amp; cd $_# initialize package.json$ npm init -yWrote to learning-typescript-with-jest/package.json:&#123; &quot;name&quot;: &quot;learning-typescript-with-jest&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 설치TypeScript와 Jest를 설치합니다. 1234$ npm i -D typescript jest @types/jest+ typescript@2.7.2+ jest@22.4.2+ @types/jest@22.2.0 Jest는 JavaScript로 작성 되었기 때문에 TypeScript에서 타입 정보를 알 수 없습니다. 그래서 Jest의 타입 정보가 담겨져 있는 @types/jest를 설치해 주어야 합니다. 그리고 Jest에서 TypeScript를 실행하기 위해서 ts-jest를 설치합니다. 12$ npm i -D ts-jest+ ts-jest@22.4.1 설정test script를 작성합니다. package.json12345&#123; &quot;script&quot;: &#123; &quot;test&quot;: &quot;jest&quot; &#125;&#125; jest를 설정합니다. 여기서 ts-jest를 사용합니다. package.json12345678910111213141516&#123; &quot;jest&quot;: &#123; &quot;transform&quot;: &#123; &quot;^.+\\\\.ts$&quot;: &quot;ts-jest&quot; &#125;, &quot;testRegex&quot;: &quot;\\\\.test\\\\.ts$&quot;, &quot;moduleFileExtensions&quot;: [ &quot;ts&quot;, &quot;js&quot; ], &quot;globals&quot;: &#123; &quot;ts-jest&quot;: &#123; &quot;enableTsDiagnostics&quot;: true &#125; &#125; &#125;&#125; testRegex에서 테스트할 파일명을 정규화 표현식으로 찾습니다. ts-jest.enableTsDiagnostics은 컴파일 시 에러가 있을 경우 무시하지 않고 테스트를 실패하게 하는 옵션입니다. 기본값이 false이기 때문에 true로 바꿔주었습니다. 그리고 ts-jest에서 필요로 하는 tsconfig.json을 추가합니다. tsconfig.json1&#123;&#125; 우선 필요한 옵션은 없기 때문에 모든 값을 기본 값으로 설정합니다. 테스트이제 테스트를 작성해 봅니다. TypeScript#Hanbook을 참고해서 Enum을 테스트해 봅니다. test/basic-types.test.ts12345678910111213describe(&#x27;Basic Types&#x27;, () =&gt; &#123; test(&#x27;Enum#number&#x27;, () =&gt; &#123; enum Color &#123;Red, Green, Blue&#125; let c: Color = Color.Green expect(c).toBe(1) &#125;) test(&#x27;Enum#name&#x27;, () =&gt; &#123; enum Color &#123;Red = 1, Green, Blue&#125; let colorName: string = Color[2] expect(colorName).toBe(&#x27;Green&#x27;) &#125;)&#125;) 테스트를 수행해 보면 통과하는 것을 볼 수 있습니다. 12345678910111213$ npm test&gt; learning-typescript-with-jest@1.0.0 test learning-typescript-with-jest&gt; jestPASS test/basic-types.test.ts Basic Types ✓ Enum#number (3ms) ✓ Enum#name (1ms)Test Suites: 1 passed, 1 totalTests: 2 passed, 2 totalSnapshots: 0 totalTime: 3.585s npm test -- --watch 명령어로 파일의 변경을 감지하여 테스트를 수행할 수 있습니다. 검증 테스트Using the Compiler API를 참고해서 TypeScript 검증 테스트를 작성해 볼 것입니다. 검증을 하기 위해서는 소스코드가 파일로 존재해야 합니다. 그래서 임시파일을 만들어 주는 node-tmp를 사용할 것입니다. 123$ npm i -D tmp @types/node+ tmp@0.0.33+ @types/node@9.4.7 @types/node는 node에서 기본으로 제공하고 있는 fs 모듈을 사용하기 위해서 설치합니다. 검증 후 에러 메시지들을 리턴하는 함수를 작성합니다. utils.ts123456789101112131415161718192021222324252627282930313233import * as fs from &#x27;fs&#x27;import * as ts from &#x27;typescript&#x27;import * as tmp from &#x27;tmp&#x27;tmp.setGracefulCleanup()export function compile(code: string, options?: ts.CompilerOptions): string[] &#123; const file = tmp.fileSync(&#123;postfix: &#x27;.ts&#x27;&#125;) fs.writeSync(file.fd, code) const servicesHost: ts.LanguageServiceHost = &#123; getScriptFileNames: () =&gt; [file.name], getScriptVersion: () =&gt; &#x27;1&#x27;, getScriptSnapshot: (fileName) =&gt; &#123; if (!fs.existsSync(fileName)) &#123; return undefined; &#125; return ts.ScriptSnapshot.fromString(fs.readFileSync(fileName).toString()); &#125;, getCurrentDirectory: () =&gt; process.cwd(), getCompilationSettings: () =&gt; options, getDefaultLibFileName: (options) =&gt; ts.getDefaultLibFilePath(options), fileExists: ts.sys.fileExists, readFile: ts.sys.readFile, readDirectory: ts.sys.readDirectory, &#125;; const service = ts.createLanguageService(servicesHost) return service.getCompilerOptionsDiagnostics() .concat(service.getSemanticDiagnostics(file.name)) .map(diagnostic =&gt; ts.flattenDiagnosticMessageText(diagnostic.messageText, &#x27;\\n&#x27;))&#125; ts.createProgram 메소드를 사용하면 코드가 매우 짧아 질 수 있지만, 속도가 3배 정도 차이가 나서 ts.createLanguageService 메소드를 사용하였습니다. 에러 메시지를 확인해보는 테스트 코드를 작성해봅니다. test/basic-types.test.ts1234567891011121314import &#123;compile&#125; from &#x27;../utils&#x27;describe(&#x27;Basic Types&#x27;, () =&gt; &#123; test(&#x27;Boolean&#x27;, () =&gt; &#123; let isDone: boolean = false export(typeof isDone).toBe(&#x27;boolean&#x27;) const diagnostics = compile(` let isDone: boolean = 1 `) console.log(diagnostics) &#125;)&#125;) 테스트를 수행해 보면 다음과 같은 메시지를 확인할 수 있습니다. 12345678910111213PASS test/basic-types.test.ts (5.799s) Basic Types ✓ Boolean (528ms) ✓ Enum#number (1ms) ✓ Enum#name console.log test/basic-types.test.ts:11 [ &#x27;Type \\&#x27;1\\&#x27; is not assignable to type \\&#x27;boolean\\&#x27;.&#x27; ]Test Suites: 1 passed, 1 totalTests: 3 passed, 3 totalSnapshots: 0 totalTime: 6.508s console.log를 지우고 expect로 변경하고 테스트를 수행하면 통과하는 것을 볼 수 있습니다. 12- console.log(diagnostics)+ expect(diagnostics[0]).toEqual(`Type &#x27;1&#x27; is not assignable to type &#x27;boolean&#x27;.`) 결론TypeScript#Hanbook을 보면서 차근차근 테스트 케이스를 만들다 보면 어느새 익숙해져 있을 것입니다. 검증 테스트는 수행 시간을 너무 많이 잡아 먹는 단점이 있습니다. 그래서 저는 expect로 에러 메시지를 확인하는 방법 보다는 에러 메시지를 주석으로 달아 놓는 것이 더 좋을 것 같다고 생각합니다. 왜냐하면 테스트 속도가 길면 공부를 집중하는데 방해가 될 수 있기 때문입니다. 참고 TypeScript#Using the Compiler API Jest#Configuration ts-jest","categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://gongzza.github.io/categories/Typescript/"}],"tags":[{"name":"test","slug":"test","permalink":"https://gongzza.github.io/tags/test/"},{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"learning","slug":"learning","permalink":"https://gongzza.github.io/tags/learning/"},{"name":"jest","slug":"jest","permalink":"https://gongzza.github.io/tags/jest/"}]},{"title":"Spring + MyBatis + H2 Memory DB를 이용한 로컬 테스트 환경 만들기","slug":"java/spring/spring-mybatis-h2-localtest","date":"2018-02-21T14:39:34.000Z","updated":"2021-02-21T13:41:51.323Z","comments":true,"path":"java/spring/spring-mybatis-h2-localtest/","link":"","permalink":"https://gongzza.github.io/java/spring/spring-mybatis-h2-localtest/","excerpt":"","text":"소개H2 Database의 In-Memory 기능을 이용해서 로컬 테스트 환경을 만들 것입니다. 로컬 테스트 환경을 만들려는 이유는 원격에 있는 DB로 테스트를 하게 되면, 어떤 데이터가 들어있는지 보장할 수 없으며, 모든 데이터를 삭제를 하면은 다른 개발자의 테스트에 영향을 줄 수 있기 때문입니다. 즉, 불확실한 테스트가 됩니다. 그래서 확실하고 빠른 테스트를 하기 위해서 로컬 테스트 환경을 구축하려고 합니다. 시작하기비어있는 Java Project를 생성합니다. 그리고 lib 디렉토리를 생성합니다. Library다음과 같은 라이브러리들을 사용하였습니다. commons-logging-1.2.jar h2-1.4.196.jar lombok.jar mybatis-3.4.5.jar mybatis-spring-1.3.1.jar Spring: aop asm: Spring 3.1.x에서 필요 beans context core expression jdbc test tx spring-asm.jar는 Spring 3.1.x일 때 필요합니다. Spring version이 3.2.x 이상일 경우 Java 1.8을 사용해야 합니다.(자세한 사항은 여기를 참고해 주세요.) SpringRepo에 접속하신 후 원하시는 버전을 클릭 합니다. 그리고 spring-framework-x.x.x.RELEASE-dist.zip 파일을 클릭해서 다운로드를 받습니다. 다운로드 받은 파일의 압축을 풀어보면은 lib 디렉토리 안에 jar 파일들이 있습니다. 위에서 명시한 jar파일들을 찾아서 프로젝트의 lib 디렉토리에 복사합니다. JUnit테스트를 위해서 JUnit을 프로젝트에 추가합니다. Eclipse: 프로젝트 우클릭 -&gt; Properties 클릭 -&gt; Java Build Path -&gt; Add Library… 클릭 -&gt; JUnit 선택 후 다음 -&gt; Finish IntelliJ: 여기를 참고해 주세요. H2H2 jar 파일은 여기에서 다운로드 받습니다. Jar File에서 Maven.org 또는 Sourceforge.net을 클릭하면 jar 파일을 받을 수 있습니다. 다운로드 받은 h2-1.4.196.jar 파일을 위에서 생성한 프로젝트의 lib 디렉토리에 복사합니다. MyBatisMyBatis는 여기에서 다운로드 받습니다. MyBatis-spring은 여기에서 다운로드 받습니다. zip 파일을 다운로드 받은 후 압축을 풀면은 안에 jar 파일이 들어 있습니다. h2 jar 파일과 마찬가지로 lib 디렉토리에 복사합니다. Library 추가 방법Eclipse: jar 파일 우클릭 -&gt; Build Path -&gt; Add to Build Path 클릭 IntelliJ: lib 디렉토리 우클릭 -&gt; Add as Library.. 클릭 ConfigMyBatis 설정MyBatis 설정을 추가합니다. src/resources/config/mybatis/SqlMapConfig.xml1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=&quot;study.localtest.model&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; useGeneratedKeys를 true로 주면은 insert 할 때 키를 자동으로 생성 후 파라메터로 넘어온 오브젝트에 셋팅할 수 있습니다. typeAliases를 package로 주면서 study.localtest.model 패키지 안에 있는 클래스들을 자동으로 Alias를 걸어줍니다. 예를 들어서 parameterType을 study.localtest.model.User로 풀네임을 명시하는 것이 아니라 User로 줄여서 사용할 수 있습니다. 자세한 설정 정보들은 Mapper Setting에서 확인할 수 있습니다. Spring 설정src/resources/config/spring/applicationContext.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;study.localtest&quot;/&gt; &lt;jdbc:embedded-database id=&quot;dataSource&quot; type=&quot;H2&quot;&gt; &lt;jdbc:script location=&quot;classpath:resources/sql/*.sql&quot; /&gt; &lt;/jdbc:embedded-database&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:resources/config/mybatis/SqlMapConfig.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:study/localtest/mapper/*.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!-- mybatis mapper auto scanning --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;study.localtest.mapper&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; spring의 embedded-database를 이용합니다. 초기화 sql들을 테이블 별로 따로 만들 수 있어서 구분하기도 편리합니다. 그리고 한번만 호출 되기 때문에 insert 구문도 추가할 수 있습니다. 아쉬운 점은 MySQL Compatibility Mode를 사용하려면은 Spring boot의 Auto configuration을 이용해야 한다는 점입니다.Working with SQL databases에서 설정 가능한 정보들을 확인할 수 있습니다. Example: application.properties1234spring.datasource.url=jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1spring.datasource.username=saspring.datasource.password=spring.datasource.driver-class-name=org.h2.Driver 여기서 중요한 것은 spring.dataSource.url 입니다. jdbc:h2:mem:localtest: jdbc로 h2 디비에 접속하면서 memory db를 이용하고 db이름은 testdb입니다. MODE=MySQL: MySQL Compatibility Mode를 사용합니다. DB_CLOSE_DELAY=-1: DB 연결을 닫아도 VM에서 살아서 Content를 지키도록 합니다. 추가적으로 INIT=runscript from &#39;./sql/users.sql&#39;: 연결될 때마다 스크립트를 실행합니다. 자세한 기능들은 Features를 확인하시기 바랍니다. Schema테이블을 작성합니다. src/resources/sql/users.sql12345create table users ( id int auto_increment primary key, name varchar(20) not null, password varchar(20) not null); 저는 테이블 별로 sql 파일을 만드는 편입니다. 그리고 기초 데이터가 필요하다면은 create table 밑에 insert 구문을 추가 작성하면 됩니다. Model테이블과 매칭되는 User Model을 추가합니다. src/study/localtest/model/User.java12345678910package study.localtest.model;import lombok.Data;@Datapublic class User &#123; private int id; private String name; private String password;&#125; Lombok의 @Data Annotation을 사용하면 Setter/Getter 와 toString()을 자동으로 만들 수 있습니다. UserMapper간단한 CRUD 기능만 작성하겠습니다. Test테스트 코드를 작성합니다. src/study/localtest/mapper/UserMapperTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package study.localtest.mapper;import static org.hamcrest.CoreMatchers.is;import static org.hamcrest.CoreMatchers.not;import static org.hamcrest.CoreMatchers.nullValue;import static org.junit.Assert.assertThat;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import study.localtest.model.User;@ContextConfiguration(locations=&quot;classpath:resources/config/spring/applicationContext.xml&quot;)@RunWith(SpringJUnit4ClassRunner.class)public class UserMapperTest &#123; @Autowired UserMapper userMapper; User user; @Before public void setUp() &#123; user = new User(); user.setName(&quot;gongzza&quot;); user.setPassword(&quot;gzgz&quot;); &#125; @Test public void add() &#123; int cnt = userMapper.add(user); assertThat(&quot;1건이 등록되어야 한다.&quot;, cnt, is(1)); assertThat(&quot;ID가 0이 아니어야 한다.&quot;, user.getId(), is(not(0))); User userAdded = userMapper.getUserById(user.getId()); checkSameUser(userAdded, user); &#125; @Test public void update() &#123; int cnt = userMapper.add(user); assertThat(&quot;1건이 등록되어야 한다.&quot;, cnt, is(1)); user.setName(&quot;gg&quot;); user.setPassword(&quot;pp&quot;); cnt = userMapper.update(user); assertThat(&quot;1건이 수정되어야 한다.&quot;, cnt, is(1)); User userUpdated = userMapper.getUserById(user.getId()); checkSameUser(userUpdated, user); &#125; @Test public void delete() &#123; int cnt = userMapper.add(user); assertThat(&quot;1건이 등록되어야 한다.&quot;, cnt, is(1)); int id = user.getId(); cnt = userMapper.delete(id); assertThat(&quot;1건이 삭제되어야 한다.&quot;, cnt, is(1)); User userDeleted = userMapper.getUserById(id); assertThat(&quot;검색 되는 사용자가 없어야 한다.&quot;, userDeleted, is(nullValue())); &#125; private void checkSameUser(User user1, User user2) &#123; assertThat(&quot;이름이 같아야 한다.&quot;, user1.getName(), is(user2.getName())); assertThat(&quot;비밀번호가 같아야 한다.&quot;, user1.getPassword(), is(user2.getPassword())); &#125;&#125; 테스트 코드를 작성하고 나면은 빨간줄들이 보일 것입니다. 이제 그 빨간줄이 그어진 것들만 작성하면 됩니다. InterfaceUserMapper는 Interface로 작성합니다. src/study/localtest/mapper/UserMapper.java1234567891011121314151617package study.localtest.mapper;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Param;import study.localtest.model.User;public interface UserMapper &#123; public User getUserById(int id); public int add(User user); public int update(User user); @Delete(&quot;delete from users where id = #&#123;id&#125;&quot;) public int delete(@Param(&quot;id&quot;) int id);&#125; 간단한 쿼리는 메소드에 Annotation으로 직접 작성할 수 있습니다. Mapper XML복잡한 쿼리는 XML에서 작성합니다. src/study/localtest/mapper/UserMapper.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;study.localtest.mapper.UserMapper&quot;&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;User&quot; keyProperty=&quot;id&quot;&gt; insert into users (name, password) values (#&#123;name&#125;, #&#123;password&#125;) &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;User&quot;&gt; update users set name = #&#123;name&#125;, password = #&#123;password&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot; parameterType=&quot;int&quot;&gt; select id, name, password from users where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 여기서 중요한 것은 mapper의 namespace가 study.localtest.mapper.UserMapper를 바라보는 것과 쿼리 id가 UserMapper의 메소드 명과 일치해야 한다는 점입니다. 그리고 parameterType과 resultType도 namespace처럼 package까지 적어주어야 하지만, 위에서 typeAliases를 걸어주었기 때문에 클래스명 만으로도 선언이 가능합니다. 자세한 설정 정보는 Mapper XML에서 확인하시기 바랍니다. 결론이제 Mapper와 Model을 자유롭게 추가하면서 빠르게 테스트를 수행할 수 있게 되었습니다. 그리고 Maven이나 Gradle을 꼭 사용해야겠다는 생각이 들었습니다. 참고 http://www.h2database.com http://www.mybatis.org/mybatis-3/ko","categories":[{"name":"Java","slug":"Java","permalink":"https://gongzza.github.io/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://gongzza.github.io/categories/Java/Spring/"}],"tags":[{"name":"test","slug":"test","permalink":"https://gongzza.github.io/tags/test/"},{"name":"java","slug":"java","permalink":"https://gongzza.github.io/tags/java/"},{"name":"junit","slug":"junit","permalink":"https://gongzza.github.io/tags/junit/"},{"name":"database","slug":"database","permalink":"https://gongzza.github.io/tags/database/"},{"name":"h2","slug":"h2","permalink":"https://gongzza.github.io/tags/h2/"},{"name":"spring","slug":"spring","permalink":"https://gongzza.github.io/tags/spring/"},{"name":"mybatis","slug":"mybatis","permalink":"https://gongzza.github.io/tags/mybatis/"}]},{"title":"지속적인 테스트 플러그인 - Infinitest 소개","slug":"java/eclipse/continuous-testing-plugin-infinitest","date":"2018-02-05T11:24:05.000Z","updated":"2021-02-21T13:41:51.322Z","comments":true,"path":"java/eclipse/continuous-testing-plugin-infinitest/","link":"","permalink":"https://gongzza.github.io/java/eclipse/continuous-testing-plugin-infinitest/","excerpt":"","text":"Infinitest는 지속적인 테스트를 해주는 Eclipse와 IntelliJ 플러그인입니다.(여기에서는 Eclipse에 대해서만 소개합니다.) Infinitest는 소스 코드 변경을 감지해서 영향도가 있는 테스트를 수행합니다. 소스 코드를 저장할 때 마다 자동으로 테스트를 돌려 줘서 편하게 테스트와 비즈니스 로직을 개발할 수 있을 것 같습니다. github: http://infinitest.github.iouser guide: http://infinitest.github.io/doc/user_guide.html Install Eclipse설치 방법은 간단합니다. Help -&gt; Eclipse Marketplace 열기 infinitest 검색 및 설치 참 쉽죠? 자세한 사항은 여기를 참고하시기 바랍니다. Filtering Tests정규화 표현식으로 수행하지 않을 테스트들을 걸러낼 수 있습니다. infinitest.filters파일을 프로젝트 루트(working directory)에 추가합니다. infinitest.filters1234567891011ITest로 끝나는 테스트:.*ITestInner Classes:.*\\$.*package 안에 있는 테스트:com\\.mycompany\\.mypackage\\..*모든 테스트:.* 테스트 시간이 너무 오래 걸리면 위 기능을 이용해서 테스트를 수행하지 않도록 합니다. Preferences설치하고 나면 Preferences에 Infinitest가 추가됩니다.(Window -&gt; Preferences -&gt; Infinitest) Continuously Test 체크를 해지하면, 테스트를 수행하지 않습니다. Slow Test Warning (milliseconds)는 기본값이 500ms 이고 테스트 수행 시간이 넘어가게 되면 테스트에 warning을 표시하게 됩니다.현재 무시하는 방법은 없고 최대값인 2147483647를 입력하는 방법만 있는 것 같습니다. Continuously Test테스트 수행 여부는 왼쪽 하단에 바로 표시가 되는데요. 초록색: 테스트 성공 노란색: 수행 테스트가 없음 또는 Infinitest 비활성화 빨간색: 테스트 실패 프로젝트에 컴파일 에러가 있으면, Infinitest가 비활성화 되어 테스트가 수행되지 않습니다. 테스트가 실패하면 빨간색 바가 표시되며 Problems와 실패한 테스트에서 위치를 볼 수 있습니다. Infinitest isn’t running my testsInfinitest가 수행되지 않을때: Infinitest preferences(Window-&gt;Preferences) 에서 Continously Test 체크 확인 Project 메뉴 밑에서 Build Automatically 체크 확인 filter가 안될 때에는 infinitest.filters 파일이 루트 디렉토리에 있는지 확인 References http://infinitest.github.io/doc/user_guide.html","categories":[{"name":"Java","slug":"Java","permalink":"https://gongzza.github.io/categories/Java/"}],"tags":[{"name":"test","slug":"test","permalink":"https://gongzza.github.io/tags/test/"},{"name":"java","slug":"java","permalink":"https://gongzza.github.io/tags/java/"},{"name":"eclipse","slug":"eclipse","permalink":"https://gongzza.github.io/tags/eclipse/"},{"name":"eclipse-plugin","slug":"eclipse-plugin","permalink":"https://gongzza.github.io/tags/eclipse-plugin/"},{"name":"tdd","slug":"tdd","permalink":"https://gongzza.github.io/tags/tdd/"},{"name":"junit","slug":"junit","permalink":"https://gongzza.github.io/tags/junit/"}]},{"title":"AdonisJs + Swagger-ui","slug":"nodejs/adonisjs/adonisjs-swagger","date":"2018-01-22T14:35:38.000Z","updated":"2021-02-21T13:41:51.324Z","comments":true,"path":"nodejs/adonisjs/adonisjs-swagger/","link":"","permalink":"https://gongzza.github.io/nodejs/adonisjs/adonisjs-swagger/","excerpt":"","text":"AdonisJs에 Swagger를 붙여보는 작업을 합니다. 시작하기필수조건AdonisJs로 프로젝트를 구성하기 위해서는 다음과 같은 환경이 필요합니다. Node.js 8.0 이상 Npm 3.0 이상 Cli toolcli tool을 전역으로 설치합니다. 12$ npm i -g @adonisjs/cli+ @adonisjs/cli@3.0.17 프로젝트 생성위에서 설치한 cli tool을 이용해서 프로젝트를 생성합니다. 12345678910111213$ adonis new yardstick...√ Your current Node.js &amp; npm version match the AdonisJs requirements!√ Cloned [adonisjs/adonis-fullstack-app]√ npm: Dependencies installed√ Default environment variables copied√ generated unique APP_KEY┌─────────────────────────────────────┐│ ✨ Application crafted ││ ││ cd yardstick ││ adonis serve --dev │└─────────────────────────────────────┘ adonis new &lt;PATH&gt; 명령어로 프로젝트를 생성할 경우 기본적으로 fullstack app를 기반으로 생성합니다. 탬플릿을 따로 작성해서 사용하고 싶은 경우 --blueprint=&lt;github-org/repo&gt;를 명령어에 같이 넘겨주면 됩니다. 자세한 사항은 adonis new --help로 확인하면 됩니다. Swagger 설치123$ npm i -D swagger-jsdoc swagger-ui-dist+ swagger-ui-dist@3.9.2+ swagger-jsdoc@1.9.7 Swagger-ui 복사AdonisJs는 express처럼 특정 static 디렉토리를 지정할 수 없기 때문에 static assets 공간으로 사용되는 public 디렉토리에 파일들을 복사합니다. 1234567$ mkdir public/docs# Copy swagger ui$ cp node_modules/swagger-ui-dist/ public/docs# Optional$ rm public/docs/package.json Swagger-ui화면이 잘 나오는지 서버를 실행해서 확인해봅니다. 123456789$ adonis serve --dev┌──────────────────────┐│ ││ Started server ││ Watcher: On ││ Debugger: Off ││ │└──────────────────────┘2018-01-22T05:04:32.625Z - info: serving app on http://127.0.0.1:3333 http://localhost:3333/docs 에 접속해보면은 http://petstore.swagger.io/v2/swagger.json 의 swagger-ui를 볼 수 있습니다. Swagger-jsdoc이제 swagger-jsdoc을 이용해서 우리의 spec을 내려주는 api를 추가합니다. 그리고 간단하게 Hello world를 리턴하는 api도 추가해줍니다. start/routes.js1234567891011121314151617181920212223242526272829303132const Route = use(&#x27;Route&#x27;)/** * Swagger jsDoc */const swaggerJSDoc = use(&#x27;swagger-jsdoc&#x27;)Route.get(&#x27;/api-specs&#x27;, async (&#123; request, response &#125;) =&gt; &#123; const options = &#123; swaggerDefinition: &#123; info: &#123; title: &#x27;My REST API&#x27;, // Title (required) version: &#x27;1.0.0&#x27; // Version (required) &#125; &#125;, apis: [&#x27;start/routes.js&#x27;] // Path to the API docs &#125; // Initialize swagger-jsdoc -&gt; returns validated swagger spec in json format return swaggerJSDoc(options)&#125;)/** * @swagger * /greeting: * get: * summary: 인사하기 * responses: * 200: * description: 인사말 * schema: * type: string */Route.get(&#x27;/greeting&#x27;, () =&gt; &#x27;Hello world&#x27;) 서버를 종료하지 않았다면, 자동으로 서버가 재시작 됩니다. 12changed yardstick\\start\\routes.js2018-01-22T05:30:44.933Z - info: serving app on http://127.0.0.1:3333 http://localhost:3333/greeting 으로 접속해보면 Hello world가 보일 것입니다. swagger ui urlswagger-ui의 spec url을 변경합니다. public/docs/index.html12345678910window.onload = function() &#123; // Build a system const ui = SwaggerUIBundle(&#123; url: &quot;../api-docs&quot;, ... &#125;) window.ui = ui&#125; Swagger다시 http://localhost:3333/docs 에 접속해 보면은 다음과 같은 화면을 볼 수 있습니다. [Try it out]버튼을 누른 후 [Execute]버튼을 눌러보면, 정상적으로 Hello world가 오는 것을 볼 수 있습니다. 참고 http://adonisjs.com https://github.com/duyluonglc/adonis-mongodb-boilerplate http://blog.jeonghwan.net/기존-프로젝트와-swagger-ui-연동하기/","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://gongzza.github.io/categories/Node-js/"},{"name":"AdonisJs","slug":"Node-js/AdonisJs","permalink":"https://gongzza.github.io/categories/Node-js/AdonisJs/"}],"tags":[{"name":"adonisjs","slug":"adonisjs","permalink":"https://gongzza.github.io/tags/adonisjs/"},{"name":"swagger-ui","slug":"swagger-ui","permalink":"https://gongzza.github.io/tags/swagger-ui/"},{"name":"swagger-jsdoc","slug":"swagger-jsdoc","permalink":"https://gongzza.github.io/tags/swagger-jsdoc/"},{"name":"node.js","slug":"node-js","permalink":"https://gongzza.github.io/tags/node-js/"}]},{"title":"Storybook for Vue","slug":"vuejs/storybook-for-vue","date":"2017-12-09T06:24:36.000Z","updated":"2021-02-21T13:41:51.338Z","comments":true,"path":"vuejs/storybook-for-vue/","link":"","permalink":"https://gongzza.github.io/vuejs/storybook-for-vue/","excerpt":"","text":"StorybookStorybook은 UI 컴포넌트를 위한 개발 환경을 만들수 있습니다.App이랑 상관없이 돌아가며, UI 컴포넌트들의 여러 상태들을 예제로 작성해서 볼 수 있습니다.App에서 사용하는 UI 컴포넌트들의 바이블이라고 보시면 될 것 같습니다. Getting StartedStorybook for Vue에 들어가 보시면 단계별로 설명이 나와있습니다. Create a projectvue-cli를 이용하여 webpack-simple로 프로젝트를 구성합니다. 123456789101112131415161718$ vue init webpack-simple storybook-for-vue? Project name storybook-for-vue? Project description A Vue.js project? Author gongzza &lt;gz.us.to@gmail.com&gt;? License MIT? Use sass? Yes vue-cli · Generated &quot;storybook-for-vue&quot;. To get started: cd storybook-for-vue npm install npm run dev$ cd storybook-for-vue &amp;&amp; npm install...added 890 packages in 79.194s Storybook for VueStorybook은 Webpack 설정과 dev 서버를 내장하고 있습니다.따라서 기존의 개발환경을 해치지 않고 독립적으로 실행이 가능합니다. Webpack 설정은 수정이 가능합니다. 참조 @storybook/vue를 설치합니다.12$ npm i -D @storybook/vue+ @storybook/vue@3.2.17 npm script를 추가합니다.package.json12345&#123; &quot;scripts&quot;: &#123; &quot;storybook&quot;: &quot;start-storybook -p 9001 -c .storybook&quot; &#125;&#125; config 파일을 추가합니다.npm script에서 -c 옵션으로 보고 있는 .storybook 디렉토리에 config.js 파일을 추가할 것입니다. config.js 파일에서는 다음과 같은 작업을 합니다. Import와 Vue.component를 통한 Global 컴포넌트 등록 Vue plugins 설치 Stories 로드 여기서 우리는 Stories 로드만 필요하기 때문에 다음과 같이 작성합니다. .storybook/config.js12345678import &#123; configure &#125; from &#x27;@storybook/vue&#x27;function loadStories() &#123; // You can require as many stories as you need. require(&#x27;../src/stories&#x27;);&#125;configure(loadStories, module); 다음은 Storybook for Vue에 있는 ./storybook/config.js 예제입니다. 1234567891011121314151617181920import &#123; configure &#125; from &#x27;@storybook/vue&#x27;;import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;; // Vue plugins// Import your custom components.import Mybutton from &#x27;../src/stories/Button.vue&#x27;;// Install Vue plugins.Vue.use(Vuex);// Register custom components.Vue.component(&#x27;my-button&#x27;, Mybutton);function loadStories() &#123; // You can require as many stories as you need. require(&#x27;../src/stories&#x27;);&#125;configure(loadStories, module); stories를 작성합니다..storybook/config.js에서 바라보는 경로 ../src/stories에 index.js파일을 추가합니다. src/stories/index.js123456789import &#123; storiesOf &#125; from &#x27;@storybook/vue&#x27;import App from &#x27;../App.vue&#x27;storiesOf(&#x27;App&#x27;, module) .add(&#x27;main&#x27;, () =&gt; (&#123; components: &#123; App &#125;, template: &#x27;&lt;app&gt;&lt;/app&gt;&#x27; &#125;)) Storybook 실행다음 명령으로 Storybook을 실행합니다. 123456789101112$ npm run storybook&gt; storybook-for-vue@1.0.0 storybook /vue/storybook-for-vue&gt; start-storybook -p 9001 -c .storybook@storybook/vue v3.2.17Failed to load ./.env.=&gt; Loading custom .babelrc=&gt; Using default webpack setup based on &quot;vue-cli&quot;.webpack built 4158726a27d45de70301 in 10213msStorybook started on =&gt; http://localhost:9001/ Storybook이 hot 모드로 켜져 있기 때문에 App.vue를 수정하면 화면에 바로 반영되는 것을 볼 수 있습니다. 이렇게 하나의 컴포넌트에 집중해서 개발할 수 있습니다. stories 파일 나누기src/stories/index.js 파일 하나에 모든 스토리를 넣으면 파일이 너무 커질 것입니다. 그래서 컴포넌트 별로 스토리 파일을 따로 만드는 것이 관리하기도 좋을 것입니다. 그리고 webpack의 require.context를 이용해서 파일이 자동으로 추가되도록 하면, 파일을 추가할 때 번거로운 작업을 하지 않아도 됩니다. .storybook/config.js12345678910import &#123; configure &#125; from &#x27;@storybook/vue&#x27;function loadStories() &#123; // You can require as many stories as you need. const load = req =&gt; req.keys().map(req) load(require.context(&#x27;../src/stories&#x27;, true, /\\.story\\.js$/))&#125;configure(loadStories, module); 이전 index.js 파일명을 App.story.js로 변경합니다. src/stories/App.story.js123456789import &#123; storiesOf &#125; from &#x27;@storybook/vue&#x27;import App from &#x27;../App.vue&#x27;storiesOf(&#x27;App&#x27;, module) .add(&#x27;welcome&#x27;, () =&gt; (&#123; components: &#123; App &#125;, template: &#x27;&lt;app&gt;&lt;/app&gt;&#x27; &#125;)) 이제 파일명이 .story.js 끝나는 파일을 추가하면 자동으로 스토리에 추가될 것입니다. storybook-addon-vue-infoStorybook의 Addon 기능을 이용해서 Vue 컴포넌트의 정보를 잘 표현해 주는 storybook-addon-vue-info Addon이 있습니다. 현재는 Usage, Preview, Props를 표시해주고 있지만, 아직 개발 초기 단계라서 앞으로 어떻게 변할지 기대가 큽니다. 여기에 들어가면 샘플 페이지를 볼 수 있습니다. 먼저 설치를 합니다. 12$ npm i -D storybook-addon-vue-info+ storybook-addon-vue-info@0.1.5 props를 받는 예제를 하나 작성합니다. src/components/Card.vue12345678910111213141516171819&lt;template lang=&quot;html&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;card&#x27; props: &#123; title: &#123; type: String, required: true &#125;, message: String &#125;&#125;&lt;/script&gt; 스토리를 작성할때 template은 필수입니다. src/stories/components/Card.story.js123456789101112131415import &#123; storiesOf &#125; from &#x27;@storybook/vue&#x27;import VueInfoAddon from &#x27;storybook-addon-vue-info&#x27;import Card from &#x27;../../components/Card.vue&#x27;storiesOf(&#x27;Card&#x27;, module) .addDecorator(VueInfoAddon) .add(&#x27;only title&#x27;, () =&gt; (&#123; components: &#123; Card &#125;, template: &#x27;&lt;card title=&quot;Card Title&quot;&gt;&lt;/card&gt;&#x27; &#125;)) .add(&#x27;with message&#x27;, () =&gt; (&#123; components: &#123; Card &#125;, template: &#x27;&lt;card title=&quot;Card Title&quot; message=&quot;With Message&quot;&gt;&lt;/card&gt;&#x27; &#125;)) 서버 재시작도 필요 없이 파일을 추가하면, 화면이 자동으로 갱신되면서 추가되는 것을 확인할 수 있습니다. Conclusion하나의 UI 컴포넌트를 집중해서 개발할 수 있는 환경을 구축할 수 있어서 좋은 것 같습니다.그리고 만들어진 UI 컴포넌트들의 사용법을 쉽게 파악할 수 있어서 한층 더 빠른 개발이 가능할 것 같습니다. storybook의 영감을 받아서 만든 Vue 친화적인 vue-play도 있는데요. 마지막 커밋이 May 23 인걸로 봐서는 더 이상 개발은 하지 않는 것 같습니다. References https://storybook.js.org https://github.com/pocka/storybook-addon-vue-info/ https://github.com/vue-play/vue-play","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"},{"name":"storybook","slug":"storybook","permalink":"https://gongzza.github.io/tags/storybook/"}]},{"title":"Vue Component Lazy Loading with Webpack","slug":"vuejs/vue-lazy-loading-with-webpack","date":"2017-11-30T16:02:40.000Z","updated":"2021-02-21T13:41:51.339Z","comments":true,"path":"vuejs/vue-lazy-loading-with-webpack/","link":"","permalink":"https://gongzza.github.io/vuejs/vue-lazy-loading-with-webpack/","excerpt":"","text":"Vue-Router#지연된 로딩과 Vue#비동기 컴포넌트를 참고하여 작성하였습니다. Vue 컴포넌트를 필요한 시점에 호출하는 방법에 대해서 알아보도록 하겠습니다. Lazy loading지연 로딩(lazy loading)이란 데이터를 필요한 시점에 서버에 요청해서 가져오는 방법으로 웹 사이트와 서버를 최적화 할 때 많이 사용됩니다. 웹 사이트는 초기 랜더링에 필요한 데이터만 받기 때문에 빠르게 랜더링을 시작해서 사용자에게 보다 빠르게 화면을 보여줄 수 있게 됩니다. 서버는 큰 데이터를 한번에 내려주면서 대역폭을 모두 차지하는 것이 아니라 작게 나누어진 데이터를 내려주기 때문에 더 많은 요청을 처리할 수 있게 됩니다. 시작하기먼저 vue-cli를 이용해서 개발 환경을 구축합니다. 123456789101112131415161718192021$ npm i -g vue-cli+ vue-cli@2.9.1$ vue init webpack-simple simple-vue-lazy-component? Project name simple-vue-lazy-component? Project description A Vue.js project? Author gongzza &lt;gz.us.to@gmail.com&gt;? License MIT? Use sass? No vue-cli · Generated &quot;simple-vue-lazy-component&quot;. To get started: cd simple-vue-lazy-component npm install npm run dev$ cd simple-vue-lazy-component &amp;&amp; npm install...added 804 packages in 75.235s Code splitting지연 로딩을 하기 위해서는 먼저 하나의 큰 파일을 작게 나누어야 합니다. 그러기 위해서 webpack의 import() 구문을 사용합니다. import()는 내부적으로 Promise를 사용합니다. 따라서 오래된 브라우저는 Promise polyfill을 사용해야 합니다. (es6-promise or promise-polyfill) Babelimport() 구문을 사용하기 위해서는 syntax-dynamic-import를 추가해 줘야 합니다. 12$ npm install --save-dev babel-plugin-syntax-dynamic-import+ babel-plugin-syntax-dynamic-import@6.18.0 .babelrc123&#123; &quot;plugins&quot;: [&quot;syntax-dynamic-import&quot;]&#125; Webpack단순히 dynamic import만 하면은 number.filename 형식으로 파일명이 자동으로 생성됩니다.ex) 0.bundle.js 다음과 같이 주석으로 이름을 지정하게 되면 그룹으로도 지정할 수 있게 됩니다. 123import(/* webpackChunkName: &quot;lodash&quot; */ &#x27;lodash&#x27;).then(_ =&gt; &#123; ...&#125;) 그리고 output.chunkFilename을 추가해서 지정한 파일명으로 저장되도록 합니다. webpack.config.js12345module.exports = &#123; output: &#123; chunkFilename: &#x27;[name].js&#x27; &#125;&#125; production으로 배포할 때에는 chunkFilename: [name].[chunkhash:7].js 식으로 지정하는 것이 좋습니다. Example홈 화면에서 Vue Logo를 보여주고 클릭하면, “Welcome To Your Vue.js App”을 보여주는 페이지로 이동하는 예제를 작성해 보겠습니다. 먼저 vue-router를 설치합니다. 12$ npm install --save-dev vue-router+ vue-router@3.0.1 그 다음 페이지들을 작성합니다. pages/Home.vue1234567891011&lt;template lang=&quot;html&quot;&gt; &lt;router-link to=&quot;/welcome&quot;&gt; &lt;img src=&quot;../assets/logo.png&quot; alt=&quot;logo&quot;&gt; &lt;/router-link&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;home-page&#x27;&#125;&lt;/script&gt; pages/Welcome.vue12345678910111213141516&lt;template lang=&quot;html&quot;&gt; &lt;div&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;welcome-page&#x27;, data() &#123; return &#123; msg: &#x27;Welcome to Your Vue.js App&#x27; &#125; &#125;&#125;&lt;/script&gt; 그 다음 라우터를 설정합니다. router.js123456789101112131415161718192021import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;Vue.use(Router)const routes = [ &#123; path: &#x27;/&#x27;, component: () =&gt; import(/* webpackChunkName: &#x27;home&#x27; */&#x27;./pages/Home.vue&#x27;), &#125;, &#123; path: &#x27;/welcome&#x27;, component: () =&gt; import(/* webpackChunkName: &#x27;welcome&#x27; */&#x27;./pages/Welcome.vue&#x27;) &#125;]const router = new Router(&#123; routes&#125;)export default router main.js123456789import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;new Vue(&#123; el: &#x27;#app&#x27;, router, render: h =&gt; h(App)&#125;) 앱 화면에서 페이지를 보여주도록 &lt;router-view&gt;를 추가합니다. App.vue1234567891011&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;app&#x27;,&#125;&lt;/script&gt; npm run dev로 서버를 실행해서 보면 build.js가 먼저 호출되고 home.js가 호출 됩니다. 그리고 /welcome 페이지로 이동하면서 welcome.js를 호출하는 것을 볼 수 있습니다. Advanced Async Components컴포넌트#고급 비동기 컴포넌트를 보면은 다음과 같이 비동기 컴포넌트를 선언할 수 있다고 합니다. 12345678910111213const AsyncComp = () =&gt; (&#123; // 로드하는 컴포넌트입니다. 반드시 Promise이어야합니다. component: import(&#x27;./MyComp.vue&#x27;), // 비동기 컴포넌트가 로드되는 동안 사용할 컴포넌트 loading: LoadingComp, // 실패했을 경우 사용하는 컴포넌트 error: ErrorComp, // 로딩 컴포넌트를 보여주기전 지연하는 정도. 기본값: 200ms. delay: 200, // 시간이 초과되면 에러용 컴포넌트가 표시됩니다. // 기본값: Infinity. timeout: 3000&#125;) Example예제를 만들어서 확인해 보겠습니다. 홈 화면의 Vue logo를 Logo.vue 컴포넌트로 만들어서 비동기로 호출해 보도록 하겠습니다. 먼저 로딩 컴포넌트를 만듭니다. components/Loading.vue123456789101112131415161718192021222324&lt;template lang=&quot;html&quot;&gt; &lt;div class=&quot;loader&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;loading&#x27;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;.loader &#123; border: 16px solid #f3f3f3; /* Light grey */ border-top: 16px solid #3498db; /* Blue */ border-radius: 50%; width: 60px; height: 60px; animation: spin 2s linear infinite;&#125;@keyframes spin &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125;&lt;/style&gt; components/Logo.vue123456789&lt;template lang=&quot;html&quot;&gt; &lt;img src=&quot;../assets/logo.png&quot;&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;logo&#x27;&#125;&lt;/script&gt; 홈 화면에서 Logo.vue 비동기 컴포넌트를 추가합니다. pages/Home.vue12345678910111213141516171819&lt;template lang=&quot;html&quot;&gt; &lt;router-link to=&quot;/welcome&quot;&gt; &lt;logo&gt;&lt;/logo&gt; &lt;/router-link&gt;&lt;/template&gt;&lt;script&gt;import Loading from &#x27;../components/Loading.vue&#x27;export default &#123; name: &#x27;home-page&#x27;, components: &#123; Logo: () =&gt; (&#123; component: import(/* webpackChunkName: &#x27;logo&#x27; */&#x27;../components/Logo.vue&#x27;), loading: Loading &#125;) &#125;&#125;&lt;/script&gt; 하지만 데이터 양이 너무 적어서 Loading.vue가 정상적으로 동작하는지 확인하기 어려울 것입니다. 이럴 경우 component가 Promise라는 점을 이용해서 다음과 같이 지연 로딩을 시킬 수 있습니다. 12345678export default &#123; components: &#123; Logo: () =&gt; (&#123; component: new Promise(resolve =&gt; setTimeout(() =&gt; resolve(import(/* webpackChunkName: &#x27;logo&#x27; */&#x27;../components/Logo.vue&#x27;)), 5000)), loading: Loading &#125;) &#125;&#125; 확인해 보면 5초동안 로딩 컴포넌트가 보인 후 로고가 나타나는 것을 확인하실 수 있습니다. Vue-router안타깝게도 위에서 사용한 형식을 vue-router에서는 사용할 수 없었습니다. 홈페이지에 다음과 같은 문구가 적혀 있습니다. vue-router에서 라우트 컴포넌트로 사용하는 경우 라우트 네비게이션이 발생하기전에 비동기 컴포넌트가 먼저 작동하기때문에 이러한 특성은 무시됩니다. vue-router 2.4.0 상위 버전을 사용할 경우 위 구문에서 component 속성은 해석이 가능하지만, loading 같은 속성은 정상동작 하지 않았습니다. Vue-router#네비게이션 가드를 이용하면 구현이 가능할 것 같습니다. router.beforeResolve의 설명에 다음과 같이 적혀 있습니다. 모든 컴포넌트 가드와 비동기 라우트 컴포넌트를 불러온 후 네비게이션 가드를 확인하기 전에 호출된다. 즉, router.beforeEach에서 로딩을 시작하고 비동기 라우트 컴포넌트 로딩이 완료된 후 router.beforeResolve가 호출되서 로딩을 완료하면 될 것 같습니다. Conclusion코드를 나누게 되면은 캐시에도 큰 영향을 주게 됩니다. 즉 재배포를 할 때마다 전체 배포가 아닌 변화가 생긴 파일만 배포를 하게 되면서 서버의 부하를 크게 줄일 수 있고 사용자 입장에서도 업데이트 되는 시간이 크게 줄어들 것입니다. 적용하기가 크게 어렵지 않아서 나중에 한번에 나누는 것 보다는 처음부터 차근차근 나누면서 시작하는 것이 좋을 것 같습니다. References https://router.vuejs.org/kr/advanced/lazy-loading.html https://kr.vuejs.org/v2/guide/components.html#비동기-컴포넌트 https://webpack.js.org/guides/code-splitting/ http://babeljs.io/docs/plugins/syntax-dynamic-import/","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://gongzza.github.io/tags/vuejs/"},{"name":"webpack","slug":"webpack","permalink":"https://gongzza.github.io/tags/webpack/"},{"name":"lazy-loading","slug":"lazy-loading","permalink":"https://gongzza.github.io/tags/lazy-loading/"},{"name":"component","slug":"component","permalink":"https://gongzza.github.io/tags/component/"},{"name":"vue-router","slug":"vue-router","permalink":"https://gongzza.github.io/tags/vue-router/"}]},{"title":"Vue.js Unit Testing with Jest","slug":"vuejs/vue-unit-testing-with-jest","date":"2017-11-05T11:27:57.000Z","updated":"2021-02-21T13:41:51.340Z","comments":true,"path":"vuejs/vue-unit-testing-with-jest/","link":"","permalink":"https://gongzza.github.io/vuejs/vue-unit-testing-with-jest/","excerpt":"","text":"Jest를 이용해서 Vue.js 테스트 환경을 만들어 볼 것입니다. Test Runner로 Mocha + Webpack도 있었지만, Jest를 선택하게 되었습니다. 테스트 실행이 굉장히 빠릅니다. 스냅샷을 찍어서 비교가 가능합니다. 이는 직접 DOM이 어떻게 그려질지 확인할 수 있습니다. Assertion(Expect)과 Code Coverage 등의 기능들이 내장되어 있습니다. 요즘 대새인 Zero Configuration 다양한 CLI 옵션들이 있습니다. 좀 더 고민이 되는 경우 Test Runner 선택하기를 참고하시면 도움이 될 것 같습니다. 시작하기Testing Single File Components with Jest에서 설명이 매우 잘 되어 있습니다. 그래서 위 내용을 참고로 작성 하였습니다. 프로젝트 생성vue-cli를 이용해서 webpack-simple 탬플릿으로 프로젝트를 생성하겠습니다. 12345678910111213141516$ vue init webpack-simple vue-test-jest? Project name vue-test-jest? Project description A Vue.js project? Author gongzza &lt;gz.us.to@gmail.com&gt;? Use sass? No vue-cli · Generated &quot;vue-test-jest&quot;. To get started: cd vue-test-jest npm install npm run dev$ cd vue-test-jest &amp;&amp; npm install Jest 셋팅Jest와 vue-test-utils를 설치합니다. 그리고 *.vue 파일을 처리하기 위해서 vue-jest를 설치합니다. 1234$ npm i -D jest vue-test-utils vue-jest+ jest@21.2.1+ vue-test-utils@1.0.0-beta.4+ vue-jest@1.0.1 Package.jsonpackage.json에 Jest 설정 옵션을 정의합니다. package.json12345678910111213141516171819&#123; // ... &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;jest&quot; &#125;, &quot;jest&quot;: &#123; &quot;moduleFileExtensions&quot;: [ &quot;js&quot;, &quot;json&quot;, // tell Jest to handle *.vue files &quot;vue&quot; ], &quot;transform&quot;: &#123; // process *.vue files with vue-jest &quot;.*\\\\.(vue)$&quot;: &quot;&lt;rootDir&gt;/node_modules/vue-jest&quot; &#125;, &quot;mapCoverage&quot;: true &#125;&#125; Handling webpack aliaseswebpack config에서 resolve alias를 사용하고 있다면, Jest 에서도 설정해 주어야 합니다. package.json12345678910&#123; // ... &quot;jest&quot;: &#123; // ... // support the same @ -&gt; src alias mapping in source code &quot;moduleNameMapper&quot;: &#123; &quot;^@/(.*)$&quot;: &quot;&lt;rootDir&gt;/src/$1&quot; &#125; &#125;&#125; Configuring Babel for Jestbabel을 사용하고 있다면, babel-jest도 설치가 필요합니다. 12$ npm i -D babel-jest+ babel-jest@21.2.0 기본적으로 babel-jest는 자동으로 설치된다고 합니다. 하지만, 우리가 *.vue를 추가 하면서 babel-jest을 명시적으로 추가해 주어야 합니다. package.json123456789101112&#123; // ... &quot;jest&quot;: &#123; // ... &quot;transform&quot;: &#123; // ... // process js with babel-jest &quot;^.+\\\\.js$&quot;: &quot;&lt;rootDir&gt;/node_modules/babel-jest&quot; &#125;, // ... &#125;&#125; 그리고 .babelrc에 env.test를 설정합니다. .babelrc123456789101112&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;modules&quot;: false &#125;] ], &quot;env&quot;: &#123; &quot;test&quot;: &#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;targets&quot;: &#123; &quot;node&quot;: &quot;current&quot; &#125;&#125;] ] &#125; &#125;&#125; async/await을 사용할 경우 plugins에 transform-runtime를 추가합니다. .babelrc12345678&#123; &quot;plugins&quot;: [ [&quot;transform-runtime&quot;, &#123; &quot;polyfill&quot;: false, &quot;regenerator&quot;: true &#125;] ]&#125; Snapshot Testingvue-server-renderer를 사용해서 Jest snapshot testing을 수해할 수 있습니다. 12$ npm i -D jest-serializer-vue+ jest-serializer-vue@0.2.0 그리고 package.json에 \b설정합니다. package.json12345678910&#123; // ... &quot;jest&quot;: &#123; // ... // serializer for snapshots &quot;snapshotSerializers&quot;: [ &quot;&lt;rootDir&gt;/node_modules/jest-serializer-vue&quot; ] &#125;&#125; Test 예제기본으로 설치된 src/App.vue에서 h1 태그에 msg 값이 잘 설정되는지 확인해보는 테스트를 작성해 보겠습니다. test/app.test.js1234567891011121314151617import &#123;mount&#125; from &#x27;vue-test-utils&#x27;import App from &#x27;../src/App.vue&#x27;describe(&#x27;App.vue&#x27;, () =&gt; &#123; const renderer = require(&#x27;vue-server-renderer&#x27;).createRenderer() it(&#x27;should render correct contents&#x27;, () =&gt; &#123; const wrap = mount(App) expect(wrap.vm.msg).toEqual(&#x27;Welcome to Your Vue.js App&#x27;) expect(wrap.find(&#x27;h1&#x27;).text()).toEqual(wrap.vm.msg) renderer.renderToString(wrap.vm, (err, str) =&gt; &#123; expect(str).toMatchSnapshot() &#125;) &#125;)&#125;) 테스트를 실행해 봅니다. 123456789101112131415161718$ npm test&gt; vue-test-jest@1.0.0 test&gt; jest PASS test&#x2F;app.test.js App.vue ✓ should render correct contents (38ms) › 1 snapshot written.Snapshot Summary › 1 snapshot written in 1 test suite.Test Suites: 1 passed, 1 totalTests: 1 passed, 1 totalSnapshots: 1 added, 1 totalTime: 2.129sRan all test suites. 테스트가 성공적으로 통과하는 것을 확인할 수 있습니다. 그리고 test/__snapshots__/app.test.js.snap 파일이 생성된 것을 볼 수 있습니다.(스냅샷 파일이 없을 경우 자동으로 생성됩니다.) 생성된 파일을 확인해 봅시다. test/__snapshots__/app.test.js.snap123456789101112131415161718192021// Jest Snapshot v1, https://goo.gl/fbAQLPexports[`App.vue should render correct contents 1`] = `&lt;div id=&quot;app&quot;&gt;&lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;h1&gt;Welcome to Your Vue.js App&lt;/h1&gt; &lt;h2&gt;Essential Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://vuejs.org&quot; target=&quot;_blank&quot;&gt;Core Docs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://forum.vuejs.org&quot; target=&quot;_blank&quot;&gt;Forum&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://gitter.im/vuejs/vue&quot; target=&quot;_blank&quot;&gt;Gitter Chat&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://twitter.com/vuejs&quot; target=&quot;_blank&quot;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Ecosystem&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://router.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-router&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://vuex.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vuex&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://vue-loader.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-loader&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/vuejs/awesome-vue&quot; target=&quot;_blank&quot;&gt;awesome-vue&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;`; 앞으로 테스트 할 때 랜더링된 정보가 위 내용과 다를 경우 테스트가 실패하게 됩니다. src/App.vue에서 &lt;img src=&quot;./assets/logo.png&quot;&gt;를 제거한 다음 테스트를 다시 수행해 봅니다. 12345678910111213141516171819202122232425262728293031323334353637383940$ npm t&gt; vue-test-jest@1.0.0 test&gt; jest FAIL test&#x2F;app.test.js App.vue ✕ should render correct contents (47ms) ● App.vue › should render correct contents expect(value).toMatchSnapshot() Received value does not match stored snapshot 1. - Snapshot + Received @@ -1,6 +1,6 @@ - &lt;div id&#x3D;&quot;app&quot;&gt;&lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt; + &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h1&gt;Welcome to Your Vue.js App&lt;&#x2F;h1&gt; &lt;h2&gt;Essential Links&lt;&#x2F;h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;vuejs.org&quot; target&#x3D;&quot;_blank&quot;&gt;Core Docs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;forum.vuejs.org&quot; target&#x3D;&quot;_blank&quot;&gt;Forum&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; at test&#x2F;app.test.js:14:19 › 1 snapshot test failed.Snapshot Summary › 1 snapshot test failed in 1 test suite. Inspect your code changes or run with &#96;npm test -- -u&#96; to update them.Test Suites: 1 failed, 1 totalTests: 1 failed, 1 totalSnapshots: 1 failed, 1 totalTime: 1.261s, estimated 2sRan all test suites.npm ERR! Test failed. See above for more details. 정확하게 이전 스냅샷과의 차이점을 보여주고 있습니다. 만약 화면이 수정되어서 스냅샷이 업데이트 되어야 할 경우 npm test -- -u 명령어로 스냅샷을 업데이트 해주면 됩니다. 만약 vue-server-renderer를 사용할 경우 this.$el.classList 같은 메소드에 대해서 재대로 랜더링이 되지 않는 문제가 있습니다. Code Coverage위에서 언급한데로 Jest는 Code Covarge 기능도 갖추고 있습니다. CLI로 손쉽게 사용할 수 있습니다. 1234567891011121314151617181920$ npm test -- --coverage&gt; vue-test-jest@1.0.0 test&gt; jest &quot;--coverage&quot; PASS test&#x2F;app.test.js App.vue ✓ should render correct contents (39ms)Test Suites: 1 passed, 1 totalTests: 1 passed, 1 totalSnapshots: 1 passed, 1 totalTime: 2.29sRan all test suites.----------|----------|----------|----------|----------|----------------|File | % Stmts | % Branch | % Funcs | % Lines |Uncovered Lines |----------|----------|----------|----------|----------|----------------|All files | 100 | 100 | 100 | 100 | | App.vue | 100 | 100 | 100 | 100 | |----------|----------|----------|----------|----------|----------------| 함수형 컴포넌트는 다음 설정을 추가해야 Code Coverage를 확인할 수 있습니다. 123456789&#123; // ... &quot;jest&quot;: &#123; // ... &quot;moduleNameMapper&quot;: &#123; &quot;^vue$&quot;: &quot;vue/dist/vue.common.js&quot; &#125; &#125;&#125; 결론Jest의 스냅샷 기능으로 어느정도 화면단의 사이드 이팩트를 확인할 수 있는 좋은 수단이 된 것 같습니다. 테스트 러너 별로 예제도 잘 되어 있고 설명도 잘 되어 있으니 마음에 드는 \b걸로 테스트를 적용해 보시기 바랍니다. 참고 https://github.com/vuejs/vue-test-utils-jest-example https://vue-test-utils.vuejs.org/en/guides/testing-SFCs-with-jest.html https://github.com/facebook/jest/tree/master/examples/async https://alexjoverm.github.io/2017/08/21/Write-the-first-Vue-js-Component-Unit-Test-in-Jest/","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"jest","slug":"jest","permalink":"https://gongzza.github.io/tags/jest/"},{"name":"vuejs","slug":"vuejs","permalink":"https://gongzza.github.io/tags/vuejs/"},{"name":"vue-test-utils","slug":"vue-test-utils","permalink":"https://gongzza.github.io/tags/vue-test-utils/"}]},{"title":"TypeScript로 Express 시작하기 - 4","slug":"typescript/typescript-express-starter-4","date":"2017-10-21T09:34:43.000Z","updated":"2021-02-21T13:41:51.330Z","comments":true,"path":"typescript/typescript-express-starter-4/","link":"","permalink":"https://gongzza.github.io/typescript/typescript-express-starter-4/","excerpt":"","text":"이전 포스트 시작하기Knex.js와 Bookshelf 그리고 mock-knex를 이용해서 DB 테스트 환경을 만들어볼 것입니다. Knex.js는 SQL Query Builder로써 Laravel Query Builder에서 파생되었다고 합니다. Bookshelf는 node.js에서 돌아가는 JavaScript ORM으로 Knex.js를 사용합니다. 설치DB는 MySQL을 사용할 것입니다. 12345$ npm i -D knex bookshelf mock-knex mysql2+ bookshelf@0.10.4+ mock-knex@0.3.9+ knex@0.13.0+ mysql2@1.4.2 @types123$ npm i -D @types/knex @types/bookshelf+ @types/bookshelf@0.9.6+ @types/knex@0.0.61 mock-knex.d.tsmock-knex는 .d.ts 파일이 없어서 직접 만들어 주어야 합니다. types/mock-kndex.d.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// https://github.com/jessezhang91/typed-mock-kneximport * as Knex from &#x27;knex&#x27;import &#123; EventEmitter &#125; from &#x27;events&#x27;/** * Attaches mocked client to knex instance * * @param knex initialized knex client */export function mock(knex: Knex): void/** * Detaches mocked client from knex instance * * @param knex initialized knex client */export function unmock(knex: Knex): void/** * Returns query Tracker instance */export function getTracker(): Tracker/** * The tracker enables you to catch and respond to queries that occur during testing, see Test for more examples. */export interface Tracker extends EventEmitter &#123; /** * Enables query tracking mock on mocked knex client */ install(): void /** * Disables query tracking mock on mocked knex client. Also resets &#x27;step&#x27; counter. */ uninstall(): void /** * Add event listener for &#x27;query&#x27; event. It gets esecuted for each query that should end up in database. * Instead of this callback gets executed and its up to you to assert queries and mock database responses. * * @param event * @param callback A function that gets executed on &#x27;query&#x27; event. */ on(event: &#x27;query&#x27;, callback: (query: QueryDetails, step: number) =&gt; void): this&#125;/** * The object containing query details that is being sent to knex database dialect on query execution. * Object properties signature matches with knex toSQL() output with additional method returns(values). */export interface QueryDetails extends Knex.Sql &#123; /** * Function that needs to be called to mock database query result for knex. * * @param error The Error, string or instance of Error, which represents why the result was rejected */ reject(error: Error | string): void /** * Function that needs to be called to mock database query result for knex. * * @param values An array of mock data to be returned by database. For Bookshelf this is mostly array of objects. Knex could return any type of data. * @param options */ response(values: any[], options?: QueryDetailsResponseOption): void&#125;export interface QueryDetailsResponseOption &#123; /** * Is this a stream response, defaults to false */ stream: boolean&#125; 설정knex는 knexfile.js 설정 파일을 필요로 합니다. $ npx knex init 명령어로 간단하게 생성할 수 있습니다. 우선 필요한 정보만 작성합니다. knexfile.js1234567891011121314module.exports = &#123; test: &#123; client: &#x27;mysql2&#x27;, debug: false &#125;, development: &#123; client: &#x27;mysql2&#x27;, connection: &#123; database: process.env.DB_DATABASE, user: process.env.DB_USERNAME, password: process.env.DB_PASSWORD &#125; &#125;&#125; DBDB 라이브러리를 작성합니다. NODE_ENV가 test일 때만 mock-knex를 사용하도록 합니다. src/db.ts1234567891011121314import * as Knex from &#x27;knex&#x27;import * as Bookshelf from &#x27;bookshelf&#x27;import * as MockKnex from &#x27;mock-knex&#x27;const config = require(&#x27;../knexfile&#x27;)const env = process.env.NODE_ENV || &#x27;development&#x27;export const knex = Knex(config[env])if (env === &#x27;test&#x27;) &#123; MockKnex.mock(knex)&#125;export default Bookshelf(knex) Echo간단하게 msg를 저장하는 Echo 서비스를 작성해 봅니다. TableEcho 테이블을 작성합니다. 12$ npx knex migrate:make echoCreated Migration: echo.js migrations/echo.js1234567891011exports.up = function (knex) &#123; return knex.schema .createTable(&#x27;echo&#x27;, table =&gt; &#123; table.increments(&#x27;id&#x27;).primary() table.string(&#x27;msg&#x27;) &#125;)&#125;exports.down = function (knex) &#123; return knex.schema .dropTable(&#x27;echo&#x27;)&#125; Migration테스트에서는 mock-knex를 사용하기 때문에 실제 DB Table이 필요하지 않습니다. 하지만, 서비스를 하기 위해서는 DB Table을 생성해서 사용해야 할 것입니다. 다음 명령으로 DB Table을 관리할 수 있습니다. 12345$ knex migrate:latest --env production# or$ NODE_ENV=production knex migrate:latest Modelsrc/models/Echo.ts12345import db from &#x27;../db&#x27;export class Echo extends db.Model&lt;Echo&gt; &#123; get tableName() &#123; return &#x27;echo&#x27; &#125;&#125; index.ts 를 추가하면은 한번에 여러 모델을 불러올 수 있어서 편합니다. src/models/index.ts1export * from &#x27;./Echo&#x27; Controllersrc/controllers/echo.ts1234567891011import &#123; Request, Response &#125; from &#x27;express&#x27;import &#123; Echo &#125; from &#x27;../models&#x27;export async function echo(req: Request, res: Response) &#123; const vo = new Echo(&#123; msg: req.query.msg &#125;) const result = await vo.save() res.json(result)&#125; Testtest/echo.test.ts123456789101112131415161718192021222324252627import &#123; expect &#125; from &#x27;chai&#x27;import * as request from &#x27;supertest&#x27;import app from &#x27;../src/app&#x27;import * as MockKnex from &#x27;mock-knex&#x27;describe(&#x27;echo.test&#x27;, () =&gt; &#123; const tracker = MockKnex.getTracker() beforeEach(() =&gt; &#123; tracker.install() &#125;) afterEach(() =&gt; &#123; tracker.uninstall() &#125;) it(&#x27;GET /echo?msg&#x27;, async () =&gt; &#123; tracker.on(&#x27;query&#x27;, query =&gt; &#123; expect(query.method).to.equal(&#x27;insert&#x27;) query.response([]) &#125;) const msg = &#x27;message&#x27; const res = await request(app).get(`/echo?msg=$&#123;msg&#125;`).expect(200) expect(res.body.msg).to.equal(msg) &#125;)&#125;) NODE_ENV를 test로 설정 후 테스트를 수행합니다. (Windows일 경우 [cross-env]를 사용하면 유용합니다.) 123456789101112$ NODE_ENV=test npm test&gt; typescript-express-starter@1.0.0 test typescript-express-starter&gt; mocha --require ts-node/register &#x27;test/**/*.test.ts&#x27; app.test ✓ GET / (39ms) ✓ GET /not_found echo.test ✓ GET /echo?msg 3 passing (72ms) 테스트가 성공적으로 수행되는 것을 볼 수 있습니다. 참고 Knex, Bookshelf, mocks and Unit Tests","categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://gongzza.github.io/categories/Typescript/"}],"tags":[{"name":"express","slug":"express","permalink":"https://gongzza.github.io/tags/express/"},{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"node.js","slug":"node-js","permalink":"https://gongzza.github.io/tags/node-js/"},{"name":"knex.js","slug":"knex-js","permalink":"https://gongzza.github.io/tags/knex-js/"},{"name":"bookshelf.js","slug":"bookshelf-js","permalink":"https://gongzza.github.io/tags/bookshelf-js/"},{"name":"mock-knex","slug":"mock-knex","permalink":"https://gongzza.github.io/tags/mock-knex/"}]},{"title":"TypeScript로 Express 시작하기 - 3","slug":"typescript/typescript-express-starter-3","date":"2017-10-06T04:17:26.000Z","updated":"2021-02-21T13:41:51.329Z","comments":true,"path":"typescript/typescript-express-starter-3/","link":"","permalink":"https://gongzza.github.io/typescript/typescript-express-starter-3/","excerpt":"","text":"이전 포스트 시작하기Mocha, Chai, SuperTest 그리고 ts-node를 이용해서 테스트 환경을 구축해 볼 것입니다. ts-node는 mocha에서 ts확장자로 테스트를 수행하기 위해서 설치합니다. 설치123456789101112# install depenecies$ npm i -D mocha chai supertest ts-node+ ts-node@3.3.0+ chai@4.1.2+ mocha@4.0.1+ supertest@3.0.0# install types$ npm i -D @types/mocha @types/chai @types/supertest+ @types/chai@4.0.4+ @types/supertest@2.0.3+ @types/mocha@2.2.43 리팩토링이전에 작성했던 index.ts에서 서버 실행 부분(app.listen)을 따로 분리할 것입니다. 그리고 404 &amp; 에러 해들러를 추가합니다. src/app.ts123456789101112131415161718192021222324252627282930import * as express from &#x27;express&#x27;const app = express()app.get(&#x27;/&#x27;, (req: express.Request, res: express.Response) =&gt; &#123; res.send(&#x27;Hello World!&#x27;)&#125;)interface Err extends Error &#123; status: number data?: any&#125;// catch 404 and forward to error handlerapp.use(function (req: express.Request, res: express.Response, next: express.NextFunction) &#123; let err = new Error(&#x27;Not Found&#x27;) as Err err.status = 404 next(err)&#125;)// error handleapp.use(function (err: Err, req: express.Request, res: express.Response, next: express.NextFunction) &#123; // render the error page res.status(err.status || 500) res.json(&#123; message: err.message, data: err.data &#125;)&#125;)export default app src/dist/server.ts12345import app from &#x27;./src/app&#x27;app.listen(3000, () =&gt; &#123; console.log(&#x27;Example app listening on port 3000!&#x27;)&#125;) Package Scriptstest 스크립트를 추가합니다. start 스크립트는 실행할 스크립트를 지정해줍니다. package.json1234567&#123; &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run lint &amp;&amp; tsc &amp;&amp; node dist/server&quot;, &quot;test&quot;: &quot;mocha --require ts-node/register &#x27;test/**/*.test.ts&#x27;&quot;, &quot;lint&quot;: &quot;tslint -p .&quot; &#125;&#125; mocha의 --compilers 옵션이 더 이상 사용되지 않는다고 합니다. 자세한 사항은 여기를 봐주세요. 테스트성공 케이스와 404에 대한 테스트 케이스를 작성합니다. test/app.test.ts1234567891011121314151617import &#123; expect &#125; from &#x27;chai&#x27;import * as request from &#x27;supertest&#x27;import app from &#x27;../src/app&#x27;describe(&#x27;app.test&#x27;, () =&gt; &#123; const req = request(app) it(&#x27;GET /&#x27;, async () =&gt; &#123; const res = await req.get(&#x27;/&#x27;).expect(200) expect(res.text).to.equal(&#x27;Hello World!&#x27;) &#125;) it(&#x27;GET /not_found&#x27;, async () =&gt; &#123; const res = await req.get(&#x27;/not_found&#x27;).expect(404) expect(res.body.message).to.equal(&#x27;Not Found&#x27;) &#125;)&#125;) 테스트를 실행해 보면 모두 성공하는 것을 볼 수 있습니다. 12345678$ npm test&gt; typescript-express-starter@1.0.0 test typescript-express-starter&gt; mocha --require ts-node/register &#x27;test/**/*.test.ts&#x27; app.test ✓ GET / ✓ GET /not_found Echo간단하게 에코 컨트롤러를 추가 후 테스트 케이스를 작성해 보겠습니다. Controllersrc/controllers/echo.ts12345import &#123; Request, Response &#125; from &#x27;express&#x27;export function echo(req: Request, res: Response) &#123; res.json(req.query)&#125; Routersrc/routes/echo.ts12345678import &#123; Router &#125; from &#x27;express&#x27;const router = Router()import * as echo from &#x27;../controllers/echo&#x27;router.get(&#x27;/echo&#x27;, echo.echo)module.exports = router src/app.ts1app.use(&#x27;/&#x27;, require(&#x27;./routes/echo&#x27;)) TestCasetest/echo.test.ts12345678910111213import &#123; expect &#125; from &#x27;chai&#x27;import * as request from &#x27;supertest&#x27;import app from &#x27;../../src/app&#x27;describe(&#x27;echo.test&#x27;, () =&gt; &#123; const req = request(app) it(&#x27;GET /echo?msg&#x27;, async () =&gt; &#123; const msg = &#x27;message&#x27; const res = await req.get(`/echo?msg=$&#123;msg&#125;`).expect(200) expect(res.body.msg).to.equal(msg) &#125;)&#125;) 다음은Knex.js와 Bookshelf 그리고 mock-knex를 이용해서 DB 테스트 환경을 만들어볼 것입니다. 다음 이동","categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://gongzza.github.io/categories/Typescript/"}],"tags":[{"name":"express","slug":"express","permalink":"https://gongzza.github.io/tags/express/"},{"name":"mocha","slug":"mocha","permalink":"https://gongzza.github.io/tags/mocha/"},{"name":"chai","slug":"chai","permalink":"https://gongzza.github.io/tags/chai/"},{"name":"supertest","slug":"supertest","permalink":"https://gongzza.github.io/tags/supertest/"},{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"node.js","slug":"node-js","permalink":"https://gongzza.github.io/tags/node-js/"},{"name":"ts-node","slug":"ts-node","permalink":"https://gongzza.github.io/tags/ts-node/"}]},{"title":"TypeScript로 Express 시작하기 - 2","slug":"typescript/typescript-express-starter-2","date":"2017-09-24T04:09:19.000Z","updated":"2021-02-21T13:41:51.329Z","comments":true,"path":"typescript/typescript-express-starter-2/","link":"","permalink":"https://gongzza.github.io/typescript/typescript-express-starter-2/","excerpt":"","text":"이전 포스트 시작하기TSLint를 적용할 것입니다. 린트는 코딩의 어머니와 같은 존재로써 말을 잘 듣는 편이 정신건강에 이롭습니다. 설치저는 JavaScript Standard Style을 따릅니다. 그래서 tslint-config-standard를 같이 설치합니다. 123$ npm i -D tslint tslint-config-standard+ tslint@5.7.0+ tslint-config-standard@6.0.1 설정위에서 설치한 tslint-config-standard를 사용하도록 설정합니다. tslint.json1234&#123; &quot;extends&quot;: &quot;tslint-config-standard&quot;, &quot;rules&quot;: &#123;&#125;&#125; 그리고 strict-type-predicates가 설정되어 있는데요. 이 Rule을 사용하려면 compilerOptions에서 strictNullChecks를 사용하도록 설정해야 합니다. tsconfig.json12345&#123; &quot;compilerOptions&quot;: &#123; &quot;strictNullChecks&quot;: true &#125;&#125; Rulesstandard 에서도 사용하고 싶지 않은 설정들이 있는데요. 이럴 경우 rules에서 다시 설정하면 됩니다. 저는 함수를 정의할 때 함수명과 파라메터 괄호를 붙여서 선언하는 편인데요. standard에서는 허용하지 않습니다. 친절하게 어떤 Rule인지 알려주네요. 다음과 같이 해당 Rule 설정을 바꿀 수 있습니다. tslint.json123456&#123; &quot;extends&quot;: &quot;tslint-config-standard&quot;, &quot;rules&quot;: &#123; &quot;space-before-function-paren&quot;: false &#125;&#125; Rule들은 TSLint - Rules에서 확인하실 수 있습니다. 실행Package ScriptsLint 실행 스크립트를 추가합니다. package.json123456&#123; &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run lint &amp;&amp; tsc &amp;&amp; node dist&quot;, &quot;lint&quot;: &quot;tslint -p .&quot;, &#125;&#125; Linting위에서 추가한 스크립트를 실행합니다. 12345678$ npm run lint&gt; typescript-express-starter@1.0.0 lint typescript-express-starter&gt; tslint -p .ERROR: typescript-express-starter/src/index.ts[10, 4]: file should end with a newlineERROR: typescript-express-starter/src/index.ts[2, 22]: Unnecessary semicolon... 2가지 에러가 발생하는데요. JS Standard Style에서는 세미콜론을 사용하지 않습니다. 그리고 파일 마지막에 빈 라인이 있어야 합니다. src/index.ts에서 세미콜론을 모두 제거 하고 파일 마지막에 빈 라인을 추가 후 다시 npm run lint를 실행하면 에러가 없는 것을 확인 할 수 있습니다. AutoFixOnSaveVS Code를 사용하실 경우 VSCode - TSLint를 설치하셔서 사용하시면 편리합니다. 사용자 설정(settings.json) 또는 .vscode/settings.json 파일에 다음 옵션을 추가합니다. .vscode/settings.json123&#123; &quot;tslint.autoFixOnSave&quot;: true&#125; 이제 편집기에서 코딩 후 저장할 때 자동으로 고칠 수 있는 부분은 고쳐져서 저장이 됩니다. 다음은Mocha, Chai, SuperTest 그리고 ts-node를 이용해서 테스트 환경을 구축해 볼 것입니다. 다음 이동 참고 TSLint TSLint - Rules","categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://gongzza.github.io/categories/Typescript/"}],"tags":[{"name":"express","slug":"express","permalink":"https://gongzza.github.io/tags/express/"},{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"node.js","slug":"node-js","permalink":"https://gongzza.github.io/tags/node-js/"},{"name":"tslint","slug":"tslint","permalink":"https://gongzza.github.io/tags/tslint/"}]},{"title":"TypeScript로 Express 시작하기 - 1","slug":"typescript/typescript-express-starter-1","date":"2017-09-24T04:09:08.000Z","updated":"2021-02-21T13:41:51.328Z","comments":true,"path":"typescript/typescript-express-starter-1/","link":"","permalink":"https://gongzza.github.io/typescript/typescript-express-starter-1/","excerpt":"","text":"시작하기Express를 TypeScript로 개발환경을 구축해 보려고합니다. TypeScript-Node-Starter를 참고하였습니다. 여기서는 간단하게 프로젝트 생성 후 Hello World를 띄우도록 하겠습니다. Initial Project작업 디렉토리와 package.json을 생성합니다. 12345# create project directory$ mkdir typescript-express-starter &amp;&amp; cd $_# make package.json$ npm init -y 설치가장 기반이 되는 모듈을 설치합니다. 1234567# install save dependencies$ npm i -S express+ express@4.15.5# install save devDependencies$ npm i -D typescript+ typescript@2.5.2 @types모듈을 설치할 때 항상 TypeScript를 지원하거나 @types 에서 모듈이 있는지 확인하는 것이 좋습니다. 만약 없다면, 직접 .d.ts 파일을 만들어야 합니다. 우선은 지금 필요한 @types를 설치합니다. 1234# install @types$ npm i -D @types/node @types/express+ @types/express@4.0.37+ @types/node@8.0.30 빌드 설정TypeScriptTypeScript 컴파일 옵션을 설정합니다. 다음 명령으로 tsconfig.json 파일을 생성할 수 있습니다. 12$ npx tsc -initmessage TS6071: Successfully created a tsconfig.json file. 생성된 tsconfig.json 파일을 열어보면, 모든 옵션들과 설명을 볼 수 있습니다. 우선은 필요한 옵션만 지정하도록 하겠습니다. tsconfig.json1234567891011&#123; &quot;compilerOptions&quot;: &#123; &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es6&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;outDir&quot;: &quot;dist&quot; &#125;, &quot;include&quot;: [ &quot;src/**/*&quot; ]&#125; Package ScriptsTypeScript 빌드 후 Node.js로 실행하는 스크립트를 추가합니다. package.json12345&#123; &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;tsc &amp;&amp; node dist&quot; &#125;&#125; Hello WorldExpress 시작하기 - Hello World 예제를 추가하여 실행해 보도록 하겠습니다. src/index.ts12345678910var express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;, function (req, res) &#123; res.send(&#x27;Hello World!&#x27;);&#125;);app.listen(3000, function () &#123; console.log(&#x27;Example app listening on port 3000!&#x27;);&#125;); 실행서버를 실행합니다. 123456$ npm start&gt; typescript-express-starter@1.0.0 start typescript-express-starter&gt; tsc &amp;&amp; node distExample app listening on port 3000! 브라우저를 열어서 localhost:3000로 접속하면, Hello World!를 볼 수 있습니다. 리팩토링위에서 작성한 src/index.ts는 Vanilla JS로 작성 되어있습니다. 그래서 TypeScript로 다시 작성해 보겠습니다. src/index.ts12345678910import * as express from &#x27;express&#x27; // 1const app = express();app.get(&#x27;/&#x27;, (req: express.Request, res: express.Response) =&gt; &#123; // 2 res.send(&#x27;Hello World!&#x27;);&#125;);app.listen(3000, () =&gt; &#123; console.log(&#x27;Example app listening on port 3000!&#x27;);&#125;); 1 require를 import로 바꾸었습니다. require로 가져온 모듈은 타입이 any라서 TypeScript의 기능을 재대로 사용할 수 없습니다. 1var require: NodeRequire(id: string) =&gt; any 앞으로는 import를 주로 사용하도록 합시다. 2 Request와 Response 타입을 지정함으로 써 자동완성(Code Intelligence) 기능도 사용할 수 있게 되었습니다. 다음은TSLint를 적용할 것입니다. 다음 이동 참고 Express TypeScript TypeScript-Node-Starter","categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://gongzza.github.io/categories/Typescript/"}],"tags":[{"name":"express","slug":"express","permalink":"https://gongzza.github.io/tags/express/"},{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"node.js","slug":"node-js","permalink":"https://gongzza.github.io/tags/node-js/"}]},{"title":"Typescript로 Vue.js 시작하기 - 7","slug":"vuejs/getting-started-vuejs-with-typescript-7","date":"2017-08-31T04:09:56.000Z","updated":"2021-02-21T13:41:51.337Z","comments":true,"path":"vuejs/getting-started-vuejs-with-typescript-7/","link":"","permalink":"https://gongzza.github.io/vuejs/getting-started-vuejs-with-typescript-7/","excerpt":"","text":"이전 포스트 faker.js와 utils.ts를 추가하여 테스트 케이스를 보강하도록 하겠습니다. 이전에 작성했던 Webpack2로 Vue.js 테스트 환경 구축하기 2와 3에서 추가했던 테스트 방법을 참고하여 TypeScript로 옮겨 올 것입니다. utils.tsutils.ts에는 반복되는 작업을 편리하게 해주는 기능들을 추가합니다. newVM먼저, 컴포넌트를 생성해주는 함수를 작성해 보겠습니다. test/unit/utils.ts1234567import Vue, &#123; ComponentOptions &#125; from &#x27;vue&#x27;const el: Element = document.createElement(&#x27;div&#x27;)export function newVM&lt;T extends Vue&gt;(Comp: new (args: ComponentOptions&lt;Vue&gt;) =&gt; T, propsData?: object): T &#123; return new Comp(&#123;el, propsData&#125;)&#125; newVM은 컴포넌트와 propsData를 파라메터로 생성된 컴포넌트를 리턴합니다. mockup이번에는 faker.js를 이용하여 mock data를 생성해주는 기능을 추가합니다. 설치기본적으로 TypeScript를 지원하고 있지 않아서 @types/faker도 같이 설치해야 합니다. 1$ npm install --save-dev faker @types/faker test/unit/utils.ts123456789101112131415161718192021222324252627282930313233343536373839404142import faker from &#x27;faker&#x27;export type MockData = &#123; [key: string]: any&#125;export function mock&lt;T&gt;(obj: MockData): T &#123; let mockup = &#123;&#125; as MockData for (let key of Object.keys(obj)) &#123; let val: string = obj[key] if (typeof val === &#x27;string&#x27; &amp;&amp; val.length !== 0) &#123; mockup[key] = mockdata(val) &#125; else &#123; mockup[key] = val &#125; &#125; return mockup as T&#125;export function mocks&lt;T&gt;(obj: MockData, cnt: number = 3): Array&lt;T&gt; &#123; let mockups = Array&lt;T&gt;() while (cnt-- &gt; 0) &#123; mockups.push(mock(obj)) &#125; return mockups&#125;export function mockdata(val: string): any &#123; let data = faker.fake(val) if (/^num:/i.test(val)) &#123; return parseInt(data.substring(&#x27;num:&#x27;.length)) &#125; else if (/^date:/i.test(val)) &#123; return new Date(data.substring(&#x27;date:&#x27;.length)) &#125; return data&#125; generic을 사용해서 mock 데이터를 만들어면, TypeScript의 장점을 활용할 수 있다. parseInt에서 redix를 설정하고 싶지 않을 경우 tslint.json에서 rules:&#123; radix: false &#125; 를 추가하면 됩니다. nextTickprocess.nextTick()으로 콜백을 만드는 보다는 async/await을 사용하여 보다 코드를 읽기 편하게 만드는 방법이 좋을 것 같습니다. async/await을 사용할 수 있도록 Promise를 리턴하는 nextTick()함수를 추가합니다. test/unit/utils.ts123export function nextTick(): Promise&lt;any&gt; &#123; return new Promise(resolve =&gt; process.nextTick(resolve))&#125; createMockAdapter매번 axios와 axios-mock-adapter를 추가하기 보다는 팩토리 메소드를 제공해 주는 것이 편할 것 같습니다. test/unit/utils.ts123456import axios from &#x27;axios&#x27;import MockAdapter from &#x27;axios-mock-adapter&#x27;export function createMockAdapter(): MockAdapter &#123; return new MockAdapter(axios)&#125; modelsTodoList에서 interface Todo를 가져오려면은 다음과 같이 선언해야 합니다. 1import &#123; Todo &#125; from &#x27;@/components/TodoList&#x27; 하지만 이렇게 불러와서 사용할 경우 webpack에서 컴파일 에러가 발생합니다. 이유는 webpack에서는 .vue로 불러오기 때문에 Todo를 찾을 수 없어서 에러가 발생합니다. (.vue에서는 TodoList만 불러와서 내보내기 때문입니다.) 그리고 Todo는 모델로써 다른 곳에서도 사용될 수 있기 때문에 따로 분리해서 불러오는 방법이 좋을 것 같습니다. 다음과 같이 2개의 파일을 추가합니다. 먼저, TodoList에 있던 interface Todo를 파일로 분리합니다. src/models/Todo.ts123456export interface Todo &#123; id: number userId: number title: string completed: boolean&#125; 그리고 간편하게 불러오기 위해서 src/models/index.ts를 추가합니다. src/models/index.ts1export * from &#x27;./Todo&#x27; Refactor위에서 추가한 기능들을 사용하여 테스트 케이스를 작성합니다. 여기서 PropsData를 Todo 처럼 model로 따로 뺴지 않은 이유는 다른 곳에서 사용할 일이 없다고 생각되었기 때문입니다. 물론 model처럼 따로 props를 만들어서 사용해도 좋을 것 같습니다. 하지만, 관리 포인트가 늘어나면 번거로움만 커질 것 같습니다. test/unit/comonents/Hello.spec.ts1234567891011121314151617181920212223242526272829303132333435import &#123; expect &#125; from &#x27;chai&#x27;import Hello from &#x27;@/components/Hello&#x27;import &#123; newVM, mock &#125; from &#x27;../utils&#x27;type PropsData = &#123; name: string initialEnthusiasm: number&#125;describe(&#x27;Hello.vue&#x27;, () =&gt; &#123; it(&#x27;#propsData&#x27;, async () =&gt; &#123; const propsData = mock&lt;PropsData&gt;(&#123; name: &#x27;&#123;&#123;name.lastName&#125;&#125;&#x27;, initialEnthusiasm: 3 &#125;) const vm = newVM(Hello, propsData) expect(vm.name).to.equals(propsData.name) expect(vm.enthusiasm).to.equals(propsData.initialEnthusiasm) expect(vm.exclamationMarks).to.have.lengthOf(propsData.initialEnthusiasm) const $greeting = vm.$el.querySelector(&#x27;.greeting&#x27;) as HTMLElement expect($greeting.textContent, `Hello $&#123;propsData.name&#125;!!!`) vm.increment() expect(vm.exclamationMarks).to.have.lengthOf(propsData.initialEnthusiasm + 1) await vm.$nextTick() // update expect($greeting.textContent, `Hello $&#123;propsData.name&#125;!!!!`) &#125;)&#125;) test/unit/components/TodoList.spec.ts123456789101112131415161718192021222324252627282930313233import &#123; expect &#125; from &#x27;chai&#x27;import TodoList from &#x27;@/components/TodoList&#x27;import &#123; Todo &#125; from &#x27;@/models&#x27;import &#123; newVM, mocks, nextTick, createMockAdapter &#125; from &#x27;../utils&#x27;describe(&#x27;TodoList.vue&#x27;, () =&gt; &#123; const mock = createMockAdapter() beforeEach(() =&gt; &#123; mock.onGet(&#x27;/todos&#x27;) .reply(200, mocks&lt;Todo&gt;(&#123; id: &#x27;num:&#123;&#123;random.number&#125;&#125;&#x27;, userId: &#x27;num:&#123;&#123;random.number&#125;&#125;&#x27;, title: &#x27;&#123;&#123;lorem.sentence&#125;&#125;&#x27;, completed: false &#125;, 3)) &#125;) afterEach(() =&gt; &#123; mock.restore() &#125;) it(&#x27;#asyncData&#x27;, async () =&gt; &#123; const vm = newVM(TodoList) expect(vm.todos).to.have.lengthOf(0) await nextTick() // axios.get expect(vm.todos).to.have.lengthOf(3) &#125;)&#125;) 마치며이 정도면 기본적인 개발 셋팅은 완료 됫다고 생각합니다. TypeScript로 개발하는 것은 좋은 것 같습니다. 지정한 타입대로 코드 이테그레이션?을 보여줘서 오타를 줄여줍니다. 오타를 줄여주는 것만으로도 개발속도는 빠르게 향상될 것입니다. 유지보수도 데이터의 프로퍼티를 추측이 아닌 타입으로 바로 확인해서 보다 안전하게 개발이 가능할 것입니다. 아직 Vue와 조화롭지 못한? 부분이 있지만, 그래도 TypeScript의 장점이 더 크다고 생각합니다.","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"}]},{"title":"Typescript로 Vue.js 시작하기 - 6","slug":"vuejs/getting-started-vuejs-with-typescript-6","date":"2017-08-25T15:17:00.000Z","updated":"2021-02-21T13:41:51.336Z","comments":true,"path":"vuejs/getting-started-vuejs-with-typescript-6/","link":"","permalink":"https://gongzza.github.io/vuejs/getting-started-vuejs-with-typescript-6/","excerpt":"","text":"이전 포스트 axios와 axios-mock-adapter를 이용해서 개발 및 테스트 케이스를 작성 해볼 것입니다. 설치1$ npm i -D axios axios-mock-adapter axios baseURLaxios는 baseURL를 지정할 수 있습니다. baseURL은 요청 URL 앞에 prefix처럼 붙어서 요청을 하게 됩니다. API는 Fake Online REST API를 제공해주는 https://jsonplaceholder.typicode.com 를 사용하였습니다. src/index.ts1234import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;https://jsonplaceholder.typicode.com&#x27;... 컴포넌트 추가TodoList 컴포넌트를 추가할 것입니다. 이름에서도 알 수 있듯이 /todos를 호출 후 결과값을 리스트로 보여주기만 하는 컴포넌트입니다. TypeScriptsrc/components/TodoList/index.ts1234567891011121314151617181920212223242526import Vue from &#x27;vue&#x27;import &#123; Component &#125; from &#x27;vue-property-decorator&#x27;import axios from &#x27;axios&#x27;export interface Todo &#123; id: number userId: number title: string completed: boolean&#125;@Componentexport default class TodoList extends Vue &#123; todos: Array&lt;Todo&gt; = [] created(): void &#123; this.asyncData() &#125; asyncData(): void &#123; axios.get(&#x27;/todos&#x27;) .then((&#123;data: todos&#125;) =&gt; &#123; this.todos = todos as Array&lt;Todo&gt; &#125;) &#125;&#125; interface Todo를 선언한 이유는 TypeScript의 장점을 잘 살리기 위해서 입니다. 지금은 컴포넌트 내에서 선언하였지만, 모델이 많아질 경우 디렉토리를 따로 만들어서 import &#123; Todo &#125; from &#39;@/models&#39; 처럼 불러오면 좋을 것 같습니다. Template화면은 심플하게 ul li로 리스트를 나열하였습니다. src/components/TodoList/index.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h1&gt;Todo List&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;todo of todos&quot; :key=&quot;todo.id&quot;&gt; &lt;label class=&quot;clickable&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.completed&quot;&gt; &lt;p class=&quot;todo-title&quot;&gt; &#123;&#123;todo.title&#125;&#125; &lt;/p&gt; &lt;/label&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import TodoList from &#x27;./index.ts&#x27;export default TodoList&lt;/script&gt;&lt;style scoped&gt;ul li &#123; list-style-type: none; &#125;.clickable &#123; cursor: pointer; &#125;.todo-title &#123; display: inline; &#125;input:checked ~ .todo-title &#123; text-decoration: line-through; &#125;&lt;/style&gt; App메인 화면에 위에서 만든 TodoList 컴포넌트를 추가합니다. src/index.ts12345678910111213import TodoList from &#x27;@/components/TodoList&#x27;const app = new Vue(&#123; el: &#x27;#app&#x27;, template: ` &lt;div&gt; &lt;todo-list /&gt; &lt;/div&gt; `, components: &#123; TodoList &#125;&#125;) 개발 서버를 실행 후 화면을 확인해보면, 다음과 같이 리스트를 볼 수 있습니다. Test 추가위에 작성한 TodoList 컴포넌트의 테스트 케이스를 작성할 것입니다. axios로 /todos를 요청하는데요. 이 부분을 axios-mock-adapter로 응답을 만들어서 내려 줄 것입니다. test/unit/components/TodoList.spec.ts1234567891011121314151617181920212223242526272829303132333435363738import &#123; expect &#125; from &#x27;chai&#x27;import TodoList from &#x27;@/components/TodoList&#x27;import axios from &#x27;axios&#x27;import MockAdapter from &#x27;axios-mock-adapter&#x27;describe(&#x27;TodoList.vue&#x27;, () =&gt; &#123; const mock = new MockAdapter(axios) beforeEach(() =&gt; &#123; mock.onGet(&#x27;/todos&#x27;) .reply(200, [ &#123; id: 1, userId: 1, title: &#x27;todo title&#x27;, completed: false &#125; ]) &#125;) afterEach(() =&gt; &#123; mock.restore() &#125;) it(&#x27;#asyncData&#x27;, done =&gt; &#123; const vm = new TodoList(&#123; el: document.createElement(&#x27;div&#x27;) &#125;) expect(vm.todos).to.have.lengthOf(0) process.nextTick(() =&gt; &#123; expect(vm.todos).to.have.lengthOf(1) done() &#125;) &#125;)&#125;) 테스트를 돌려보면은 성공하는 것을 볼 수 있습니다. 하지만, axios-mockadapter가 typescript를 지원하고 있지 않아서 컴파일 에러도 같이 보입니다. issue로 남겨있으며, @andrepinguim이 작업하던 소스를 참고하여 다음과 같이 추가하여 컴파일 에러를 제거할 수 있습니다. test/unit/@types/axios-mock-adapter/index.d.ts1234567891011121314151617181920212223242526272829303132333435declare module &quot;axios-mock-adapter&quot; &#123; import &#123; AxiosStatic, AxiosRequestConfig, AxiosPromise, AxiosAdapter &#125; from &#x27;axios&#x27;; export class MockAdapter &#123; constructor(axios?: AxiosStatic, config?: MockAdapter.IMockConfig); restore(): void; reset(): void; passThrough(): void; adapter(): AxiosAdapter; reply(func: (config: AxiosRequestConfig) =&gt; MockAdapter.MockResponse | AxiosPromise): MockAdapter; reply(status: number, data?: any): MockAdapter; replyOnce(func: (config: AxiosRequestConfig) =&gt; MockAdapter.MockResponse | AxiosPromise): MockAdapter; replyOnce(status: number, data?: any): MockAdapter; onGet: MockAdapter.defaultVerb; onPost: MockAdapter.defaultVerb; onPut: MockAdapter.defaultVerb; onHead: MockAdapter.defaultVerb; onDelete: MockAdapter.defaultVerb; onPatch: MockAdapter.defaultVerb; &#125; export namespace MockAdapter &#123; export type MockResponse = [number, any, any]; export interface IMockConfig &#123; delayResponse: number &#125; interface defaultVerb &#123; (path?: string | RegExp, body?: any): MockAdapter &#125; &#125; export default MockAdapter;&#125; 다시 테스트를 수행해 보면, 컴파일이 성공적으로 된 것을 확인할 수 있습니다. 다음은?위에서 작성한 테스트 케이스를 faker.js와 utils.ts를 추가하여 보강하도록 하겠습니다. 다음 이동","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"}]},{"title":"Typescript로 Vue.js 시작하기 - 5","slug":"vuejs/getting-started-vuejs-with-typescript-5","date":"2017-08-21T11:50:12.000Z","updated":"2021-02-21T13:41:51.332Z","comments":true,"path":"vuejs/getting-started-vuejs-with-typescript-5/","link":"","permalink":"https://gongzza.github.io/vuejs/getting-started-vuejs-with-typescript-5/","excerpt":"","text":"이전 포스트 TSLint를 적용할 것입니다. 저는 JavaScript Standard Style를 따릅니다. 설치1$ npm i -D tslint tslint-loader tslint-config-standard 그리고 VS Code에서 TSLint를 검색해서 설치합니다. TSLint 설정tslint.json를 추가합니다. tslint.json12345&#123; &quot;defaultSeverity&quot;: &quot;error&quot;, &quot;extends&quot;: &quot;tslint-config-standard&quot;, &quot;rules&quot;: &#123;&#125;&#125; VS Code에서 Hello.ts를 열어보면, import Vue from &quot;vue&quot;에서 [tslint] &quot; should be &#39;(quotemark) 에러를 확인하실 수 있습니다. 이 에러는 &quot;를 &#39;로 변경하면 사라집니다. 이렇게 코드 컨벤션을 지킬 수 있게 도와주기 때문에 꼭 설치해서 사용하는 것이 좋을 것 같습니다. Webpack 설정Webpack에 tslint-loader를 설정해 줘서 npm run dev 또는 npm test에서 TSLint를 해줘서 놓치는 부분이 없도록 합니다. webpack.config.js123456789101112module.exports = &#123; module: &#123; rules: [ &#123; enforce: &#x27;pre&#x27;, test: /\\.tsx?$/, loader: &#x27;tslint-loader&#x27;, exclude: /node_modules/ &#125; ] &#125;&#125; 개발 서버를 실행해 보면은 다음과 같은 에러를 볼 수 있습니다. 1234$ npm run dev...WARNING in .&#x2F;src&#x2F;components&#x2F;Hello.ts[18, 23]: Missing whitespace before function parens VS Code에서 해당 파일의 라인에 가서 마우스를 가져다 대면은 어떤 룰을 위반했는지 알 수 있습니다. 또는 왼쪽 하단에 X를 클릭하면 모든 에러를 한번에 볼 수 있고 리스트 중 하나를 클릭하면 바로 포커스를 이동시켜줍니다. 저는 룰을 좀 수정해서 사용하는데요. 그 중 하나가 space-before-function-paren 입니다. 위에서 발생한 에러를 제거할 수 있습니다. tslint.json에서 해당 룰을 수정하면 됩니다. tslint.json123456&#123; ..., &quot;rules&quot;: &#123; &quot;space-before-function-paren&quot;: false &#125;&#125; 이렇게 룰은 꼭 정해진 것이 아닌 자기 또는 팀에 맞춰서 수정해서 사용하면 됩니다. 미해결Hello.vue에서 import Hello from &#39;./Hello.ts&#39;로 했는데요. VS Code에서 An import path cannot end with a &#39;.ts&#39; extension. ... 에러가 나오는데요.이 부분에 대해서는 어떻게 없에야 할지 고민입니다… 혹시 아시는 분 계시면 꼭 알려주시면 감사하겠습니다. 다음은?axios와 axios-mock-adapter를 이용해서 개발 및 테스트 케이스를 작성해 보도록 하겠습니다. 다음 이동","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"}]},{"title":"Typescript로 Vue.js 시작하기 - 4","slug":"vuejs/getting-started-vuejs-with-typescript-4","date":"2017-08-19T18:34:42.000Z","updated":"2021-02-21T13:41:51.332Z","comments":true,"path":"vuejs/getting-started-vuejs-with-typescript-4/","link":"","permalink":"https://gongzza.github.io/vuejs/getting-started-vuejs-with-typescript-4/","excerpt":"","text":"이전 포스트 VS Code에서 테스트를 작성할 때 유용한 방법을 알아보도록 하겠습니다. 처음에는 Single File Component인 .vue 파일을 사용하려고 했습니다. 하지만, 이전 포스팅에서 추가했던 Hello.spec.ts를 직접 코딩해보시면 이상한 점을 느끼셨을 것입니다. 바로 자동완성(코드 인텔리센스) 기능이 동작을 안한다는 것입니다. 이유는 VS Code가 @/components/Hello.vue를 찾을 수 없기 때문입니다. 이럴 경우 TypeScript의 장점을 재대로 살릴 수 없게됩니다. Vue와 TypeScript 분리Vue의 SFC(Single File Component)를 포기하면서, TypeScript의 장점을 살리는 방법으로 진행할 생각입니다. 먼저, Hello.vue에서 TypeScript를 분리해서 Hello.ts를 생성합니다. 그리고 다음 코드를 넣습니다. src/components/Hello.vue1234&lt;script lang=&quot;ts&quot;&gt;import Hello from &#x27;./Hello.ts&#x27;export default Hello&lt;/script&gt; src/components/Hello.ts123456789101112131415161718192021222324252627282930313233import Vue from &quot;vue&quot;import &#123; Component, Prop &#125; from &#x27;vue-property-decorator&#x27;@Componentexport default class HelloComponent extends Vue &#123; // props @Prop() name: string @Prop() initialEnthusiasm: number // data enthusiasm: number = this.initialEnthusiasm // computed get exclamationMarks(): string &#123; return Array(this.enthusiasm + 1).join(&#x27;!&#x27;) &#125; // methods increment(): void &#123; this.enthusiasm++; &#125; decrement(): void &#123; if (this.enthusiasm &gt; 1) &#123; this.enthusiasm-- &#125; &#125;&#125; tsconfig 설정현재 tsconfig.json을 src디렉토리에 복사합니다. 그리고 @/*를 해석할 수 있도록 baseUrl과 paths를 compilerOptions에 추가합니다. src/tsconfig.json1234567891011121314&#123; &quot;compilerOptions&quot;: &#123; ..., &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [ &quot;./*&quot; ] &#125; &#125;, &quot;include&quot;: [ &quot;./**/*&quot; ]&#125; 그리고 tsconfig.json을 test/unit 디렉토리에 복사하고 include를 제거합니다. test/unit/tsconfig.json1234567891011&#123; &quot;compilerOptions&quot;: &#123; ..., &quot;baseUrl&quot;: &quot;../../&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [ &quot;src/*&quot; ] &#125; &#125;&#125; tsconfig.json 파일을 둘로 나눈 이유는 include에 test/unit 디렉토리를 포함할 수 없어서 그런 것 같습니다. 만약 포함하게 된다면, 엄청나게 많은 에러가 발생하게 됩니다. (한번 해보세요 ㅎ) webpack 설정주의할 점은 webpack의 resolve.extensions입니다. 꼭 .vue가 &#39;.ts&#39;보다 앞에 있어야 합니다. webpack.config.js12345module.exports = &#123; resolve: &#123; extensions: [&#x27;&#x27;, &#x27;.vue&#x27;, &#x27;.ts&#x27;, &#x27;.js&#x27;, &#x27;.json&#x27;] &#125;&#125; 이렇게 설정하고 나면 import Hello from &#39;@/components/Hello&#39;는 다음과 같이 해석됩니다. VS Code 에서는 자동으로 .ts 확장자를 붙여서 src/components/Hello.ts를 바라보게 됩니다. webpack에서는 .vue를 먼저 바라보게 했기 때문에 src/components/Hello.vue를 바라보게 됩니다. 이제 VS Code에서 @/components/Hello에 마우스를 가져다 대면은 모듈을 찾을 수 있을 것입니다. 그렇다는 것은 vm.까지만 쳤을 때 자동완성 기능을 사용할 수 있다는 것입니다. 자동완성 기능으로 인해서 오타도 훨씬 줄어들고 개발 속도도 증가하는 것을 느끼실 수 있을 것입니다. 다음은?TSLint를 적용해볼 것입니다. 처음부터 적용하고 시작하려고 했으나, .vue 파일에서는 재대로 동작을 하지 않는 것 같아서 (Atom으로 해서 그런건지..) 이번에 TypeScript를 파일로 따로 분리했기 때문에 적용해보려고 합니다. 다음 이동 참조 Vue.js + TypeScript 조합으로 ASP.NET Core 애플리케이션 개발하기","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"}]},{"title":"Typescript로 Vue.js 시작하기 - 3","slug":"vuejs/getting-started-vuejs-with-typescript-3","date":"2017-08-19T02:52:58.000Z","updated":"2021-02-21T13:41:51.331Z","comments":true,"path":"vuejs/getting-started-vuejs-with-typescript-3/","link":"","permalink":"https://gongzza.github.io/vuejs/getting-started-vuejs-with-typescript-3/","excerpt":"","text":"이전 포스트 테스트 환경을 만들 것입니다. 테스트 환경은 Karma와 Mocha 그리고 Chai를 사용할 것입니다. 설치패키지들을 설치합니다. 1npm i -D karma mocha chai karma-chai karma-mocha karma-webpack phantomjs-prebuilt karma-phantomjs-launcher Karma 설정Karma 설정 파일을 작성합니다. test/unit/karma.conf.js12345678910111213141516171819202122232425262728var webpackConfig = require(&#x27;../../webpack.config.js&#x27;);module.exports = function (config) &#123; config.set(&#123; basePath: &#x27;&#x27;, frameworks: [&#x27;mocha&#x27;, &#x27;chai&#x27;], files: [ &#x27;index.ts&#x27; ], exclude: [ ], preprocessors: &#123; &#x27;index.ts&#x27;: [&#x27;webpack&#x27;] &#125;, webpack: &#123; module: webpackConfig.module, resolve: webpackConfig.resolve &#125;, reporters: [&#x27;progress&#x27;], port: 9876, colors: true, logLevel: config.LOG_INFO, autoWatch: false, browsers: [&#x27;PhantomJS&#x27;], singleRun: true, concurrency: Infinity &#125;)&#125; 위에서 설정한 엔트리 파일을 작성합니다. 엔트리 파일은 파일명이 .spec.ts로 끝나는 파일들만 불러오도록 합니다. test/unit/index.ts1234567import Vue from &#x27;vue&#x27;// disable print Vue production tipVue.config.productionTip = falseconst testsContext = require.context(&#x27;./&#x27;, true, /\\.spec\\.ts(x?)$/)testsContext.keys().forEach(testsContext) require.context는 webpack에서 사용하는 함수로 디렉토리를 검색할 수 있게 합니다. 링크 Test script 추가Karma를 실행하면서 설정파일을 지정해 주는 테스트 스크립트를 작성합니다. package.json123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;karma start test/unit/karma.conf.js&quot;&#125; Component Test 추가Hello.vue 컴포넌트의 테스트 케이스를 작성합니다. 간단하게 props를 넘겨주고, 넘겨준 값이 잘 반영되었는지 확인합니다. test/unit/components/Hello.spec.ts12345678910111213141516171819import &#123; expect &#125; from &#x27;chai&#x27;import Hello from &#x27;@/components/Hello.vue&#x27;describe(&#x27;Hello.vue&#x27;, () =&gt; &#123; it(&#x27;#propsData&#x27;, () =&gt; &#123; const propsData = &#123; name: &#x27;World&#x27;, initialEnthusiasm: 3 &#125; const vm = new Hello(&#123; el: document.createElement(&#x27;div&#x27;), propsData &#125;) expect(vm.name).to.equals(propsData.name) expect(vm.enthusiasm).to.equals(propsData.initialEnthusiasm) expect(vm.exclamationMarks).to.have.lengthOf(propsData.initialEnthusiasm) &#125;)&#125;) ../../../src/components/Hello.vue로 가져오는 것은 너무 길어서 src를 @로 webpack에서 alias를 걸어줍니다. webpack.config.js123456789var path = require(&#x27;path&#x27;)module.exports = &#123; resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(&#x27;src&#x27;) &#125; &#125;&#125; Test 실행테스트 스크립트를 실행합니다. 테스트는 성공적인 것을 확인할 수 있습니다.하지만, 타입스크립트 컴파일 에러를 보실 수 있습니다.이유는 타입을 찾지 못해서 입니다. 그래서 타입을 설치하도록 하겠습니다. @types 설치타입을 설치하는 이유를 같이 적어 두었습니다. 12345678# error TS2304: Cannot find name &#39;describe&#39;, &#39;it&#39;.$ npm i -D @types&#x2F;mocha# error TS7016: Could not find a declaration file for module &#39;chai&#39;.$ npm i -D @types&#x2F;chai# error TS2304: Cannot find name &#39;require&#39;.$ npm i -D @types&#x2F;webpack-env 설치 후 테스트를 다시 돌려보면, 컴파일이 성공적으로 마쳤다는 메시지인 webpack: Compiled successfully. 를 보실 수 있습니다. 다음은?VS Code에서 테스트 코드를 작성할 때 유용한 방법에 대해서 알아보도록 하겠습니다. 다음 이동","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"}]},{"title":"Typescript로 Vue.js 시작하기 - 2","slug":"vuejs/getting-started-vuejs-with-typescript-2","date":"2017-08-13T09:56:22.000Z","updated":"2021-02-21T13:41:51.331Z","comments":true,"path":"vuejs/getting-started-vuejs-with-typescript-2/","link":"","permalink":"https://gongzza.github.io/vuejs/getting-started-vuejs-with-typescript-2/","excerpt":"","text":"이전 포스트 Class-Based Components를 만들 것입니다. Microsoft/TypeScript-Vue-Starter에서 보여주는 컴포넌트 예제가 아닌 Class를 선택한 이유는 Class로 작성 할 때 TypeScript의 장점을 잘 살릴 수 있어서 입니다. 그리고 컴파일 에러도 발생하지 않습니다. 예를 들어서: src/components/Hello.vue1234567891011121314import Vue from &#x27;vue&#x27;export default Vue.extend(&#123; data() &#123; return &#123; name: &#x27;World&#x27; &#125; &#125;, methods: &#123; greet() &#123; alert(`Hello $&#123;this.name&#125;`) &#125; &#125;&#125;) 위 코드를 컴파일 할 경우 TypeScript는 greet() 메소드에서 this.name을 찾을 수 없다고 에러가 발생합니다. 12&#x2F;Users&#x2F;Gz&#x2F;study&#x2F;typescript&#x2F;vue-typescript-starter&#x2F;src&#x2F;components&#x2F;Hello.vue.ts(19,27): error TS2339: Property &#39;name&#39; does not exist on type &#39;Vue&#39;. 하지만, 다음과 같이 Class로 작성하면 위와 같은 에러도 발생하지 않고 this.까지만 쳐도 name을 찾을 수 있습니다. 12345678910111213import Vue from &#x27;vue&#x27;import Component from &#x27;vue-class-component&#x27;@Componentexport default class HelloComponent extends Vue &#123; // data name: string = &#x27;World&#x27; // methods greet(): void &#123; alert(`Hello $&#123;this.name&#125;`) &#125;&#125; Class-Based Componentsvue-class-component를 이용해서 컴포넌트를 class로 작성해보도록 하겠습니다. 설치1$ npm i -D vue-class-component TypeScript 설정vue-class-component의 @Component decorator를 사용하기 위해서는 tsconfig.json에서 설정을 해줘야 합니다. tsconfig.json12345&quot;compilerOptions&quot;: &#123; ... &quot;allowSyntheticDefaultImports&quot;: true, &quot;experimentalDecorators&quot;: true&#125; Single File ComponentsTypeScript에서 .vue파일을 불러올 때 Cannot find module &#39;./components/Hello.vue&#39;. 같은 에러를 볼 수 있습니다. .vue를 import할 때 어떤 파일인지 선언이 필요합니다. 다음 파일을 추가 합니다. src/vue-shims.d.ts1234declare module &#x27;*.vue&#x27; &#123; import Vue from &#x27;vue&#x27; export default Vue&#125; 이제 TypeScript에서 .vue 파일을 불러 올 때 에러가 발생하지 않을 것입니다. Component 추가Microsoft/TypeScript-Vue-Starter의 컴포넌트 예제를 @Component를 이용해서 Class로 작성합니다. src/components/Hello.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div&gt; &lt;div class=&quot;greeting&quot;&gt;Hello &#123;&#123;name&#125;&#125;&#123;&#123;exclamationMarks&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import Vue from &#x27;vue&#x27;import Component from &#x27;vue-class-component&#x27;@Component(&#123; props: &#123; name: String, initialEnthusiasm: Number &#125;&#125;)export default class HelloComponent extends Vue &#123; // data enthusiasm: number = this.initialEnthusiasm // computed get exclamationMarks(): string &#123; return Array(this.enthusiasm + 1).join(&#x27;!&#x27;); &#125; // methods increment(): void &#123; this.enthusiasm++ &#125; decrement(): void &#123; if (this.enthusiasm &gt; 1) &#123; this.enthusiasm-- &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.greeting &#123; font-size: 20px;&#125;&lt;/style&gt; src/index.ts에서 HelloComponent를 추가해줍니다. src/index.ts123456789101112131415161718import Vue from &#x27;vue&#x27;import HelloComponent from &#x27;./components/Hello.vue&#x27;new Vue(&#123; el: &#x27;#app&#x27;, template: ` &lt;div&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;hello-component :name=&quot;name&quot; :initialEnthusiasm=&quot;5&quot; /&gt; &lt;/div&gt; `, data: &#123; name: &#x27;World&#x27; &#125;, components: &#123; HelloComponent &#125;&#125;) 개발 서버를 실행해서 확인해 보면 잘 동작 하는 것을 볼 수 있습니다. vue-property-decorator하지만, 다음과 같은 에러를 보실 수 있습니다. 12&#x2F;Users&#x2F;Gz&#x2F;study&#x2F;typescript&#x2F;vue-typescript-starter&#x2F;src&#x2F;components&#x2F;Hello.vue.ts(23,29): error TS2339: Property &#39;initialEnthusiasm&#39; does not exist on type &#39;HelloComponent&#39;. 이유는 initialEnthusiasm를 Class 내부가 아닌 @Component에서 선언하고 있어서 찾지 못하는 것입니다. 이 문제를 해결하기 위해서 enthusiasm와 마찬가지로 Class 내부에서 선언하면 됩니다. vue-property-decorator의 @Prop를 이용하면 Class 내부에 선언된 변수를 props와 연결해 줍니다. 설치1$ npm i -D vue-property-decorator TypeScript 설정emitDecoratorMetadata를 활성화 해줘야 type을 재대로 가져가서 설정을 해줍니다. tsconfig.json123&quot;compilerOptions&quot;: &#123; &quot;emitDecoratorMetadata&quot;: true&#125; Component 수정src/components/Hello.vue1234567891011121314151617- import Component from &#x27;vue-class-component&#x27;+ import &#123; Component, Prop &#125; from &#x27;vue-property-decorator&#x27;- @Component(&#123;- props: &#123;- name: String,- initialEnthusiasm: Number- &#125;- &#125;)+ @Componentexport default class HelloComponent extends Vue &#123;+ // props+ @Prop() name: string+ @Prop() initialEnthusiasm: number ... 이제 에러가 없는 깔끔한 로그를 볼 수 있을 것입니다. 다음은?unit test 환경을 만들어보도록 하겠습니다. 다음 이동 참조 vue-class-component vue-property-decorator","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"}]},{"title":"Typescript로 Vue.js 시작하기 - 1","slug":"vuejs/getting-started-vuejs-with-typescript-1","date":"2017-08-13T08:04:07.000Z","updated":"2021-02-21T13:41:51.330Z","comments":true,"path":"vuejs/getting-started-vuejs-with-typescript-1/","link":"","permalink":"https://gongzza.github.io/vuejs/getting-started-vuejs-with-typescript-1/","excerpt":"","text":"Typescript로 Vue.js를 사용하는 방법을 알아보려고 합니다. Vue.js에서도 Typescript 지원을 하듯이 둘은 잘 어울릴 수 있다고 생각합니다. Typescript 기초는 타입스크립트 코리아: 2017.05 기초 세미나 - Youtube를 보시면 도움이 될 것 같습니다. Microsoft/TypeScript-Vue-Starter를 참고하여 작성하였습니다. 프로젝트 생성먼저 프로젝트를 초기화 합니다. 1$ mkdir vue-typescript-starter &amp;&amp; cd vue-typescript-starter package.json를 작성합니다. package.json123&#123; &quot;name&quot;: &quot;vue-typescript-starter&quot;&#125; 설치package들을 설치합니다. 1$ npm i -D vue typescript webpack ts-loader css-loader vue-loader vue-template-compiler TypeScript 설정tsc를 이용해서 tsconfig.json을 생성할 수 있습니다. 1$ ./node_modules/.bin/tsc --init 하지만, tsc --init으로 생성할 경우 양이 방대하기 때문에 다음과 같이 필요한 옵션만 넣도록 합니다. 123456789101112131415&#123; &quot;compilerOptions&quot;: &#123; &quot;outDir&quot;: &quot;.&#x2F;built&#x2F;&quot;, &quot;sourceMap&quot;: true, &quot;strict&quot;: true, &quot;noImplicitReturns&quot;: true, &quot;module&quot;: &quot;es2015&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;allowSyntheticDefaultImports&quot;: true &#125;, &quot;include&quot;: [ &quot;.&#x2F;src&#x2F;**&#x2F;*&quot; ]&#125; allowSyntheticDefaultImports 옵션을 활성화 해야지 import Vue from &#39;vue&#39;처럼 사용할 수 있습니다. Webpack 설정앱 번들을 위한 webpack.config.js를 추가합니다. webpack.config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var path = require(&#x27;path&#x27;)var webpack = require(&#x27;webpack&#x27;)module.exports = &#123; entry: &#x27;./src/index.ts&#x27;, output: &#123; path: path.resolve(__dirname, &#x27;./dist&#x27;), publicPath: &#x27;/dist/&#x27;, filename: &#x27;build.js&#x27; &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27; &#125;, &#123; test: /\\.tsx?$/, loader: &#x27;ts-loader&#x27;, exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125; &#125; ] &#125;, resolve: &#123; extensions: [&#x27;.ts&#x27;, &#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], alias: &#123; &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27; &#125; &#125;, devServer: &#123; historyApiFallback: true, noInfo: true &#125;, performance: &#123; hints: false &#125;, devtool: &#x27;#eval-source-map&#x27;&#125;if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; module.exports.devtool = &#x27;#source-map&#x27; // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: &#x27;&quot;production&quot;&#x27; &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: true, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125; Hello World이제 Hello World를 화면에 띄워 보도록 합니다. webpack.config.js에서 설정한 entry로 시작 파일을 작성합니다. src/index.ts1234567891011121314import Vue from &#x27;vue&#x27;new Vue(&#123; el: &#x27;#app&#x27;, template: ` &lt;div&gt; &lt;div&gt;Hello &#123;&#123;name&#125;&#125;!&lt;/div&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/div&gt; `, data: &#123; name: &#x27;World&#x27; &#125;&#125;) index.html1234567891011&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./dist/build.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 빌드 스크립트package.json에 Webpack을 실행하는 build 스크립트를 추가합니다. package.json123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;&#125; 실행은 다음과 같이 합니다. index.html를 열어보면 다음과 같은 화면을 볼 수 있습니다. webpack-dev-server를 이용해서 변경을 감지하여 자동으로 빌드 후 적용되도록 합니다. 1$ npm i -D webpack-dev-server dev 스크립트를 추가합니다. package.json123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --hot --inline&quot;&#125; 서버를 실행합니다. 123456789$ npm run dev&gt; vue-typescript-starter@ dev /Users/Gz/study/typescript/vue-typescript-starter&gt; webpack-dev-serverProject is running at http://localhost:8080/webpack output is served from /dist/404s will fallback to /index.htmlts-loader: Using typescript@2.4.2 and /Users/Gz/study/typescript/vue-typescript-starter/tsconfig.json 이제 http://localhost:8080 으로 접속하면 똑같은 화면을 볼 수 있습니다.그리고 src/index.ts를 수정하면 자동으로 빌드가 되면서 화면에 바로 적용 되는 것을 볼 수 있습니다. 다음은?vue-class-component를 이용해서 Class-Based Components를 만드는 방법을 살펴보도록 하겠습니다. 다음 이동 참조 Microsoft/TypeScript-Vue-Starter 타입스크립트 코리아: 2017.05 기초 세미나 - Youtube","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"}]},{"title":"Express에 Swagger 붙이기","slug":"nodejs/express/swagger-node-express","date":"2017-07-18T11:16:30.000Z","updated":"2021-02-21T13:41:51.325Z","comments":true,"path":"nodejs/express/swagger-node-express/","link":"","permalink":"https://gongzza.github.io/nodejs/express/swagger-node-express/","excerpt":"","text":"Express에 Swagger를 붙여보려고 합니다. Install언제나 시작은 설치부터죠 1$ npm install --save-dev swagger-ui-express swagger-jsdoc swagger-ui-express: express에 swagger ui를 쉽게 붙일 수 있습니다. swagger-jsdoc: Comment 형식으로 문서를 작성할 수 있습니다. Swagger Specificationswagger-jsdoc를 이용해서 Swagger 명세서를 생성합니다. 12345678910111213141516171819202122232425const swaggerJSDoc = require(&#x27;swagger-jsdoc&#x27;)// Swagger definition// You can set every attribute except paths and swagger// https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.mdvar swaggerDefinition = &#123; info: &#123; // API informations (required) title: &#x27;Hello World&#x27;, // Title (required) version: &#x27;1.0.0&#x27;, // Version (required) description: &#x27;A sample API&#x27;, // Description (optional) &#125;, host: &#x27;localhost:3000&#x27;, // Host (optional) basePath: &#x27;/&#x27;, // Base path (optional)&#125;// Options for the swagger docsvar options = &#123; // Import swaggerDefinitions swaggerDefinition: swaggerDefinition, // Path to the API docs apis: [&#x27;./example/routes*.js&#x27;, &#x27;./example/parameters.yaml&#x27;],&#125;// Initialize swagger-jsdoc -&gt; returns validated swagger spec in json formatvar swaggerSpec = swaggerJSDoc(options) apis 배열에 들어간 파일들의 주석을 분석합니다. swaggerDefinition는 json이기 때문에 파일로 따로 분리할 수도 있고, production일 경우 basePath를 변경할 수 있습니다. 상세 정보는 여기를 참고하시면 됩니다. host는 변경하지 않으면 현재 Domain을 따라서 갑니다. Security DefinitionsJWT 인증을 사용할 경우 다음과 같이 swaggerDefinition을 수정합니다. 12345678910111213var swaggerDefinition = &#123; ... securityDefinitions: &#123; jwt: &#123; type: &#x27;apiKey&#x27;, name: &#x27;Authorization&#x27;, in: &#x27;header&#x27; &#125; &#125;, security: [ &#123; jwt: [] &#125; ]&#125; security를 API마다 따로 적용할 수도 있지만, 여기서는 로그인 기반 서비스이기 때문에 전역으로 설정하였습니다.자세한 사항은 여기 를 참고하시기 바랍니다. Writing the documentationYAML형식으로 문서를 작성합니다. 12345678910111213141516171819202122232425262728293031323334353637383940/** * @swagger * tags: * name: Todo * description: Todo management * definitions: * Todo: * type: object * required: * - content * properties: * _id: * type: string * description: ObjectID * content: * type: string * description: 할일 내용 * done: * type: boolean * description: 완료 여부 *//** * @swagger * /todo: * get: * summary: Returns Todo list * tags: [Todo] * responses: * 200: * description: todo list * schema: * type: object * properties: * todos: * type: array * items: * $ref: &#x27;#/definitions/Todo&#x27; */router.put(&#x27;/&#x27;, isAuthenticated, todoList); 위 문서를 파싱할 경우 아래와 같은 화면을 보실 수 있습니다. Swagger UI ExpressExpress에 Swagger UI를 추가합니다. 1234567const express = require(&#x27;express&#x27;);const app = express();const swaggerUi = require(&#x27;swagger-ui-express&#x27;);const swaggerSpec = swaggerJSDoc(options);app.use(&#x27;/api-docs&#x27;, swaggerUi.serve, swaggerUi.setup(swaggerSpec)); 설정이 정말 간단하죠?이제 http://localhost:3000/api-docs 로 접속하면 위에서 봤던 화면을 보실 수 있습니다. /api-docs는 얼마든지 변경하셔서 사용하시면 됩니다. References https://swagger.io/specification/ https://apihandyman.io/writing-openapi-swagger-specification-tutorial-part-1-introduction/ http://joliv.me/2016/10/15/express-api-swagger/","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://gongzza.github.io/categories/Node-js/"},{"name":"Express","slug":"Node-js/Express","permalink":"https://gongzza.github.io/categories/Node-js/Express/"}],"tags":[{"name":"swagger-jsdoc","slug":"swagger-jsdoc","permalink":"https://gongzza.github.io/tags/swagger-jsdoc/"},{"name":"node.js","slug":"node-js","permalink":"https://gongzza.github.io/tags/node-js/"},{"name":"swagger-ui-express","slug":"swagger-ui-express","permalink":"https://gongzza.github.io/tags/swagger-ui-express/"}]},{"title":"Let's Encrypt - 무료 SSL 인증서 발급받기","slug":"linux/install/install-letsencrypt-nginx","date":"2017-05-22T16:45:28.000Z","updated":"2021-02-21T09:19:03.653Z","comments":true,"path":"linux/install/install-letsencrypt-nginx/","link":"","permalink":"https://gongzza.github.io/linux/install/install-letsencrypt-nginx/","excerpt":"","text":"Let’s Encrypt를 적용하는 방법을 알아볼 것입니다. 다행히 문서화가 잘 되어 있어서 (한글은 아니지만…) 다른 환경에서도 적용하는데 큰 문제는 없을 것입니다. 서버 환경OS: CentOS7NGINX: 1.10.2 InstallCertbot을 이용해서 아주 간단하게 설치할 수 있습니다.“I’m using (Software) on (System)”을 시스템에 맞게 선택 하면은 설치 방법을 알려줍니다.저는 위에 적힌 서버 환경대로 Software에서 Nginx를 선택 하고 System에서 CentOS/RHEL 7를 선택하였습니다. 주의설치하기에 앞서 반듯이 EPEL repository가 활성화 되어 있어야 합니다.만약 설치 하지 않았다면, sudo yum install epel-release로 설치하면 됩니다. Certbot을 설치합니다. 1$ sudo yum install certbot 인증서를 생성하는 방법은 다음과 같습니다. 1$ sudo certbot certonly --standalone -d www.example.com 주의Certbot이 인증을 하면서 443 포트를 사용합니다. (80 포트를 사용할 수도 있습니다.) 그래서 443 포트를 열어주어야 합니다. 12$ sudo firewall-cmd --permanent --add-service=https$ sudo firewall-cmd --reload 주의만약 Nginx 또는 다른 어떤 프로그램이 443 포트가 사용중이라면, 다음과 같은 에러를 볼 수 있습니다. 12345678910111213$ sudo certbot certonly --standalone -d www.example.comSaving debug log to /var/log/letsencrypt/letsencrypt.logStarting new HTTPS connection (1): acme-v01.api.letsencrypt.orgObtaining a new certificatePerforming the following challenges:tls-sni-01 challenge for www.example.com-------------------------------------------------------------------------------Could not bind TCP port 443 because it is already in use by another process onthis system (such as a web server). Please stop the program in question and thentry again.-------------------------------------------------------------------------------(R)etry/(C)ancel: 443포트를 비워두고 Retry 또는 다시 명령어를 실행하면 됩니다. nginx를 사용할 경우 다음과 같이 hook를 이용할 수 있습니다. 1$ sudo certbot certonly --standalone -d gz.us.to --pre-hook &quot;systemctl stop nginx&quot; --post-hook &quot;systemctl start nginx&quot; Nginx configurationNginx에 위에서 발급받은 SSL 인증서를 설정합니다. 123456789101112$ sudo vi &#x2F;etc&#x2F;nginx&#x2F;nginx.confserver &#123; listen 443 ssl; server_name www.example.com; ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.example.com&#x2F;fullchain.pem; ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.example.com&#x2F;privkey.pem; location &#x2F; &#123; ... &#125;&#125; 설정 정보를 적용합니다. 1$ sudo systemctl reload nginx 아무런 메시지 없이 프롬프트로 떨어졌다면, 정상적으로 설정이 적용된 것입니다. ProxyAPI서버를 따로 두었을 경우 proxy를 이용하여 요청정보를 넘길 수 있습니다. 123456789101112131415$ sudo vi &#x2F;etc&#x2F;nginx&#x2F;nginx.confserver &#123; ... location &#x2F;api &#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-NginX-Proxy true; proxy_pass http:&#x2F;&#x2F;localhost:3000&#x2F;api; proxy_redirect off; &#125;&#125; 이제 /api로 호출되는 모든 요청은 내부서버로 넘어가게 됩니다. Renewing certificatesLet’s Encrypt로 발급받은 SSL 인증서는 유효기간이 90일 입니다.그리고 재발급이 가능한 기간은 60일 이후 부터입니다. 먼저 --dry-run 옵션으로 재발급이 가능한지 테스트를 할 수 있습니다. 1234$ sudo certbot renew --dry-run...Congratulations, all renewals succeeded. The following certs have been renewed: &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.example.com&#x2F;fullchain.pem (success) 위와 같이 success가 나온다면 60일 이후 certbot renew 명령으로 재발급을 받을 수 있습니다. 여기서도 문제가 발생할 수 있습니다.처음에 인증서를 발급하면서 hook을 이용하지 않으셧을 경우 nginx가 켜져 있으면, 위에서 발생했던 443 포트 문제가 다시 발생하게 됩니다.그럴 경우 renewal파일에 hook을 추가해줍니다. 1234567$ sudo vi &#x2F;etc&#x2F;letsencrypt&#x2F;renewal&#x2F;www.example.com.conf...# Options used in the renewal process[renewalparams]pre_hook &#x3D; systemctl stop nginxpost_hook &#x3D; systemctl start nginx... 다시 명령어를 실행하면 성공으로 떨어지는 것을 확인할 수 있을 것입니다. CrontabLinux의 스케줄러인 Crontab에 등록해서 3달에 한번씩 자동 갱신하도록 작업을 추가합니다. 12$ sudo crontab -e0 4 1 *&#x2F;3 * certbot renew 1월, 4월, 7월, 10월 1일 4시 0분에 위 명령어가 실행됩니다. Conclusion정보가 중요한 시대인 만큼 보안은 필수입니다.SSL을 적용함으로 써 속도가 느려지는 부분도 존재하지만, 그 부분은 매우 미미하다고 생각합니다.옛날에는 SSL인증서 발급이 비싸서 주로 개인서명(Self Signed)를 많이 사용했지만, 고맙게도 이렇게 무료로 인증서를 발급해주니 꼭 서버에 적용해서 안전한 서비스를 제공하시기 바랍니다. References https://letsencrypt.org/ https://certbot.eff.org/ https://zetawiki.com/wiki/YUM_epel_%EC%A0%80%EC%9E%A5%EC%86%8C_%EC%B6%94%EA%B0%80 https://www.upcloud.com/support/install-lets-encrypt-nginx/","categories":[{"name":"Linux","slug":"Linux","permalink":"https://gongzza.github.io/categories/Linux/"},{"name":"Install","slug":"Linux/Install","permalink":"https://gongzza.github.io/categories/Linux/Install/"}],"tags":[{"name":"install","slug":"install","permalink":"https://gongzza.github.io/tags/install/"},{"name":"nginx","slug":"nginx","permalink":"https://gongzza.github.io/tags/nginx/"},{"name":"centos","slug":"centos","permalink":"https://gongzza.github.io/tags/centos/"},{"name":"https","slug":"https","permalink":"https://gongzza.github.io/tags/https/"},{"name":"letsencrypt","slug":"letsencrypt","permalink":"https://gongzza.github.io/tags/letsencrypt/"}]},{"title":"Express 테스트 환경 만들기(2)","slug":"nodejs/express/express-test-structure-2","date":"2017-04-11T12:16:11.000Z","updated":"2021-02-21T13:41:51.325Z","comments":true,"path":"nodejs/express/express-test-structure-2/","link":"","permalink":"https://gongzza.github.io/nodejs/express/express-test-structure-2/","excerpt":"","text":"이번에는 Express 테스트 환경 만들기(1)를 이어서 DB 테스트 환경을 구축하겠습니다. 여기서 저는 MongoDB ODM(Object Data Mapping) 프레임워크인 Mongoose를 사용할 것입니다. 설치1$ npm i -S mongoose Todo간단하게 Todo로 테스트 코드를 만들어 볼 생각입니다. 먼저 DB 접속 부분을 작성합니다.url부분은 환경에 맞게 수정하시면 됩니다. db.js123456789101112131415import mongoose from &#x27;mongoose&#x27;mongoose.Promise = global.Promisevar db = nullvar url = &#x27;mongodb://host:port/database&#x27;export function connect(cb) &#123; db = mongoose.connection db.on(&#x27;error&#x27;, console.error.bind(console, &#x27;connection error:&#x27;)) db.once(&#x27;open&#x27;, function() &#123; cb() &#125;) mongoose.connect(url)&#125; 그리고 스키마를 작성합니다. todo.js123456789var mongoose = require(&#x27;mongoose&#x27;)var Schema = mongoose.Schema(&#123; content: String, done: Boolean&#125;)const Todo = mongoose.model(&#x27;Todo&#x27;, Schema)export default Todo api를 작성합니다. app.js123456789101112131415import * as db from &#x27;./db&#x27;import Todo from &#x27;./todo&#x27;...app.get(&#x27;/todos&#x27;, async (req, res) =&gt; &#123; const todos = await Todo.find().exec() res.json(&#123;todos&#125;)&#125;)db.connect(() =&gt; &#123; app.listen(3000, function () &#123; console.log(&#x27;Example app listening on port 3000!&#x27;); &#125;);&#125;) test를 작성합니다. todos.test.js12345678910111213import test from &#x27;ava&#x27;;import request from &#x27;supertest&#x27;import app from &#x27;./app&#x27;test(&#x27;todos&#x27;, async t =&gt; &#123; const res = await request(app) .get(&#x27;/todos&#x27;) .expect(200) const todos = res.body.todos t.true(Array.isArray(todos))&#125;) 테스트를 돌려보면 성공으로 떨어질 것입니다. 테스트를 수행하기전에 기본적인 데이터를 넣어두는 방법을 알아보겠습니다. 테스트 데이터를 만드는 방법은 2가지가 있습니다.하나는 직접 fixtures.json을 만드는 방법과 하나는 faker.js를 이용하는 방법입니다. 하나하나 알아 보겠습니다. Fixtures먼저 json파일을 만듭니다. fixtures.json12345678910111213141516&#123; &quot;todos&quot;: [ &#123; &quot;content&quot;: &quot;Todo 1&quot;, &quot;done&quot;: false &#125;, &#123; &quot;content&quot;: &quot;Todo 2&quot;, &quot;done&quot;: true &#125;, &#123; &quot;content&quot;: &quot;Todo 3&quot;, &quot;done&quot;: false &#125; ]&#125; 테스트 파일을 수정합니다. todos.test.js12345678910111213141516171819202122...import Todo from &#x27;./todo&#x27;import fixtures from &#x27;./fixtures&#x27;var insertedIds = nulltest.cb.before(t =&gt; &#123; Todo.collection.insert(fixtures.todos, (err, docs) =&gt; &#123; if (err) return t.fail() insertedIds = docs.insertedIds t.end() &#125;)&#125;)test.cb.after(t =&gt; &#123; if (insertedIds) &#123; Todo.collection.remove(&#123;_id: &#123;$in: insertedIds&#125;&#125;, (err, docs) =&gt; &#123; if (err) return t.fail() t.end() &#125;) &#125;&#125;) 검증은 아래처럼 할 수 있습니다. 1t.is(res.body.todos.length, fixtures.todos.length) Fakerjson을 만들때 값을 쉽게 만들어주는 라이브러리입니다. 사용하기 쉽도록 메소드로 만들어 보았습니다. helpers.js123456789101112131415161718192021222324252627282930import faker from &#x27;faker&#x27;/** * Create mock object * * 파라메터 객체 구조를 그대로 가지면서 * value값을 해석해서 fake value로 채워서 리턴합니다. * * @param &#123;Object&#125; obj - mock data로 채워질 객체 * @return &#123;Object&#125; - mock data로 채워진 객체 */export function mock(obj) &#123; let mockup = &#123;&#125; for (let key of Object.keys(obj)) &#123; mockup[key] = faker.fake(obj[key]) &#125; return mockup&#125;/** * Create mock data array * * @param &#123;Object&#125; obj - mock data로 채워질 객체 * @param &#123;Number&#125; [length = 3] - 갯수 만큼 객체를 생성 */export function mocks(obj, length = 3) &#123; return Array.from(&#123;length&#125;, () =&gt; mock(obj))&#125; 사용법은 다음과 같습니다. todos.test.js1234567891011121314151617181920212223import &#123;mocks&#125; from &#x27;./helper&#x27;var insertedIds = nulltest.cb.before(t =&gt; &#123; const todos = mocks(&#123; content: &#x27;&#123;&#123;lorem.sentence&#125;&#125;&#x27; &#125;, 3) Todo.collection.insert(todos, (err, docs) =&gt; &#123; if (err) return t.fail() insertedIds = docs.insertedIds t.end() &#125;)&#125;)test.cb.after(t =&gt; &#123; if (insertedIds) &#123; Todo.collection.remove(&#123;_id: &#123;$in: insertedIds&#125;&#125;, (err, docs) =&gt; &#123; if (err) return t.fail() t.end() &#125;) &#125;&#125;) 이렇게 손쉽게 목데이터를 만들수 있습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://gongzza.github.io/categories/Node-js/"},{"name":"Express","slug":"Node-js/Express","permalink":"https://gongzza.github.io/categories/Node-js/Express/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://gongzza.github.io/tags/mongodb/"},{"name":"express","slug":"express","permalink":"https://gongzza.github.io/tags/express/"},{"name":"node.js","slug":"node-js","permalink":"https://gongzza.github.io/tags/node-js/"},{"name":"ava","slug":"ava","permalink":"https://gongzza.github.io/tags/ava/"},{"name":"mongoose","slug":"mongoose","permalink":"https://gongzza.github.io/tags/mongoose/"}]},{"title":"Express 테스트 환경 만들기(1)","slug":"nodejs/express/express-test-structure-1","date":"2017-04-09T13:53:13.000Z","updated":"2021-02-21T13:41:51.324Z","comments":true,"path":"nodejs/express/express-test-structure-1/","link":"","permalink":"https://gongzza.github.io/nodejs/express/express-test-structure-1/","excerpt":"","text":"Express 서버 테스트 환경을 구축하는 방법을 알아볼 것입니다.설치부터 시작해서 AVA와 Babel을 적용할 것입니다. Hello world ExampleExpress 시작하기를 보면 설명이 잘 되어 있습니다.먼저 차례대로 따라가 보겠습니다. 12345678# 디렉토리 생성$ mkdir myapp &amp;&amp; cd myapp# package.json 생성 및 초기화$ npm init -y# express 설치$ npm install express --save app.js12345678910var express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;, function (req, res) &#123; res.send(&#x27;Hello World!&#x27;);&#125;);app.listen(3000, function () &#123; console.log(&#x27;Example app listening on port 3000!&#x27;);&#125;); 실행 후 확인해 봅니다. 12$ node app.jsExample app listening on port 3000! 브라우저로 http://localhost:3000 에 접속하면, Hello World!를 확인할 수 있습니다. Test매번 서버를 실행 시키고, 브라우저를 열어서 URL에 접속 후 결과물을 눈으로 직접 확인하는 일은 시간도 많이 소요되고 고도의 집중력을 필요로 해서 프로젝트가 점점 커질 수록 테스트하기가 힘들어질 것입니다.테스트 케이스를 만들어 두면, 명령어 한번에 모든 케이스에 대해서 테스트를 진행하고 사이드 이펙트를 바로 찾을 수 있어서 처음부터 차근차근 만들어 나가는 것이 좋습니다.저는 여기서 테스트 프레임워크로 AVA를 선택하였습니다. 한국어 번역이 되어 있어서 손쉽게 이해하고 사용할 수 있습니다. 한국어 먼저 설치를 진행합니다. 1$ npm i -D ava 그리고 테스트 실행 스크립트를 작성합니다. package.json12345&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;ava&quot; &#125;&#125; 홈페이지에 적혀있는 테스트 예제 파일을 작성해봅니다. test.js1234567891011import test from &#x27;ava&#x27;;test(&#x27;foo&#x27;, t =&gt; &#123; t.pass();&#125;);test(&#x27;bar&#x27;, async t =&gt; &#123; const bar = Promise.resolve(&#x27;bar&#x27;); t.is(await bar, &#x27;bar&#x27;);&#125;); 테스트를 실행합니다. 12345678$ npm test&gt; myapp@1.0.0 test /myapp&gt; avaExample app listening on port 3000! 2 passed 2개의 테스트 모두 성공한 것을 확인할 수 있습니다. 테스트가 잘 수행되는 것을 확인 했으니, 이제 본격적으로 express를 테스트를 하기 위한 준비를 하겠습니다. express를 테스트 하기 위해서 SuperTest를 사용합니다. 먼저 설치해줍니다. 1$ npm i -D supertest 그 다음 app.js에 다음 문구를 추가합니다. 12...module.exports = app 이유는 SuperTest에서 app을 참조하기 때문입니다. 테스트 케이스를 작성합니다. test.js1234567891011import test from &#x27;ava&#x27;;import request from &#x27;supertest&#x27;import app from &#x27;./app&#x27;test(&#x27;greeting&#x27;, async t =&gt; &#123; const res = await request(app) .get(&#x27;/&#x27;) .expect(200) t.is(res.text, &#x27;Hello World!&#x27;)&#125;) 테스트를 다시 실행해봅니다. 12345678$ npm test&gt; myapp@1.0.0 test /myapp&gt; avaExample app listening on port 3000! 1 passed Babel테스트 케이스를 작성하면서 눈치채셧겠지만, app.js와 문법이 다릅니다.AVA에서는 기본적으로 Babel을 이용한 ES2017을 지원합니다. AVA ES2017 support그래서 test.js에서 es2016이상의 문법을 사용할 수 있었던 것입니다. 이번에는 app.js도 Babel을 이용해서 test와 같은 Syntax 환경을 만들겠습니다. 다음과 같이 설치합니다. 1$ npm i -D babel-cli 설정 파일을 다음과 같이 수정합니다. package.json1234567891011&#123; &quot;scripts:&quot; &#123; &quot;start&quot;: &quot;babel-node app.js&quot; &#125;, &quot;ava&quot;: &#123; &quot;require&quot;: [ &quot;babel-register&quot; ], &quot;babel&quot;: &quot;inherit&quot; &#125;&#125; .babelrc를 생성합니다. .babelrc12345&#123; &quot;presets&quot;: [ &quot;@ava/stage-4&quot; ]&#125; AVA에서 사용하는 presets를 그대로 사용합니다. 잘 적용이 되었는지 확인해 보기 위해서 app.js를 다음과 같이 수정해봅니다. 12- var express = require(&#x27;express&#x27;)+ import express from &#x27;express&#x27; 테스트가 잘 수행이 되는지 확인해 봅니다. 12345678$ npm test&gt; myapp@1.0.0 test /myapp&gt; avaExample app listening on port 3000! 1 passed 이제 다음과 같은 코딩이 가능합니다. 12345678910111213141516171819202122// app.jsfunction randomNumber() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(Math.floor(Math.exp(Math.random() * 10))) &#125;, 0) &#125;)&#125;app.get(&#x27;/random&#x27;, async (req, res) =&gt; &#123; const num = await randomNumber() res.json(&#123;num&#125;)&#125;)// test.jstest(&#x27;random&#x27;, async t =&gt; &#123; const res = await request(app) .get(&#x27;/random&#x27;) .expect(200) t.truthy(/^\\d+$/.test(res.body.num))&#125;) 비동기 호출을 콜백을 이용하지 않고 async/await을 이용해서 자연스럽게 읽히는 코드를 작성할 수 있게 되었습니다. Watch위에서 보셧듯이 수정이 일어날 때마다 확인해보기 위해서 테스트 명령어를 실행해서 확인해 보아야 했습니다. 자동으로 수행해 준다면 정말 편할 것 입니다. 설정파일에 실행 스크립트를 추가합니다. package.json12345&#123; &quot;scripts&quot;: &#123; &quot;test:watch&quot;: &quot;npm test -- --watch&quot; &#125;&#125; 명령어를 실행합니다. 1$ npm run test:watch 테스트 수행 후 프롬프르트로 떨어지지 않을 것입니다.이제 파일을 수정할 때마다 테스트를 다시 수행합니다. 만약 수정한 파일이 테스트 파일일 경우 해당 파일의 테스트들만 다시 실행을 합니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://gongzza.github.io/categories/Node-js/"},{"name":"Express","slug":"Node-js/Express","permalink":"https://gongzza.github.io/categories/Node-js/Express/"}],"tags":[{"name":"express","slug":"express","permalink":"https://gongzza.github.io/tags/express/"},{"name":"supertest","slug":"supertest","permalink":"https://gongzza.github.io/tags/supertest/"},{"name":"node.js","slug":"node-js","permalink":"https://gongzza.github.io/tags/node-js/"},{"name":"ava","slug":"ava","permalink":"https://gongzza.github.io/tags/ava/"},{"name":"babel-cli","slug":"babel-cli","permalink":"https://gongzza.github.io/tags/babel-cli/"}]},{"title":"Semantic-UI Toastr for Vue.js","slug":"vuejs/semantic-ui-toastr-for-vuejs","date":"2017-03-25T05:54:12.000Z","updated":"2021-02-21T13:41:51.337Z","comments":true,"path":"vuejs/semantic-ui-toastr-for-vuejs/","link":"","permalink":"https://gongzza.github.io/vuejs/semantic-ui-toastr-for-vuejs/","excerpt":"","text":"Semantic-UI를 기반으로 하는 Toastr를 만들어 보았다. vue-bulma/notification를 참조해서 만들었다. 처음에는 vue-toastr처럼 Root 컴포넌트에서 하위 컴포넌트로 선언을 하고 ref를 지정해서 해당 컴포넌트의 메소드를 호출하는 식으로 개발을 했었다.하지만 사용함에 있어서 제약사항이 너무나도 많았다. 모든 컴포넌트에서 접근할 수 있는 this.$root에 하위 컴포넌트로 등록을 해야 한다. 등록한 하위 컴포넌트를 ref로 지정해서 접근한다. ref로 지정한 이름을 모든 컴포넌트가 알고 있어야 한다. Root 컴포넌트가 mounted된 이후 사용할 수 있다. 만약 매번 컴포넌트마다 하위 컴포넌트로 선언해서 사용할 경우 mounted가 호출된 이후에 사용할 수 있어서 life-cycle이 무의미해 진다. 즉, 다음과 같이 사용할 수 없다. 12345beforeMount() &#123; this.$refs.toastr.i(&#x27;Welcome&#x27;)&#125;// [Vue warn]: Error in beforeMount hook// [Error] TypeError: undefined is not an object (evaluating &#x27;this.$refs.toastr.i&#x27;) 또 this.$root.$refs.toastr는 다음과 같이 생성하면, 접근할 수가 없다. 1234567import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;new Vue(&#123; el: &#x27;#app&#x27;, render: h =&gt; h(App)&#125;) 위와 같이 할 경우 this.$root.$children[0].$refs.toastr로 접근을 해야 한다. 그리고 한번 접근하기 위해서 이름이 너무 길다. 뭔가 많이 비효율적인 것 같아서 계속 고민을 하던 중 vue-bulma/notification 소스를 보게 되었다. 사용법만 봤을 뿐인데도 매우 마음에 들었다. 왜냐하면 의존성을 찾아볼 수 없었기 때문이다. 1234567891011121314151617181920212223242526272829import Vue from &#x27;vue&#x27;import Notification from &#x27;vue-bulma-notification&#x27;const NotificationComponent = Vue.extend(Notification)const openNotification = (propsData = &#123; title: &#x27;&#x27;, message: &#x27;&#x27;, type: &#x27;&#x27;, direction: &#x27;&#x27;, duration: 4500, container: &#x27;.notifications&#x27;&#125;) =&gt; &#123; return new NotificationComponent(&#123; el: document.createElement(&#x27;div&#x27;), propsData &#125;)&#125;...methods: &#123; openNotificationWithType (type) &#123; openNotification(&#123; title: &#x27;This is a title&#x27;, message: &#x27;This is the message.&#x27;, type: type &#125;) &#125;&#125; 그리고 Notification.vue에서 다시한번 감동을 받았다.핵심은 created와 mounted에 있다. Notification.vue123456789101112131415161718192021222324252627282930313233created () &#123; let $parent = this.$parent if (!$parent) &#123; let parent = document.querySelector(this.container) if (!parent) &#123; // Lazy creating `div.notifications` container. const className = this.container.replace(&#x27;.&#x27;, &#x27;&#x27;) const Notifications = Vue.extend(&#123; name: &#x27;Notifications&#x27;, render (h) &#123; return h(&#x27;div&#x27;, &#123; &#x27;class&#x27;: &#123; [`$&#123;className&#125;`]: true &#125; &#125;) &#125; &#125;) $parent = new Notifications().$mount() document.body.appendChild($parent.$el) &#125; else &#123; $parent = parent.__vue__ &#125; // Hacked. this.$_parent_ = $parent &#125;&#125;,mounted () &#123; if (this.$_parent_) &#123; this.$_parent_.$el.appendChild(this.$el) this.$parent = this.$_parent_ delete this.$_parent_ &#125;&#125;, document에서 container를 찾고 없을 경우 container를 생성 해서 body에 추가한다. 그리고 mounted에서 자신의 $el을 container에 추가한다. 이렇게 해서 의존성을 가지지 않고 추가할 수 있다. 그리고 &lt;transition appear&gt;를 이용해서 초기 랜더링에서 전환 효과를 주었다. 하지만 아직 수정사항은 존재한다.container를 프로퍼티로 넘겨받는데, 만약 container가 그냥 선언이 되어 있을 경우 위 코드는 재대로 동작하지 않는다.이유는 $parent = parent.__vue__ 에서 __vue__가 존재하지 않기 때문이다.Body가 아닌 컴포넌트 단위로 사용 하고 싶다면 다음과 같이 수정해서 사용할 수 있다. 1234567891011121314151617181920212223data() &#123; return &#123; $_el_: null &#125;&#125;,created() &#123; let $parent = this.$parent if (!$parent) &#123; let parent = document.querySelector(this.container) ... // Hacked. this.$_el_ = $parent ? $parent.$el : parent &#125;&#125;,mounted() &#123; if (this.$_el_) &#123; this.$_el_.appendChild(this.$el) &#125; if (this.$_parent_) &#123;- this.$_parent_.$el.appendChild(this.$el) ... &#125;&#125; 위와 같이 수정할 경우 컴포넌트에서 &lt;div class=&quot;container&quot;&gt;를 선언 하고 container로 .container를 넘긴다면, container 자식으로 계속 추가가 될 것이다. 이제 필요에 따라서 커스터마이징 하면 될 것 같다.","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"},{"name":"semantic-ui","slug":"semantic-ui","permalink":"https://gongzza.github.io/tags/semantic-ui/"},{"name":"toastr","slug":"toastr","permalink":"https://gongzza.github.io/tags/toastr/"}]},{"title":"Webpack Code Splitting - Using require.ensure","slug":"webpack/webpack-code-splitting-using-require-ensure","date":"2017-03-05T04:33:48.000Z","updated":"2021-02-21T13:41:51.342Z","comments":true,"path":"webpack/webpack-code-splitting-using-require-ensure/","link":"","permalink":"https://gongzza.github.io/webpack/webpack-code-splitting-using-require-ensure/","excerpt":"","text":"Webpack으로 번들링을 했는데 0.js가 생성이 되었다. 파일을 열어보니 비동기로 나중에 불러올려고 했던 컴포넌트들이었다. output.chunkFilename을 chunk.js로 설정하니 더이상 0.js는 생성되지 않았다. 하지만, 모든 비동기 컴포넌트들이 chunk.js하나로 번들링이되서 컴포넌트 별로 나누고 싶었다. 청크 이름을 지정할 수 있는 방법을 알아보니 require.ensure가 있었다. 1require.ensure(dependencies: String[], callback: function(require), chunkName: String) For example: 123require.ensure([], (require) =&gt; &#123; require(&#x27;./Home&#x27;)&#125;, &#x27;home&#x27;) 그리고 output.chunkFilename을 [name].js로 설정하니 번들링 할 때 home.js가 생성되었다. 참고 https://webpack.js.org/guides/code-splitting-require/","categories":[{"name":"Webpack","slug":"Webpack","permalink":"https://gongzza.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://gongzza.github.io/tags/webpack/"},{"name":"lazyload","slug":"lazyload","permalink":"https://gongzza.github.io/tags/lazyload/"}]},{"title":"Installing MySQL on Microsoft Windows Using a noinstall Zip Archive","slug":"install-mysql-on-windows","date":"2017-03-02T14:29:52.000Z","updated":"2021-02-21T09:19:03.614Z","comments":true,"path":"install-mysql-on-windows/","link":"","permalink":"https://gongzza.github.io/install-mysql-on-windows/","excerpt":"","text":"Windows10에서 MySQL을 설치하는 방법을 알아볼 것이다. MySQL은 5.7로 설치할 것이다.windows-install-archive를 참고하여 작성하였다. 목차 Download ZIP Archive Create an option file Initialize MySQL Start the MySQL server 1. Download Zip Archivehttps://dev.mysql.com/downloads/mysql/ 에서 다운로드 받으면 된다.download 버튼을 클릭하면 Login 하라고 나오는데, 당황하지 않고 밑에 No thanks, just start my download.를 클릭한다.다운로드가 완료되면 원하는 위치에 압축을 푼다.나는 C:\\mysql에 압축을 풀기로 했다. 그리고 시스템 환경 변수로 MYSQL_HOME에 c:\\mysql를 등록 하고 Path에 %MYSQL_HOME%\\bin을 등록한다. 시스템 환경 변수는 윈도우즈 실행(ctrl-r 또는 ctrl-s)에서 SystemPropertiesAdvanced를 실행한 후 환경 변수 버튼을 눌러서 들어간 다음 시스템 변수에 등록하면 된다. 2. Create an option filehttps://dev.mysql.com/doc/refman/5.7/en/windows-create-option-file.html먼저 my-default.ini파일을 my.ini으로 복사한다. 1$ cp my-default.ini my.ini 그리고 basedir과 port만 설정해 주면된다.MySQL에서 포트는 보통 3306을 사용한다.datadir은 설정하지 않으면 basedir/data로 설정된다. my.ini12345# These are commonly set, remove the # and set as required.basedir = &quot;c:/mysql&quot;# datadir = .....port = 3306# server_id = ..... 3. Initialize MySQLhttps://dev.mysql.com/doc/refman/5.7/en/data-directory-initialization-mysqld.htmlnoinstall로 설치했을 경우 data directory를 초기화 해주어야 한다.mysqld로 초기화를 하는데 두가지 옵션이 있다. --initialize은 root password를 랜덤으로 생성해준다. 생성된 패스워드는 로그를 통해서 확인할 수 있다. --initialize-insecure은 root password가 없다. 나는 root password 없이 초기화 하는 방법을 선택하였다.root password는 서버 실행 후 초기화 할 수 있다. 1$ mysqld --initialize-insecure 만약 data directory가 있을 경우 초기화는 실패한다. 1[ERROR] --initialize specified but the data directory exists. Aborting. 4. Start the MySQL serverhttps://dev.mysql.com/doc/refman/5.7/en/windows-start-command-line.html먼저 command line으로 서버를 실행해 보자. 1$ mysqld --console --console option은 windows only이며 stderr와 stdout을 콘솔에 그대로 보여준다.그래서 마지막에 다음과 같은 문구가 나온다면 정상적으로 실행된 것이다. 1Version: &#39;5.7.17&#39; socket: &#39;&#39; port: 3306 MySQL Community Server (GPL) ctrl-c를 눌러서 서버를 종료하고 서비스를 등록해보자.꼭 커맨드창을 관리자모드로 실행해야 한다. 123456$ mysqld --installService successfully installed.$ net start mysqlMySQL 서비스를 시작합니다.MySQL 서비스가 잘 시작되었습니다. 이제 root password를 설정할 수 있다. 123# `--initialize-insecure`로 초기화 했을 경우에만 가능하다.$ mysql -u root --skip-passwordmysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new_password&#x27;; exit 명령어로 빠져나온 다음 패스워드를 입력해서 로그인 해보자 1234$ mysql -u root -pEnter password: ************...mysql&gt; 패스워드 입력 프롬프트를 그냥 지나가고 싶은 경우 -pnew_password를 입력하면 되지만, 이렇게 할 경우 패스워드가 노출이 되기 때문에 매우 위험한 행동이다.","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://gongzza.github.io/tags/mysql/"},{"name":"install","slug":"install","permalink":"https://gongzza.github.io/tags/install/"}]},{"title":"Vue.js TodoMVC Template","slug":"vuejs/vuejs-todomvc-template","date":"2017-02-19T10:46:46.000Z","updated":"2021-02-21T13:41:51.340Z","comments":true,"path":"vuejs/vuejs-todomvc-template/","link":"","permalink":"https://gongzza.github.io/vuejs/vuejs-todomvc-template/","excerpt":"","text":"Todo앱은 가장 기본적인 기능인 CRUD를 가지고 있어서 언어를 공부 하고 제일 먼저 만들어 보면서 데이터 흐름을 파악할 수 있어서 좋다.이번에 Vue.js를 공부하면서 Todo앱을 만들어 볼려고 하다가 TodoMVC라는 이쁜 화면을 찾을 수 있었다.화면을 직접 만들면서 해도 좋지만, 처음에 로직에만 집중할 수 있어서 이 방법이 더 좋다고 생각한다. 그리고 화면도 이뻐서 개발하는 맛(?)도 좋다… Vue.js TodoMVC Example도 있어서 나중에 직접 만든 소스와 비교해 보면 좋은 공부가 될 것이라고 생각한다. 목적이번 포스팅에서는 Vue.js 개발 환경 구축과 TodoMVC 화면을 띄우는 작업을 할 것이다. 개발 환경 구축vue-cli를 이용해서 webpack-simple로 개발 환경을 구축 하였다.vue-cli가 없을 경우 $ npm install --global vue-cli로 설치한다. 다음은 vue-cli를 이용해서 webpack-simple로 프로젝트를 생성하는 과정이다.$ vue init webpack-simple todoapp으로 프로젝트를 생성한다. 위 화면 마지막에 나온 To get started:대로 명령어를 실행해서 패키지 설치 후 화면이 잘 나오는지 확인한다. 12345678# Change Directory todoapp$ cd todoapp# Install depedencies$ npm install# Run webpack dev server$ npm run dev TodoMVC templateTodoMVC 화면을 띄워보자. 먼저 todomvc-app-css를 설치한다. 1$ npm install --save-dev todomvc-app-css TodoMVC.vue를 추가한다.&lt;template&gt;는 todomvc.html의 내용을 붙여 넣는다.그리고 todomvc-app-css를 불러온다. src/components/TodoMVC.vue12345678910&lt;template&gt; ...&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;todo-mvc&#x27;&#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; src=&quot;todomvc-app-css/index.css&quot;&gt;&lt;/style&gt; 글로벌 컴포넌트로 todo-mvc를 등록한다. src/main.js1234...import TodoMVC from &#x27;./components/TodoMVC.vue&#x27;Vue.component(&#x27;todo-mvc&#x27;, TodoMVC)... App.vue에 todo-mvc컴포넌트를 추가한다. src/App.vue1234567891011&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;todo-mvc&gt;&lt;/todo-mvc&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;app&#x27;&#125;&lt;/script&gt; $ npm run dev로 화면을 띄우면 TodoMVC와 똑같은 화면을 볼 수 있다. 이제 TodoMVC와 똑같이 동작하도록 기능을 구현해 보자.","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"},{"name":"todomvc","slug":"todomvc","permalink":"https://gongzza.github.io/tags/todomvc/"}]},{"title":"Getting Started Laravel On Windows","slug":"php/laravel/getting-started-laravel-on-windows","date":"2017-02-03T09:03:21.000Z","updated":"2021-02-21T09:19:03.662Z","comments":true,"path":"php/laravel/getting-started-laravel-on-windows/","link":"","permalink":"https://gongzza.github.io/php/laravel/getting-started-laravel-on-windows/","excerpt":"","text":"Laracasts#Learn Vue 2: Step By Step을 보면서 Laravel을 한번 해보고 싶어 졌다. Windows8 64bit에서 작업을 진행 하였다. Laravel 은 PHP Framework이다. 그래서 PHP를 먼저 설치해 주어야 한다. InstallAPMSETUP을 사용하면 Apache + PHP + Mysql을 한방에 손쉽게 설치하고 관리할 수 있다.하지만 나는 PHP만 필요하기 때문에 사용하지 않았다. PHP먼저 자신의 CPU bit에 맞춰서 아래 사이트에서 다운로드 한다. http://windows.php.net/download/ 들어가보면 Thread Safe 와 Non Thread Safe 가 있는데,Thread Safe와 Non Thread Safe 차이점에서 확인하기 바란다.나는 VC14 x64 Non Thread Safe (2017-Jan-18 21:06:20) 를 받았다. 단순 zip파일이라서 원하는 곳에 압축을 풀면 된다. 압축을 풀고 실행이 잘 되는지 확인해 보자.나는 단순하게 c:\\php에 설치하였다. 1234c:\\php&gt;php -vPHP 7.1.1 (cli) (built: Jan 18 2017 18:38:28) ( NTS MSVC14 (Visual C++ 2015) x64 )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.1.0, Copyright (c) 1998-2017 Zend Technologies 위와 같이 나오면 된다. php.iniLaravel을 사용하기 위해서는 다음과 같이 필수요소를 갖춰야 한다. PHP &gt;= 5.6.4 OpenSSL PHP Extension PDO PHP Extension Mbstring PHP Extension Tokenizer PHP Extension XML PHP Extension 먼저 c:\\php 폴더에서 php.ini-development를 php.ini으로 복사한다. 그리고 다음과 같이 파일 내용을 수정한다. php.ini12345; On windows:extension_dir = &quot;ext&quot;...extension=php_mbstring.dllextension=php_openssl.dll mbstring과 openssl을 제외하고는 기본 내장인 것 같다. 자세한 사항은 php manual에서 찾아보기 바란다. ComposerComposer는 의존성 관리도구로 haruair님이 번역해주신 PHP 의존성 관리도구 – Composer 시작하기를 읽어보기 바란다. 이제 Composer를 설치한다. Composer-Setup.exe를 받는다. 설치를 진행하면 다음과 같이 php가 설치된 디렉토리를 자동으로 찾는다.못찾을 경우 Browse…를 눌러서 직접 php.exe를 지정해 주기 바란다. 그다음은 그냥 Next만 누르면 설치가 완료 된다. 설치가 완료되면 고맙게도 c:\\php를 PATH에 자동 등록해 준다. 이제 어디서든 php명령어를 사용할 수 있게 되었다. Laravel먼저 프로젝트를 생성한다. 123$ composer create-project --prefer-dist laravel&#x2F;laravel blogInstalling laravel&#x2F;laravel (v5.4.3)... 서버를 실행 시켜서 화면을 띄워보자. 123$ cd blog$ php artisan serveLaravel development server started on http:&#x2F;&#x2F;127.0.0.1:8000&#x2F; 위 URL로 접속해서 Laravel이 딱 보이면 정상적으로 서버가 실행된 것이다. 자세한 사항은 Laravel#Documentation를 읽어보기 바란다.","categories":[{"name":"PHP","slug":"PHP","permalink":"https://gongzza.github.io/categories/PHP/"},{"name":"Laravel","slug":"PHP/Laravel","permalink":"https://gongzza.github.io/categories/PHP/Laravel/"}],"tags":[{"name":"install","slug":"install","permalink":"https://gongzza.github.io/tags/install/"},{"name":"php","slug":"php","permalink":"https://gongzza.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://gongzza.github.io/tags/laravel/"}]},{"title":"Slack에 Hubot 붙이기","slug":"getting-started-hubot","date":"2017-01-27T09:51:36.000Z","updated":"2021-02-21T09:19:03.609Z","comments":true,"path":"getting-started-hubot/","link":"","permalink":"https://gongzza.github.io/getting-started-hubot/","excerpt":"","text":"Slack을 시작하면서 Github에서 만든 Hubot을 알게 되었다. 재미있을 것 같아서 한번 붙여보았다. 설치Hubot은 Yeoman위에서 돌아가는 generator-hubot이 있다.그래서 손쉽게 설치해서 시작할 수 있다. 1$ npm install -g yo generator-hubot hubot을 생성한다. Slack에서 이용할 것이라서 adapter를 slack으로 입력 했다.그러면 hubot-slack을 추가해서 설치해준다. 시작페키지까지 설치가 완료되었으니 한번 실행해 보자. &gt; my-bot ping을 날려서 PONG이 오면 정상 작동 하는 것이다. 하지만, 처음에 시작하면서 ERROR, WARNING, INFO가 올라온다.깨끗한 화면으로 시작하는 작업을 해보자. 먼저 어떤 패키지들이 사용되고 있는지 확인해 보자.hubot은 external-scripts.json에서 사용할 외부 스크립트들을 선언한다. external-scripts.json123456789101112[ &quot;hubot-diagnostics&quot;, &quot;hubot-help&quot;, &quot;hubot-heroku-keepalive&quot;, &quot;hubot-google-images&quot;, &quot;hubot-google-translate&quot;, &quot;hubot-pugme&quot;, &quot;hubot-maps&quot;, &quot;hubot-redis-brain&quot;, &quot;hubot-rules&quot;, &quot;hubot-shipit&quot;] 간단하게 하나씩 살펴보면서 필요여부를 확인해 보자. hubot-diagnostics: 간단한 기본기능들이 들어있다. 위에서 사용했던 ping을 이 모듈이 응답한 것이다. 그 외 time과 echo도 있다. hubot-help: 현재 hubot의 명령어들을 표시해준다. script들의 # Commands 들을 가져와서 뿌려주는 역할을 한다. hubot-pugme: 설명을 보면은 가장 중요한 휴봇 스크립트라고 적혀있다. 기능은 퍼그 이미지 url을 랜덤으로 가져오는 것이다. 하지만 2년이 지나서 그런지 url이 유효하지 않다. hubot-rules: hubot의 룰을 설명한다. &gt; hubot rules으로 볼 수 있다. hubot-shipit: 가지고 있는 이미지URL중 랜덤으로 하나를 보내준다. hubot-pugme와 마찬가지로 유효한 URL이 별로 없다. hubot-heroku-keepalive: 무료 heroku를 사용할 경우 하루 사용시간 제한이 있기 때문에 필요한 것 같다. hubot-redis-brain: hubot의 brain기능을 redis로 이용하는 것이다.hubot-google-images와 hubot-google-translate는 이름에서도 알 수 있듯이 구글의 API키를 받아서 구글 서비스를 사용할 때 필요하다.hubot-maps도 구글의 맵서비스를 이용하는 것이다. 나는 여기서 hubot-diagnostics과 hubot-help 그리고 hubot-rules를 제외하고 모두 삭제할 것이다. hubot-redis-brain은 나중에 필요할 때 다시 설치해서 사용할 생각이다. Uninstall depenencies1$ npm un -S hubot-heroku-keepalive hubot-google-images hubot-google-translate hubot-pugme hubot-maps hubot-redis-brain external-scripts.json도 꼭 수정해 주어야 한다. external-scripts.json12345[ &quot;hubot-diagnostics&quot;, &quot;hubot-help&quot;, &quot;hubot-rules&quot;] 그리고 hubot-scripts.json은 다음버전(3.0)에서 삭제될 것이라고 한다. 사용하지 않도록 한다. 1$ rm hubot-scripts.json hubot을 실행해보면 아무런경고 없이 실행되는 것을 볼 수 있다. Slack이제 슬랙에 추가해보자. 먼저 API_KEY를 받아야 한다. 슬랙의 오른쪽 상단에 설정 버튼을 누르고 Add an app or integration 버튼을 누른다. Hubot을 검색한다. Hubot을 설치한다. Hubot을 추가한다. Hubot API키를 저장한다. 위에서 발급받은 HUBOT_SLACK_TOKEN 을 이용해서 Slack에 접속하도록 해보자. 12$ HUBOT_SLACK_TOKEN=xoxb-~~ bin/hubot --adapter slack[Fri Jan 27 2017 18:00:06 GMT+0900 (KST)] INFO Slack client now connected 위와 같은 로그가 나왔다면 Slack에서 my-bot에 초록불이 들어왔을 것이다. 이제 명령어를 날려서 실제로 잘 동작하는지 확인해 보자. 먼저 Hubot을 채널로 초대를 한다. my-bot을 선택 후 Invite버튼을 누른다.남들에게 방해가 되지 않도록 #playground채널을 따로 만들어서 초대했다. 핑퐁으로 잘 동작하는지 확인한다. 핑퐁이 잘 오는것을 확인할 수 있다. 인사하기간단하게 my-bot이 켜질 때마다 인사를 하는 기능을 추가해보자. 파일 위에는 항상 tomdoc을 따르는 주석을 추가해주어야 한다.그리고 # Commands:부분을 입력하면 &gt; hubot help에 추가되어 나온다. scripts/greeting.coffee12345# Description:# Just greetingmodule.exports = (robot) -&gt; robot.adapter.client.web.chat.postMessage &#x27;#playground&#x27;, &#x27;안녕하세요 ~ 로봇입니다 ~&#x27; slack api methods중 chat.postMessage를 이용해서 #playground채널에 메시지를 보내고 있다.robot.messageRoom으로도 같은 파라메터로 같은 기능을 수행할 수 있다. 착한 로봇으로 키우기 위해서 인사를 먼저 가르쳐주었다. slack api methods를 모두 사용할 수는 없다.bot-users에서 API Usage를 보면 App bots로 사용 가능한 method가 체크되어있으니 확인하고 사용하기 바란다. 데몬으로 실행하기만약 heroku를 사용하지 않고 Linux에서 돌릴경우 다음 명령어로 간단하게 사용할 수 있다. 1$ HUBOT_SLACK_TOKEN=xoxb-~~ nohup bin/hubot --adapter slack &amp; 꼭 my-bot 디렉토리에 들어가서 실행 해야 한다.bin/hubot을 확인해보면 PATH에 node_modules를 상대 경로로 추가하기 때문에 다른 디렉토리에서 실행하면 실행파일을 찾을 수 없기 때문이다. 절대 경로와 상대경로의 차이점은 여기에서 확인하기 바란다. 마치며Hubot의 활용도는 서버 관리나 프로젝트 관리에서 빛을 발할 것 같다.서버에 명령을 직접 내릴 수 있는 만큼 크리티컬한 영향을 줄 수 있으니 안전범위 내에서 잘 사용하기 바란다.그리고 외부의 변화를 감시해서 바로 알려줄 수 있기 때문에 좋은 것 같다. 제일 좋은 점은 재미있는 요소가 많은 것 같다. 핑퐁만해도 왠지 재미있다. ㅎㅎ 또 다른 재미있는 요소가 생기면 알려주기 바란다.","categories":[],"tags":[{"name":"hubot","slug":"hubot","permalink":"https://gongzza.github.io/tags/hubot/"},{"name":"slack","slug":"slack","permalink":"https://gongzza.github.io/tags/slack/"}]},{"title":"Yeoman generator 따라하기 - 3","slug":"yeoman/generator-v-3","date":"2017-01-16T13:07:27.000Z","updated":"2021-02-21T13:41:51.343Z","comments":true,"path":"yeoman/generator-v-3/","link":"","permalink":"https://gongzza.github.io/yeoman/generator-v-3/","excerpt":"","text":"이전 포스팅 Yeoman generator 따라하기 - 2 이번에는 사용자로부터 정보를 입력받아서 설정 정보를 저장하는 작업을 할 것이다. Yeoman#User Interactions를 참조하면서 만들 것이다. 그리고 이제부터는 babel을 이용한 es6문법을 사용할 것이다.Yeoman generator with babel을 참고하기 바란다. Prompts프롬프트 모듈은 내부적으로 Inquirer.js를 사용한다고 한다. 먼저 프롬프트로 앱이름을 입력받는 테스트를 작성한다. test/specs/app.spec.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import helper from &#x27;yeoman-test&#x27;import assert from &#x27;yeoman-assert&#x27;import path from &#x27;path&#x27;const target = &#x27;app&#x27;describe(target, () =&gt; &#123; const _generator = path.resolve(__dirname, &#x27;../..&#x27;, &#x27;generators&#x27;, target, &#x27;index.es6&#x27;) describe(&#x27;with prompts&#x27;, () =&gt; &#123; var gen const props = &#123; srcPath: &#x27;src&#x27;, testSpecPath: &#x27;test/spec&#x27; &#125; beforeEach(() =&gt; &#123; return helper.run(_generator) .withPrompts(props) .on(&#x27;ready&#x27;, (_gen) =&gt; &#123; gen = _gen &#125;) &#125;) it(&#x27;works with props&#x27;, () =&gt; &#123; assert.deepEqual(gen.props, props) &#125;) &#125;) describe(&#x27;without prompts&#x27;, () =&gt; &#123; var gen const props = &#123; srcPath: &#x27;./app/src&#x27;, testSpecPath: &#x27;./test/specs&#x27; &#125; beforeEach(() =&gt; &#123; return helper.run(_generator) .on(&#x27;ready&#x27;, (_gen) =&gt; &#123; gen = _gen &#125;) &#125;) it(&#x27;defaults&#x27;, () =&gt; &#123; assert.deepEqual(gen.props, props) &#125;) &#125;)&#125;) 디폴트값을 확인하기 위해 prompts가 있을 때와 없을 때를 테스트 하는 코드를 작성하였다. 이제 generators/app/index.es6를 작성한다. generators/app/index.es612345678910111213141516171819202122232425262728293031import Generator from &#x27;yeoman-generator&#x27;class AppGenerator extends Generator &#123; initializing() &#123; // prompts를 저장한다. this.props = &#123;&#125; &#125; prompting() &#123; const questions = [ &#123; type: &#x27;input&#x27;, name: &#x27;srcPath&#x27;, message: &#x27;Your source path?&#x27;, default: &#x27;./app/src&#x27; &#125;, &#123; type: &#x27;input&#x27;, name: &#x27;testSpecPath&#x27;, message: &#x27;Your test specs path?&#x27;, default: &#x27;./test/specs&#x27; &#125; ] return this.prompt(questions) .then((answers) =&gt; &#123; this.props = answers &#125;) &#125;&#125;module.exports = AppGenerator 테스트로 확인해 보자 12345678$ npm test app with prompts ✓ works with props without prompts ✓ works with defaults 4 passing (70ms) 잘 통과하는 것을 확인할 수 있다. Storing user configs사용자 정보를 입력받을 준비가 되었으니 잃어버리지 않도록 저장하는 방법을 알아보자. 설정 저장은 configuring() 메소드에서 작성한다. 메소드 우선순위는 Yeoman#Running Context에서 확인하면 된다. 마찬가지로 테스트를 먼저 작성한다. test/specs/app.spec.js12345678910111213141516describe(target, () =&gt; &#123; describe(&#x27;with prompts&#x27;, () =&gt; &#123; ... it(&#x27;saved configs&#x27;, () =&gt; &#123; const configs = gen.config.getAll() assert.deepEqual(configs, props) &#125;) &#125;) describe(&#x27;without prompts&#x27;, () =&gt; &#123; ... it(&#x27;saved configs&#x27;, () =&gt; &#123; const configs = gen.config.getAll() assert.deepEqual(configs, props) &#125;) &#125;)&#125;) 테스트를 실행해 보면 빈 오브젝트만 있을 것이다. 제너레이터를 작성해 보자. generators/app/index.es612345678class AppGenerator extends Generator &#123; ... configuring() &#123; for (let key of Object.keys(this.props)) &#123; this.config.set(key, this.props[key]) &#125; &#125;&#125; prompting()에서 입력받은 모든 key, value를 저장하도록 작성하였다. 저장된 정보는 .yo-rc.json에 저장 된다. 이제 언제든지 사용자 설정 정보를 불러와서 사용할 수 있게 되었다. Yeoman#Storage에서 좀 더 자세한 설명을 볼 수 있다. 지금까지 알아본 기술들로 generator-v를 개발할 것이다. 완성된 소스코드는 generator-v에서 확인할 수 있다.","categories":[{"name":"Yeoman","slug":"Yeoman","permalink":"https://gongzza.github.io/categories/Yeoman/"}],"tags":[{"name":"yeoman-generator","slug":"yeoman-generator","permalink":"https://gongzza.github.io/tags/yeoman-generator/"},{"name":"generator-v","slug":"generator-v","permalink":"https://gongzza.github.io/tags/generator-v/"}]},{"title":"Yeoman generator with babel","slug":"yeoman/yeoman-with-babel","date":"2017-01-15T03:11:34.000Z","updated":"2021-02-21T13:41:51.344Z","comments":true,"path":"yeoman/yeoman-with-babel/","link":"","permalink":"https://gongzza.github.io/yeoman/yeoman-with-babel/","excerpt":"","text":"이번 포스팅은 Yeoman generator 따라하기를 진행 하다가es6문법을 적용하고 싶어서 babel을 적용하는 과정을 다루게 되었다. Install뭐든지 설치가 먼저인듯 하다. Install1$ npm install --save-dev babel-cli babel-core babel-register babel-preset-es2015 babel-preset-es2015를 설치하면 es6문법들을 한방에 적용할 수 있다. 다음으로 .babelrc를 만들어 줘야 한다. .babelrc123&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; 자세한 설정 사항은 babeljs.io에서 확인하자. 이제 es6 문법을 사용할 수 있는 상황이 되었다. Usage사용하는 방법을 알아보자. 테스트에서도 babel을 사용하기 위해서는 package.json에서 test script를 수정해야 한다. package.json123456&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;npm run test:base test/specs/**/*.js&quot;, &quot;test:base&quot;: &quot;mocha -R spec --compilers js:babel-register&quot; &#125;&#125; 테스트를 만들어 보자. test/app.spec.js12345678910111213141516171819import helper from &#x27;yeoman-test&#x27;import assert from &#x27;yeoman-assert&#x27;import path from &#x27;path&#x27;describe(&#x27;app&#x27;, () =&gt; &#123; const generator = path.resolve(&#x27;generators&#x27;, &#x27;app&#x27;) const name = &#x27;mock&#x27; beforeEach(() =&gt; &#123; return helper.run(generator) .withArguments([name]) &#125;) it(&#x27;create file with content&#x27;, () =&gt; &#123; const destfile = path.join(&#x27;src&#x27;, name + &#x27;.vue&#x27;) assert.file([destfile]) assert.fileContent(destfile, name) &#125;)&#125;) 테스트를 실행해 보면 잘 통과하는 것을 확인할 수 있다. 제너레이터를 es6문법으로 바꾸기전 주의사항이 있다. yeoman은 index.js를 호출 한다. 그래서 index.js로 작업을 하게 될 경우 node.js에서 es6문법을 모두 해석하지 못하기 때문에 babel로 컴파일된 index.js를 사용해야 한다. 그래서 우리는 index.es6로 작업 후 컴파일을 해서 index.js로 저장 할 것이다.꼭 배포 전에 babel로 컴파일을 해주어야 한다. 만약 git을 사용한다면 .git/hooks에서 pre-commit을 사용해서 커밋 전에 자동으로 컴파일된 소스를 추가할 수 있다. .git/hooks디렉토리에 pre-commit.sample이 있으면 pre-commit으로 복사 후 사용한다. 12345$ cd .git/hooks/$ cp pre-commit.sample pre-commit$ vi pre-commitnpm run buildgit add generators/*/index.js 위 명령을 추가해준다. 빌드 스크립트도 추가해준다. package.json12345&#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;babel generators/*/index.es6 -d .&quot; &#125;&#125; 이제 제너레이터도 es6문법으로 바꿔 보도록 하자. generators/app/index.es61234567891011121314151617181920212223242526272829303132import Generator from &#x27;yeoman-generator&#x27;import path from &#x27;path&#x27;class AppGenerator extends Generator &#123; // The name `constructor` is important here constructor(args, opts) &#123; super(args, opts) try &#123; // name을 필수로 받도록 처리 this.argument(&#x27;name&#x27;, &#123; type: String, required: true &#125;) &#125; catch(err) &#123; this.log.error(&#x27;Usage: yo v name&#x27;) process.exit(1) &#125; &#125; initializing() &#123; // 생성 될 스크립트확장자 this.options.suffixScript = &#x27;.vue&#x27; &#125; writing() &#123; const filename = this.options.name + this.options.suffixScript this.fs.copyTpl( this.templatePath(&#x27;Vue.vue&#x27;), this.destinationPath(path.join(&#x27;src&#x27;, filename)), &#123; name: this.options.name&#125; ) &#125;&#125;module.exports = AppGenerator 테스트 코드에서 index.es6를 불러오도록 수정한다. test/app.spec.js1234describe(&#x27;app&#x27;, () =&gt; &#123; const generator = path.resolve(&#x27;generators&#x27;, &#x27;app&#x27;, &#x27;index.es6&#x27;) ...&#125;) 테스트를 실행해 보면 잘 통과 하는 것을 볼 수 있다. 이제 직접 사용해 보기 위해서 컴파일을 수행하자. 12$ npm run buildgenerators/app/index.es6 -&gt; generators/app/index.js 제너레이터를 사용해 보자. 12$ yo v Appcreate src/App.vue es6문법이 잘 적용된 것을 확인할 수 있다.","categories":[{"name":"Yeoman","slug":"Yeoman","permalink":"https://gongzza.github.io/categories/Yeoman/"}],"tags":[{"name":"yeoman-generator","slug":"yeoman-generator","permalink":"https://gongzza.github.io/tags/yeoman-generator/"},{"name":"babel","slug":"babel","permalink":"https://gongzza.github.io/tags/babel/"}]},{"title":"Yeoman generator 따라하기 - 2","slug":"yeoman/generator-v-2","date":"2017-01-13T12:00:24.000Z","updated":"2021-02-21T13:41:51.343Z","comments":true,"path":"yeoman/generator-v-2/","link":"","permalink":"https://gongzza.github.io/yeoman/generator-v-2/","excerpt":"","text":"Yeoman generator 따라하기 - 1 이번에는 테스트 코드를 만들고 테스트 코드를 통과하는 코드를 만드는 작업을 할 것이다. 저번과 마찬가지로 Yoeman#Unit testing을 참조하면서 진행하였다. Getting Started With Mocha먼저 테스트 환경을 구성한다. 테스트 프레임워크로 Mocha를 사용할 것이다. Install12# test runner$ npm install --save-dev mocha package.json에서 test script를 변경한다. package.json1234567&#123; ... &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha&quot; &#125; ...&#125; 테스트를 작성한다. test/test.js12345678var assert = require(&#x27;assert&#x27;);describe(&#x27;Array&#x27;, function() &#123; describe(&#x27;#indexOf()&#x27;, function() &#123; it(&#x27;should return -1 when the value is not present&#x27;, function() &#123; assert.equal(-1, [1,2,3].indexOf(4)); &#125;); &#125;);&#125;); 테스트를 해보자 123456$ npm testArray #indexOf() ✓ should return -1 when the value is not present1 passing (9ms) Test Yeoman제너레이터를 테스트하기전에 필요한 모듈이 있다. install12# yeoman test helper and assertion$ npm install --save-dev yeoman-test yeoman-assert yeoman-test는 내가 만든 제너레이터를 실행해 주는 역할을 한다.옵션이나 인수들을 마음대로 넣을 수 있다. yeoman-assert는 내가 만든 제너레이터가 잘 동작 했는지 검사한다. 정말 간단한 테스트 코드를 만들어 보자. test/app.spec.js123456789101112131415161718var helper = require(&#x27;yeoman-test&#x27;)var assert = require(&#x27;yeoman-assert&#x27;)var path = require(&#x27;path&#x27;)describe(&#x27;app&#x27;, () =&gt; &#123; const name = &#x27;mock&#x27; const destFile = path.join(&#x27;src&#x27;, name + &#x27;.vue&#x27;) beforeEach(() =&gt; &#123; return helper.run(path.join(__dirname, &#x27;../generators/app&#x27;)) .withArguments([name]) &#125;) it(&#x27;create file with content&#x27;, () =&gt; &#123; assert.file([destFile]) assert.fileContent(destFile, name) &#125;)&#125;) 위 코드는 다음을 검증한다. $ yo v mock 명령을 실행 한다. 파일이 원하는 위치와 이름으로 생성 되는지 확인한다. 파일안에 파일명이 있는지 확인한다. 일단 한번 돌려 보자. 1234567891011121314151617181920212223$ npm testappmethod 1 just ranmethod 2 just ran 1) create file with content0 passing (156ms)1 failing1) app create file with content: AssertionError: src\\mock.vue, no such file or directory + expected - actual -false +true at node_modules\\yeoman-assert\\index.js:46:12 at Array.forEach (native) at Function.assert.file (node_modules\\yeoman-assert\\index.js:44:8) at Context.it (test\\app.spec.js:15:12)npm ERR! Test failed. See above for more details. 앞으로 자주 보게될 화면이다. 이제 개발을 시작해 보자 generators/app/index.js1234567891011121314151617181920var Generator = require(&#x27;yeoman-generator&#x27;)var path = require(&#x27;path&#x27;)module.exports = class extends Generator &#123; constructor(args, opts) &#123; super(args, opts) // name을 필수로 받도록 처리 this.argument(&#x27;name&#x27;, &#123; type: String, required: true &#125;) // 생성 될 스크립트확장자 this.options.suffixScript = &#x27;.vue&#x27; &#125; writeing() &#123; const filename = this.options.name + this.options.suffixScript this.fs.copyTpl( this.templatePath(&#x27;Vue.vue&#x27;), this.destinationPath(path.join(&#x27;src&#x27;, this.options.name + &#x27;.vue&#x27;)), &#123; name: this.options.name &#125; ) &#125;&#125; 이제 템플릿을 만들어 보자 generators/app/templates/Vue.vue1&lt;%= name %&gt; 정말 간단하게 파라메터로 넘어온 name을 그냥 뿌려주기만 한다. 테스트를 해보자 12345$ npm testapp ✓ create file with content1 passing (173ms) 테스트를 통과했으니 실제로 사용해 보자. 12345$ yo v app create src/App.vue$ cat src/App.vueApp 정확히 의도한 대로 개발이 되었다. 이제는 template을 만들고 그대로 원하는 위치에 파일을 복사 할 수 있는 수준이 되었다. 다음 포스팅에서는 사용자로부터 정보를 입력받는 기능과 설정 정보를 저장하는 방법을 알아 볼 것이다.","categories":[{"name":"Yeoman","slug":"Yeoman","permalink":"https://gongzza.github.io/categories/Yeoman/"}],"tags":[{"name":"mocha","slug":"mocha","permalink":"https://gongzza.github.io/tags/mocha/"},{"name":"yeoman-generator","slug":"yeoman-generator","permalink":"https://gongzza.github.io/tags/yeoman-generator/"},{"name":"generator-v","slug":"generator-v","permalink":"https://gongzza.github.io/tags/generator-v/"}]},{"title":"Yeoman generator 따라하기 - 1","slug":"yeoman/generator-v-1","date":"2017-01-11T05:00:00.000Z","updated":"2021-02-21T13:41:51.343Z","comments":true,"path":"yeoman/generator-v-1/","link":"","permalink":"https://gongzza.github.io/yeoman/generator-v-1/","excerpt":"","text":"요즘 한창 vue.js를 공부중이다. 그래서 매번 컴포넌트를 만들기 귀찮아서 제너레이터를 만들려고 한다. 제너레이터를 직접 만들면 좋은 점이 많다.원하는 위치에 원하는 탬플릿을 가공해서 생성할 수 있기 때문이다.그리고 yeoman-generator를 사용하면 후 처리 작업도 가능하다.(예를 들어 index.html 파일에 script tag 추가) 처음이 어렵지 한번 만들고 나면 다음부터는 복붙 아니겠는가? Yeoman - Creating a generator를 보면서 작업을 진행할 계획이다.yeoman의 version은 1.0.1로 작업 하였다. 제너레이터 이름은 generator-v이다. Getting started기본적으로 npm install --global yo는 설치 하고 시작하자. Setting먼저 package.json을 생성한다.npm init -y명령으로 간단하게 생성할 수 있다. package.json1234567891011121314151617181920&#123; &quot;name&quot;: &quot;generator-v&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;yeoman generator for vue.js&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/gongzza/generator-v.git&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;https://github.com/gongzza/generator-v/issues&quot; &#125;, &quot;homepage&quot;: &quot;https://github.com/gongzza/generator-v#readme&quot;&#125; name은 반듯이 generator-로 시작해야 한다.뒤에 따라오는 v는 나중에 yo v으로 사용 된다. 가장 중요한 yeoman-generator를 설치한다. Install1$ npm install --save yeoman-generator Folder tree기본적으로 yo name은 generators/app/index.js를 호출한다.좀 더 새분화를 시키고 싶으면, 폴더를 추가하면 된다.예를 들어 yo name:component는 generators/component/index.js를 호출한다. 123456├─package.json└─generators&#x2F; ├─app&#x2F; │ └─index.js └─component&#x2F; └─index.js 사실 generators에 넣지 않아도 된다. 12345├─package.json├─app&#x2F;│ └─index.js└─component&#x2F; └─index.js 이렇게 구조를 잡아도 위에서 실행 했던 명령어는 이전과 똑같이 실행 된다. Extending generator이제 제너레이터를 만들어 보자. 기본적으로 yeoman-generator를 확장해서 만들게 된다. generators/app.js123var Generator = require(&#x27;yeoman-generator&#x27;)module.exports = class extends Generator&#123;&#125; 여기서 주의해야 할 부분이 있다.ECMAScript2015부터 적용된 class 문법이다.class이다 보니 생성자가 있다. generators/app.js12345678910module.exports = class extends Generator &#123; // The name `constructor` is important here constructor(args, opts) &#123; // Calling the super constructor is important so our generator is correctly set up super(args, opts); // Next, add your custom code this.option(&#x27;babel&#x27;); // This method adds support for a `--babel` flag &#125;&#125;; 생성자는 구지 만들지 않아도 되지만, 만약 만든다면 부모 생성자를 꼭 호출해 주어야 한다. (args와 opts도 같이) Adding your own functionality이제 메소드를 만들어 보자 es6문법대로 메소드를 추가하면 된다. generators/app.js123456789module.exports = class extends Generator &#123; method1() &#123; console.log(&#x27;method 1 just ran&#x27;); &#125; method2() &#123; console.log(&#x27;method 2 just ran&#x27;); &#125;&#125;; 위에서 봤던 생성자(constructor)처럼 메소드도 우선순위가 정해진 예약어가 존재한다. 123456781. initializing - 초기화2. prompting - 사용자로부터 대화식으로 옵션을 받는 프롬프트 생성3. configuring - 설정 저장4. default - 기본 그룹5. writing - 파일 생성6. conflicts - 충돌 해결7. install - 설치 실행8. end - 클린업 등등.. 위 예약어에 속하지 않은 메소드들은 모두 4. default그룹에 속하게 되고 작성된 순서대로 호출이 된다.위 규칙을 따르지 않아도 되지만, 따라서 하는 것이 유지보수에 더 좋을 것 같다. Running the generator만든 generator를 global 모듈 디렉토리에 링크를 걸어줘야 한다.(global 모듈 디렉토리는 $npm config get prefix으로 알 수 있다.) 다음 명령으로 간단하게 링크를 걸 수 있다. 1$ npm link 콘솔이 잘 나오는지 실행해서 확인해 보자 123$ yo vmethod 1 just ranmethod 2 just ran 다음 포스팅에서는 탬플릿을 만들고 테스트를 하겠다. Yeoman generator 따라하기 - 2","categories":[{"name":"Yeoman","slug":"Yeoman","permalink":"https://gongzza.github.io/categories/Yeoman/"}],"tags":[{"name":"yeoman-generator","slug":"yeoman-generator","permalink":"https://gongzza.github.io/tags/yeoman-generator/"},{"name":"generator-v","slug":"generator-v","permalink":"https://gongzza.github.io/tags/generator-v/"}]},{"title":"webpack2에 eslint 붙이기","slug":"webpack/webpack2-add-eslint","date":"2017-01-10T10:42:44.000Z","updated":"2021-02-21T13:41:51.342Z","comments":true,"path":"webpack/webpack2-add-eslint/","link":"","permalink":"https://gongzza.github.io/webpack/webpack2-add-eslint/","excerpt":"","text":"Webpack2에 ESLint를 붙이는 작업을 할 것이다. 목차 Install Configuration Webpack2 ESLint Linting1. InstallInstall12345# install webpack 2$ npm install --save-dev webpack@2.2.0-rc.3# install eslint$ npm install --save-dev eslint eslint-loader eslint-plugin-promise webpack2 버전을 최신으로 확인 후 설치하자 2. Configuration Webpack2Webpack#Configuration에서 설정 정보를 확인하면서 추가한다. webpack.config.js1234567891011121314151617181920var path = require(&#x27;path&#x27;)module.exports = &#123; entry: &#x27;./src/app.js&#x27;, output: &#123; path: path.resolve(__dirname, &#x27;./dist&#x27;), publicPath: &#x27;/dist/&#x27;, filename: &#x27;build.js&#x27; &#125;, module: &#123; rules: [ &#123; enforce: &#x27;pre&#x27;, test: /\\.js$/, loader: &#x27;eslint-loader&#x27;, exclude: /node_modules/ &#125; ] &#125;&#125; ESLintESLint 설정은 질문형식으로 설정이 가능하다. 파일 내용은 다음과 같다 .eslintrc.js123456789101112131415161718192021222324module.exports = &#123; &quot;env&quot;: &#123; &quot;browser&quot;: true &#125;, &quot;extends&quot;: &quot;eslint:recommended&quot;, &quot;rules&quot;: &#123; &quot;indent&quot;: [ &quot;error&quot;, &quot;tab&quot; ], &quot;linebreak-style&quot;: [ &quot;error&quot;, &quot;unix&quot; ], &quot;quotes&quot;: [ &quot;error&quot;, &quot;double&quot; ], &quot;semi&quot;: [ &quot;error&quot;, &quot;always&quot; ] &#125;&#125;; 3. Linting이제 검사할 javascript를 간단하게 작성해보자. src/app.js12345function greeting(name) &#123; console.log(&#x27;Hi!&#x27;,name)&#125;greeting(&#x27;gongzza&#x27;) 코드도 준비 되었으니 검사를 해보자. 12345678910111213141516171819$ .&#x2F;node_modules&#x2F;webpack&#x2F;bin&#x2F;webpack.jsHash: 515b6952888bca5fe93fVersion: webpack 2.2.0-rc.3Time: 514ms Asset Size Chunks Chunk Namesbuild.js 2.59 kB 0 [emitted] main [0] .&#x2F;src&#x2F;app.js 75 bytes &#123;0&#125; [built] [1 error]ERROR in .&#x2F;src&#x2F;app.js&#x2F;Users&#x2F;GongZza&#x2F;study&#x2F;webpack&#x2F;eslint&#x2F;src&#x2F;app.js 2:3 error Expected indentation of 1 tab but found 2 spaces indent 2:3 error Unexpected console statement no-console 2:15 error Strings must use doublequote quotes 2:26 error Missing semicolon semi 5:10 error Strings must use doublequote quotes 5:20 error Missing semicolon semi✖ 6 problems (6 errors, 0 warnings) …6개나 된다… 우선 indent는 편집기에 따라서 수정해주면 된다.나는 편집기에서 tab을 space2로 사용하고 있어서 에러로 잡힌 것이다.설정 파일에서 “tab”을 space 숫자로 바꿔준다.(에러가 없을 경우 그대로 두면 된다.) semi는 구문마다 세미콜론을 찍어주면 된다. 생각해보니 나는 singlequote를 사용한다.그래서 설정파일을 수정해서 모든 파일에 적용 되도록 하겠다. no-console은 주석을 이용해서 특정 부분만 비활성화 하는 방법을 적용하겠다. ESLint#Disabling Rules with Inline Comments Comments에서 주석으로 비활성화 하는 방법들을 볼 수 있다. 수정된 코드를 확인해 보자 .eslintrc.js12345678910111213module.exports = &#123; ... &quot;rules&quot;: &#123; &quot;indent&quot;: [ &quot;error&quot; 2 ], &quot;quotes&quot;: [ &quot;error&quot;, &quot;single&quot; ] &#125;&#125; src/app.js1234567/* eslint-disable no-console */function greeting(name) &#123; console.log(&#x27;Hi!&#x27;,name);&#125;/* eslint-enable no-console */greeting(&#x27;gongzza&#x27;); /* eslint-disable */ 로 비활성화를 할 경우 그 라인부터 밑으로 /* eslint-enable */ 를 만나기 전까지 적용 된다 다시 확인해 보자 webpack1234567$ ./node_modules/webpack/bin/webpack.jsHash: b2464e0380957923b228Version: webpack 2.2.0-rc.3Time: 410ms Asset Size Chunks Chunk Namesbuild.js 2.65 kB 0 [emitted] main [0] ./src/app.js 140 bytes &#123;0&#125; [built] 아무런 에러없이 잘 통과하는 것을 볼 수 있다.","categories":[{"name":"Webpack","slug":"Webpack","permalink":"https://gongzza.github.io/categories/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://gongzza.github.io/tags/webpack/"},{"name":"eslint","slug":"eslint","permalink":"https://gongzza.github.io/tags/eslint/"}]},{"title":"Linux에서 PhantomJS 설치하기","slug":"linux/install/phantomjs","date":"2017-01-06T02:14:50.000Z","updated":"2021-02-21T09:19:03.654Z","comments":true,"path":"linux/install/phantomjs/","link":"","permalink":"https://gongzza.github.io/linux/install/phantomjs/","excerpt":"","text":"목차 필수 설치 설치 실행 ### 1. 필수 설치 - Node.js 패키지 매니저로 Node.js 설치하기에 들어가보면친절하게 OS별로 자세하게 정리 되어 있다. ### 2. 설치 ##### 1차 시도 123$ npm install --global phantomjsPhantom installation failed &#123; Error: Command failed: tar jxf /usr/lib/node_modules/phantomjs/phantomjs/phantomjs-2.1.1-linux-x86_64.tar.bz2tar (child): bzip2: Cannot exec: 그런 파일이나 디렉터리가 없습니다. bzip2가 필요한가 보다. `yum`으로 설치해 주자. 1$ yum install -y bzip2 2차 시도12$ npm install --global phantomjsDone. Phantomjs binary available at /usr/lib/node_modules/phantomjs/lib/phantom/bin/phantomjs 설치가 완료 되었다. 3. 실행 그럼 이제 설치가 잘 되었는지 확인하기 위해서 실행해보자. 12$ phantomjs/usr/lib/node_modules/phantomjs/lib/phantom/bin/phantomjs: error while loading shared libraries: libfontconfig.so.1: cannot open shared object file: No such file or directory 이건 도대체 뭔가… 다운로드 사이트에 들어가서 linux 64-bit를 보니fontconfig 또는 libfontconfig가 필요하다고 적혀있다. 당황하지 않고 설치해준다. 12345# CentOS$ yum install -y fontconfig# Debian, Ubuntu$ sudo apt-get install libfontconfig 필요한 라이브러리를 설치 후 실행해 보니 잘 되는 것을 확인할 수 있다. 12$ phantomjsphantomjs&gt;_","categories":[{"name":"Linux","slug":"Linux","permalink":"https://gongzza.github.io/categories/Linux/"},{"name":"Install","slug":"Linux/Install","permalink":"https://gongzza.github.io/categories/Linux/Install/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://gongzza.github.io/tags/javascript/"},{"name":"phantomjs","slug":"phantomjs","permalink":"https://gongzza.github.io/tags/phantomjs/"}]},{"title":"CentOS 7에서 Java JDK 설치방법 및 환경변수 설정","slug":"linux/install/java","date":"2017-01-04T02:14:50.000Z","updated":"2021-02-21T09:19:03.654Z","comments":true,"path":"linux/install/java/","link":"","permalink":"https://gongzza.github.io/linux/install/java/","excerpt":"","text":"CentOS를 minimal로 설치 후 JDK를 설치 하는 방법을 소개 한다. 목차 필수 설치 다운로드 설치 명령어 등록 환경변수 설정 확인참고1. 필수 설치 wget CentOS7을 minimal로 설치하면 자주 사용하는 라이브러리도 없을 때가 있다.그 중 하나가 wget 이다. 가볍게 yum으로 설치해 주자. 1yum install -y wget 2. 다운로드다운로드 페이지 접속 후 아래의 이미지를 클릭 하면 최신 jdk 목록을 볼 수 있다. 약관에 동의 하야 링크 들을 볼 수 있다. 링크를 복사 후 아래의 명령어에서 맨 뒤에 URL만 바꾸면 최신 버전을 받을 수 있다. 1wget --no-check-certificate --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.tar.gz cpu bit를 확인 후 받도록 하자. 3. 설치설치 할 디렉토리는 마음대로 정하면 된다. 12345678# 디렉토리 생성mkdir /usr/local/java# 파일 이동mv jdk-8u112-linux-x64.tar.gz /usr/local/java#압축 해제tar xvzf jdk-8u112-linux-x64.tar.gz 4. 명령어 등록1234567alternatives --install /usr/bin/java java /usr/local/java/jdk1.8.0_112/bin/java 1alternatives --install /usr/bin/java javac /usr/local/java/jdk1.8.0_112/bin/javac 1alternatives --install /usr/bin/java javaws /usr/local/java/jdk1.8.0_112/bin/javaws 1alternatives --set java /usr/local/java/jdk1.8.0_112/bin/javaalternatives --set javac /usr/local/java/jdk1.8.0_112/bin/javacalternatives --set javaws /usr/local/java/jdk1.8.0_112/bin/javaws 5. 환경변수 설정123456$ vi /etc/profile...export JAVA_HOME=$(readlink -f /usr/bin/java | sed &quot;s:bin/java::&quot;)# 현재 쉘에 적용$ . /etc/profile 6. 확인1234$ java -versionjava version &quot;1.8.0_112&quot;Java(TM) SE Runtime Environment (build 1.8.0_112-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode) 참고 CentOS에 wget을 이용하여 JDK1.7 RPM 다운로드 후 설치하기 리눅스에 Java 다운로드해서 설치하기","categories":[{"name":"Linux","slug":"Linux","permalink":"https://gongzza.github.io/categories/Linux/"},{"name":"Install","slug":"Linux/Install","permalink":"https://gongzza.github.io/categories/Linux/Install/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://gongzza.github.io/tags/linux/"},{"name":"java","slug":"java","permalink":"https://gongzza.github.io/tags/java/"},{"name":"wget","slug":"wget","permalink":"https://gongzza.github.io/tags/wget/"}]}],"categories":[{"name":"VSCode","slug":"VSCode","permalink":"https://gongzza.github.io/categories/VSCode/"},{"name":"Mac","slug":"Mac","permalink":"https://gongzza.github.io/categories/Mac/"},{"name":"Database","slug":"Database","permalink":"https://gongzza.github.io/categories/Database/"},{"name":"Typescript","slug":"Typescript","permalink":"https://gongzza.github.io/categories/Typescript/"},{"name":"Nuxt.js","slug":"Nuxt-js","permalink":"https://gongzza.github.io/categories/Nuxt-js/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://gongzza.github.io/categories/GraphQL/"},{"name":"Docker","slug":"Docker","permalink":"https://gongzza.github.io/categories/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://gongzza.github.io/categories/Linux/"},{"name":"Java","slug":"Java","permalink":"https://gongzza.github.io/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://gongzza.github.io/categories/Java/Spring/"},{"name":"Node.js","slug":"Node-js","permalink":"https://gongzza.github.io/categories/Node-js/"},{"name":"AdonisJs","slug":"Node-js/AdonisJs","permalink":"https://gongzza.github.io/categories/Node-js/AdonisJs/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://gongzza.github.io/categories/Vue-js/"},{"name":"Express","slug":"Node-js/Express","permalink":"https://gongzza.github.io/categories/Node-js/Express/"},{"name":"Install","slug":"Linux/Install","permalink":"https://gongzza.github.io/categories/Linux/Install/"},{"name":"Webpack","slug":"Webpack","permalink":"https://gongzza.github.io/categories/Webpack/"},{"name":"PHP","slug":"PHP","permalink":"https://gongzza.github.io/categories/PHP/"},{"name":"Laravel","slug":"PHP/Laravel","permalink":"https://gongzza.github.io/categories/PHP/Laravel/"},{"name":"Yeoman","slug":"Yeoman","permalink":"https://gongzza.github.io/categories/Yeoman/"}],"tags":[{"name":"mocha","slug":"mocha","permalink":"https://gongzza.github.io/tags/mocha/"},{"name":"vscode","slug":"vscode","permalink":"https://gongzza.github.io/tags/vscode/"},{"name":"debugging","slug":"debugging","permalink":"https://gongzza.github.io/tags/debugging/"},{"name":"mac","slug":"mac","permalink":"https://gongzza.github.io/tags/mac/"},{"name":"shortcut","slug":"shortcut","permalink":"https://gongzza.github.io/tags/shortcut/"},{"name":"bettertouchtool","slug":"bettertouchtool","permalink":"https://gongzza.github.io/tags/bettertouchtool/"},{"name":"vi","slug":"vi","permalink":"https://gongzza.github.io/tags/vi/"},{"name":"mysql","slug":"mysql","permalink":"https://gongzza.github.io/tags/mysql/"},{"name":"FullText","slug":"FullText","permalink":"https://gongzza.github.io/tags/FullText/"},{"name":"typescript","slug":"typescript","permalink":"https://gongzza.github.io/tags/typescript/"},{"name":"dotenv","slug":"dotenv","permalink":"https://gongzza.github.io/tags/dotenv/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://gongzza.github.io/tags/nuxt-js/"},{"name":"nuxt-typescript","slug":"nuxt-typescript","permalink":"https://gongzza.github.io/tags/nuxt-typescript/"},{"name":"iterm2","slug":"iterm2","permalink":"https://gongzza.github.io/tags/iterm2/"},{"name":"finder","slug":"finder","permalink":"https://gongzza.github.io/tags/finder/"},{"name":"graphql","slug":"graphql","permalink":"https://gongzza.github.io/tags/graphql/"},{"name":"apollo","slug":"apollo","permalink":"https://gongzza.github.io/tags/apollo/"},{"name":"type-graphql","slug":"type-graphql","permalink":"https://gongzza.github.io/tags/type-graphql/"},{"name":"express","slug":"express","permalink":"https://gongzza.github.io/tags/express/"},{"name":"test","slug":"test","permalink":"https://gongzza.github.io/tags/test/"},{"name":"chai","slug":"chai","permalink":"https://gongzza.github.io/tags/chai/"},{"name":"supertest","slug":"supertest","permalink":"https://gongzza.github.io/tags/supertest/"},{"name":"postgresql","slug":"postgresql","permalink":"https://gongzza.github.io/tags/postgresql/"},{"name":"trigger","slug":"trigger","permalink":"https://gongzza.github.io/tags/trigger/"},{"name":"docker","slug":"docker","permalink":"https://gongzza.github.io/tags/docker/"},{"name":"oracle","slug":"oracle","permalink":"https://gongzza.github.io/tags/oracle/"},{"name":"mariadb","slug":"mariadb","permalink":"https://gongzza.github.io/tags/mariadb/"},{"name":"postgres","slug":"postgres","permalink":"https://gongzza.github.io/tags/postgres/"},{"name":"mongodb","slug":"mongodb","permalink":"https://gongzza.github.io/tags/mongodb/"},{"name":"mssql","slug":"mssql","permalink":"https://gongzza.github.io/tags/mssql/"},{"name":"nginx","slug":"nginx","permalink":"https://gongzza.github.io/tags/nginx/"},{"name":"linux","slug":"linux","permalink":"https://gongzza.github.io/tags/linux/"},{"name":"learning","slug":"learning","permalink":"https://gongzza.github.io/tags/learning/"},{"name":"jest","slug":"jest","permalink":"https://gongzza.github.io/tags/jest/"},{"name":"java","slug":"java","permalink":"https://gongzza.github.io/tags/java/"},{"name":"junit","slug":"junit","permalink":"https://gongzza.github.io/tags/junit/"},{"name":"database","slug":"database","permalink":"https://gongzza.github.io/tags/database/"},{"name":"h2","slug":"h2","permalink":"https://gongzza.github.io/tags/h2/"},{"name":"spring","slug":"spring","permalink":"https://gongzza.github.io/tags/spring/"},{"name":"mybatis","slug":"mybatis","permalink":"https://gongzza.github.io/tags/mybatis/"},{"name":"eclipse","slug":"eclipse","permalink":"https://gongzza.github.io/tags/eclipse/"},{"name":"eclipse-plugin","slug":"eclipse-plugin","permalink":"https://gongzza.github.io/tags/eclipse-plugin/"},{"name":"tdd","slug":"tdd","permalink":"https://gongzza.github.io/tags/tdd/"},{"name":"adonisjs","slug":"adonisjs","permalink":"https://gongzza.github.io/tags/adonisjs/"},{"name":"swagger-ui","slug":"swagger-ui","permalink":"https://gongzza.github.io/tags/swagger-ui/"},{"name":"swagger-jsdoc","slug":"swagger-jsdoc","permalink":"https://gongzza.github.io/tags/swagger-jsdoc/"},{"name":"node.js","slug":"node-js","permalink":"https://gongzza.github.io/tags/node-js/"},{"name":"vue.js","slug":"vue-js","permalink":"https://gongzza.github.io/tags/vue-js/"},{"name":"storybook","slug":"storybook","permalink":"https://gongzza.github.io/tags/storybook/"},{"name":"vuejs","slug":"vuejs","permalink":"https://gongzza.github.io/tags/vuejs/"},{"name":"webpack","slug":"webpack","permalink":"https://gongzza.github.io/tags/webpack/"},{"name":"lazy-loading","slug":"lazy-loading","permalink":"https://gongzza.github.io/tags/lazy-loading/"},{"name":"component","slug":"component","permalink":"https://gongzza.github.io/tags/component/"},{"name":"vue-router","slug":"vue-router","permalink":"https://gongzza.github.io/tags/vue-router/"},{"name":"vue-test-utils","slug":"vue-test-utils","permalink":"https://gongzza.github.io/tags/vue-test-utils/"},{"name":"knex.js","slug":"knex-js","permalink":"https://gongzza.github.io/tags/knex-js/"},{"name":"bookshelf.js","slug":"bookshelf-js","permalink":"https://gongzza.github.io/tags/bookshelf-js/"},{"name":"mock-knex","slug":"mock-knex","permalink":"https://gongzza.github.io/tags/mock-knex/"},{"name":"ts-node","slug":"ts-node","permalink":"https://gongzza.github.io/tags/ts-node/"},{"name":"tslint","slug":"tslint","permalink":"https://gongzza.github.io/tags/tslint/"},{"name":"swagger-ui-express","slug":"swagger-ui-express","permalink":"https://gongzza.github.io/tags/swagger-ui-express/"},{"name":"install","slug":"install","permalink":"https://gongzza.github.io/tags/install/"},{"name":"centos","slug":"centos","permalink":"https://gongzza.github.io/tags/centos/"},{"name":"https","slug":"https","permalink":"https://gongzza.github.io/tags/https/"},{"name":"letsencrypt","slug":"letsencrypt","permalink":"https://gongzza.github.io/tags/letsencrypt/"},{"name":"ava","slug":"ava","permalink":"https://gongzza.github.io/tags/ava/"},{"name":"mongoose","slug":"mongoose","permalink":"https://gongzza.github.io/tags/mongoose/"},{"name":"babel-cli","slug":"babel-cli","permalink":"https://gongzza.github.io/tags/babel-cli/"},{"name":"semantic-ui","slug":"semantic-ui","permalink":"https://gongzza.github.io/tags/semantic-ui/"},{"name":"toastr","slug":"toastr","permalink":"https://gongzza.github.io/tags/toastr/"},{"name":"lazyload","slug":"lazyload","permalink":"https://gongzza.github.io/tags/lazyload/"},{"name":"todomvc","slug":"todomvc","permalink":"https://gongzza.github.io/tags/todomvc/"},{"name":"php","slug":"php","permalink":"https://gongzza.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://gongzza.github.io/tags/laravel/"},{"name":"hubot","slug":"hubot","permalink":"https://gongzza.github.io/tags/hubot/"},{"name":"slack","slug":"slack","permalink":"https://gongzza.github.io/tags/slack/"},{"name":"yeoman-generator","slug":"yeoman-generator","permalink":"https://gongzza.github.io/tags/yeoman-generator/"},{"name":"generator-v","slug":"generator-v","permalink":"https://gongzza.github.io/tags/generator-v/"},{"name":"babel","slug":"babel","permalink":"https://gongzza.github.io/tags/babel/"},{"name":"eslint","slug":"eslint","permalink":"https://gongzza.github.io/tags/eslint/"},{"name":"javascript","slug":"javascript","permalink":"https://gongzza.github.io/tags/javascript/"},{"name":"phantomjs","slug":"phantomjs","permalink":"https://gongzza.github.io/tags/phantomjs/"},{"name":"wget","slug":"wget","permalink":"https://gongzza.github.io/tags/wget/"}]}